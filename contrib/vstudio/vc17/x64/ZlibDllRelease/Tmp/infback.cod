; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35209.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type@		; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@	; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@ DB 'invalid distanc'
	DB	'e too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code@ DB 'invalid distance code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@ DB 'invalid literal/le'
	DB	'ngth code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set@ DB 'invalid distances set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@ DB 'invalid literal/le'
	DB	'ngths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@ DB 'invalid c'
	DB	'ode -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@ DB 'invalid bit length r'
	DB	'epeat', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@ DB 'invalid code lengths '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@ DB 'too many len'
	DB	'gth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@ DB 'invalid stored bl'
	DB	'ock lengths', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type@ DB 'invalid block type', 00H ; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateBackEnd
PUBLIC	inflateBack
PUBLIC	inflateBackInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN9
	DD	imagerel $LN9+65
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN636
	DD	imagerel $LN636+64
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateBack DD imagerel $LN636+64
	DD	imagerel $LN636+95
	DD	imagerel $chain$2$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBack DD imagerel $LN636+95
	DD	imagerel $LN636+3774
	DD	imagerel $chain$3$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBack DD imagerel $LN636+3774
	DD	imagerel $LN636+3841
	DD	imagerel $chain$4$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateBack DD imagerel $LN636+3841
	DD	imagerel $LN636+3936
	DD	imagerel $chain$5$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN22
	DD	imagerel $LN22+87
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateBackInit_ DD imagerel $LN22+87
	DD	imagerel $LN22+190
	DD	imagerel $chain$0$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateBackInit_ DD imagerel $LN22+190
	DD	imagerel $LN22+238
	DD	imagerel $chain$2$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBackInit_ DD imagerel $LN22+238
	DD	imagerel $LN22+280
	DD	imagerel $chain$3$inflateBackInit_
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBackInit_ DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateBackInit_ DD 020021H
	DD	065400H
	DD	imagerel $LN22
	DD	imagerel $LN22+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateBackInit_ DD 020521H
	DD	065405H
	DD	imagerel $LN22
	DD	imagerel $LN22+87
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateBack DD 021H
	DD	imagerel $LN636
	DD	imagerel $LN636+64
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBack DD 021H
	DD	imagerel $LN636+64
	DD	imagerel $LN636+95
	DD	imagerel $chain$2$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBack DD 020421H
	DD	0be404H
	DD	imagerel $LN636+64
	DD	imagerel $LN636+95
	DD	imagerel $chain$2$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateBack DD 060f21H
	DD	0c740fH
	DD	0d640bH
	DD	0e3404H
	DD	imagerel $LN636
	DD	imagerel $LN636+64
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 052101H
	DD	0f01ae221H
	DD	0c016d018H
	DD	05014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\infback.c
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
window$ = 64
version$ = 72
stream_size$ = 80
inflateBackInit_ PROC					; COMDAT

; 27   :                              int stream_size) {

$LN22:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f0	 mov	 rsi, r8
  00012	8b fa		 mov	 edi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 28   :     struct inflate_state FAR *state;
; 29   : 
; 30   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00017	4d 85 c9	 test	 r9, r9
  0001a	0f 84 e3 00 00
	00		 je	 $LN3@inflateBac
  00020	41 80 39 31	 cmp	 BYTE PTR [r9], 49	; 00000031H
  00024	0f 85 d9 00 00
	00		 jne	 $LN3@inflateBac
  0002a	83 7c 24 50 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0002f	0f 85 ce 00 00
	00		 jne	 $LN3@inflateBac

; 31   :         stream_size != (int)(sizeof(z_stream)))
; 32   :         return Z_VERSION_ERROR;
; 33   :     if (strm == Z_NULL || window == Z_NULL ||
; 34   :         windowBits < 8 || windowBits > 15)

  00035	48 85 c9	 test	 rcx, rcx
  00038	0f 84 b0 00 00
	00		 je	 $LN5@inflateBac
  0003e	4d 85 c0	 test	 r8, r8
  00041	0f 84 a7 00 00
	00		 je	 $LN5@inflateBac
  00047	8d 42 f8	 lea	 eax, DWORD PTR [rdx-8]
  0004a	83 f8 07	 cmp	 eax, 7
  0004d	0f 87 9b 00 00
	00		 ja	 $LN5@inflateBac

; 36   :     strm->msg = Z_NULL;                 /* in case we return an error */
; 37   :     if (strm->zalloc == (alloc_func)0) {

  00053	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00057	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0005c	33 ed		 xor	 ebp, ebp
  0005e	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp
  00062	48 85 c0	 test	 rax, rax
  00065	75 13		 jne	 SHORT $LN10@inflateBac

; 38   : #ifdef Z_SOLO
; 39   :         return Z_STREAM_ERROR;
; 40   : #else
; 41   :         strm->zalloc = zcalloc;

  00067	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 42   :         strm->opaque = (voidpf)0;

  0006e	48 89 69 40	 mov	 QWORD PTR [rcx+64], rbp
  00072	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  00076	8b cd		 mov	 ecx, ebp
  00078	eb 04		 jmp	 SHORT $LN6@inflateBac
$LN10@inflateBac:
  0007a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
$LN6@inflateBac:

; 43   : #endif
; 44   :     }
; 45   :     if (strm->zfree == (free_func)0)

  0007e	48 39 6b 38	 cmp	 QWORD PTR [rbx+56], rbp
  00082	75 0b		 jne	 SHORT $LN7@inflateBac

; 46   : #ifdef Z_SOLO
; 47   :         return Z_STREAM_ERROR;
; 48   : #else
; 49   :     strm->zfree = zcfree;

  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:zcfree
  0008b	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
$LN7@inflateBac:

; 50   : #endif
; 51   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,

  0008f	ba 01 00 00 00	 mov	 edx, 1
  00094	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  0009a	ff d0		 call	 rax
  0009c	48 8b d0	 mov	 rdx, rax

; 52   :                                                sizeof(struct inflate_state));
; 53   :     if (state == Z_NULL) return Z_MEM_ERROR;

  0009f	48 85 c0	 test	 rax, rax
  000a2	75 1a		 jne	 SHORT $LN8@inflateBac
  000a4	b8 fc ff ff ff	 mov	 eax, -4
$LN20@inflateBac:
  000a9	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 64   : }

  000ae	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000b3	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
$LN8@inflateBac:

; 54   :     Tracev((stderr, "inflate: allocated\n"));
; 55   :     strm->state = (struct internal_state FAR *)state;

  000be	48 89 53 28	 mov	 QWORD PTR [rbx+40], rdx

; 56   :     state->dmax = 32768U;
; 57   :     state->wbits = (uInt)windowBits;
; 58   :     state->wsize = 1U << windowBits;

  000c2	8b cf		 mov	 ecx, edi
  000c4	c7 40 1c 00 80
	00 00		 mov	 DWORD PTR [rax+28], 32768 ; 00008000H
  000cb	89 78 30	 mov	 DWORD PTR [rax+48], edi
  000ce	b8 01 00 00 00	 mov	 eax, 1
  000d3	d3 e0		 shl	 eax, cl
  000d5	89 42 34	 mov	 DWORD PTR [rdx+52], eax

; 59   :     state->window = window;
; 60   :     state->wnext = 0;
; 61   :     state->whave = 0;
; 62   :     state->sane = 1;
; 63   :     return Z_OK;

  000d8	33 c0		 xor	 eax, eax
  000da	48 89 72 40	 mov	 QWORD PTR [rdx+64], rsi
  000de	48 89 6a 38	 mov	 QWORD PTR [rdx+56], rbp
  000e2	c7 82 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rdx+7136], 1
  000ec	eb bb		 jmp	 SHORT $LN20@inflateBac
$LN5@inflateBac:

; 35   :         return Z_STREAM_ERROR;

  000ee	b8 fe ff ff ff	 mov	 eax, -2

; 64   : }

  000f3	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000f8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000fd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00101	5f		 pop	 rdi
  00102	c3		 ret	 0
$LN3@inflateBac:
  00103	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00108	b8 fa ff ff ff	 mov	 eax, -6
  0010d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00112	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00116	5f		 pop	 rdi
  00117	c3		 ret	 0
inflateBackInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\infback.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 77   : #ifdef BUILDFIXED
; 78   :     static int virgin = 1;
; 79   :     static code *lenfix, *distfix;
; 80   :     static code fixed[544];
; 81   : 
; 82   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 83   :     if (virgin) {
; 84   :         unsigned sym, bits;
; 85   :         static code *next;
; 86   : 
; 87   :         /* literal/length table */
; 88   :         sym = 0;
; 89   :         while (sym < 144) state->lens[sym++] = 8;
; 90   :         while (sym < 256) state->lens[sym++] = 9;
; 91   :         while (sym < 280) state->lens[sym++] = 7;
; 92   :         while (sym < 288) state->lens[sym++] = 8;
; 93   :         next = fixed;
; 94   :         lenfix = next;
; 95   :         bits = 9;
; 96   :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 97   : 
; 98   :         /* distance table */
; 99   :         sym = 0;
; 100  :         while (sym < 32) state->lens[sym++] = 5;
; 101  :         distfix = next;
; 102  :         bits = 5;
; 103  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 104  : 
; 105  :         /* do this just once */
; 106  :         virgin = 0;
; 107  :     }
; 108  : #else /* !BUILDFIXED */
; 109  : #   include "inffixed.h"
; 110  : #endif /* BUILDFIXED */
; 111  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 112  :     state->lenbits = 9;

  00007	c7 41 70 09 00
	00 00		 mov	 DWORD PTR [rcx+112], 9
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 113  :     state->distcode = distfix;

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00019	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 114  :     state->distbits = 5;

  0001d	c7 41 74 05 00
	00 00		 mov	 DWORD PTR [rcx+116], 5

; 115  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\infback.c
;	COMDAT inflateBack
_TEXT	SEGMENT
left$1$ = 48
here$ = 52
last$ = 52
next$ = 56
put$1$ = 64
strm$ = 160
in$ = 168
in_desc$ = 176
out$ = 184
out_desc$ = 192
inflateBack PROC					; COMDAT

; 243  :                         out_func out, void FAR *out_desc) {

$LN636:
  00000	48 8b c4	 mov	 rax, rsp
  00003	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	55		 push	 rbp
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 57		 push	 r15
  0001a	48 8b ec	 mov	 rbp, rsp
  0001d	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00021	4d 8b e0	 mov	 r12, r8
  00024	4c 8b fa	 mov	 r15, rdx
  00027	4c 8b c9	 mov	 r9, rcx

; 244  :     struct inflate_state FAR *state;
; 245  :     z_const unsigned char FAR *next;    /* next input */
; 246  :     unsigned char FAR *put;     /* next output */
; 247  :     unsigned have, left;        /* available input and output */
; 248  :     unsigned long hold;         /* bit buffer */
; 249  :     unsigned bits;              /* bits in bit buffer */
; 250  :     unsigned copy;              /* number of stored or match bytes to copy */
; 251  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 252  :     code here;                  /* current decoding table entry */
; 253  :     code last;                  /* parent table entry */
; 254  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 255  :     int ret;                    /* return code */
; 256  :     static const unsigned short order[19] = /* permutation of code lengths */
; 257  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 258  : 
; 259  :     /* Check that the strm exists and that the state was initialized */
; 260  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0002a	48 85 c9	 test	 rcx, rcx
  0002d	0f 84 ce 0e 00
	00		 je	 $LN254@inflateBac
  00033	4c 8b 69 28	 mov	 r13, QWORD PTR [rcx+40]
  00037	4d 85 ed	 test	 r13, r13
  0003a	0f 84 c1 0e 00
	00		 je	 $LN254@inflateBac
  00040	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx

; 262  :     state = (struct inflate_state FAR *)strm->state;
; 263  : 
; 264  :     /* Reset the state */
; 265  :     strm->msg = Z_NULL;

  00044	45 33 d2	 xor	 r10d, r10d
  00047	48 89 70 d0	 mov	 QWORD PTR [rax-48], rsi
  0004b	48 89 78 c8	 mov	 QWORD PTR [rax-56], rdi
  0004f	4c 89 51 20	 mov	 QWORD PTR [rcx+32], r10

; 266  :     state->mode = TYPE;

  00053	49 c7 45 08 3f
	3f 00 00	 mov	 QWORD PTR [r13+8], 16191 ; 00003f3fH

; 267  :     state->last = 0;
; 268  :     state->whave = 0;

  0005b	45 89 55 38	 mov	 DWORD PTR [r13+56], r10d
  0005f	4c 89 70 c0	 mov	 QWORD PTR [rax-64], r14

; 269  :     next = strm->next_in;

  00063	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00066	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
  0006a	48 85 c0	 test	 rax, rax

; 270  :     have = next != Z_NULL ? strm->avail_in : 0;

  0006d	74 05		 je	 SHORT $LN343@inflateBac
  0006f	8b 79 08	 mov	 edi, DWORD PTR [rcx+8]
  00072	eb 03		 jmp	 SHORT $LN344@inflateBac
$LN343@inflateBac:
  00074	41 8b fa	 mov	 edi, r10d
$LN344@inflateBac:

; 271  :     hold = 0;
; 272  :     bits = 0;
; 273  :     put = state->window;
; 274  :     left = state->wsize;
; 275  : 
; 276  :     /* Inflate until end of block marked as last */
; 277  :     for (;;)
; 278  :         switch (state->mode) {

  00077	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  0007b	45 8b f2	 mov	 r14d, r10d
  0007e	49 8b 5d 40	 mov	 rbx, QWORD PTR [r13+64]
  00082	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00087	45 8b 45 34	 mov	 r8d, DWORD PTR [r13+52]
  0008b	41 8b f2	 mov	 esi, r10d
  0008e	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00092	44 89 45 b8	 mov	 DWORD PTR left$1$[rbp-120], r8d
  00096	83 f8 12	 cmp	 eax, 18
  00099	0f 87 ff 0d 00
	00		 ja	 $LN339@inflateBac
$LN632@inflateBac:
  0009f	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  000a6	48 98		 cdqe
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@
  000af	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN511@inflateBac[r11+rax*4]
  000b7	49 03 cb	 add	 rcx, r11
  000ba	ff e1		 jmp	 rcx
$LN255@inflateBac:

; 279  :         case TYPE:
; 280  :             /* determine and dispatch block type */
; 281  :             if (state->last) {

  000bc	41 83 7d 0c 00	 cmp	 DWORD PTR [r13+12], 0
  000c1	74 17		 je	 SHORT $LN12@inflateBac

; 282  :                 BYTEBITS();

  000c3	8b ce		 mov	 ecx, esi

; 283  :                 state->mode = DONE;

  000c5	41 c7 45 08 50
	3f 00 00	 mov	 DWORD PTR [r13+8], 16208 ; 00003f50H
  000cd	83 e1 07	 and	 ecx, 7
  000d0	41 d3 ee	 shr	 r14d, cl
  000d3	2b f1		 sub	 esi, ecx

; 284  :                 break;

  000d5	e9 8c 0d 00 00	 jmp	 $LN2@inflateBac
$LN12@inflateBac:

; 285  :             }
; 286  :             NEEDBITS(3);

  000da	83 fe 03	 cmp	 esi, 3
  000dd	73 47		 jae	 SHORT $LN10@inflateBac
  000df	90		 npad	 1
$LL13@inflateBac:
  000e0	85 ff		 test	 edi, edi
  000e2	75 14		 jne	 SHORT $LN18@inflateBac
  000e4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  000e8	49 8b cc	 mov	 rcx, r12
  000eb	41 ff d7	 call	 r15
  000ee	8b f8		 mov	 edi, eax
  000f0	85 c0		 test	 eax, eax
  000f2	0f 84 89 0d 00
	00		 je	 $LN369@inflateBac
$LN18@inflateBac:
  000f8	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  000fc	8b ce		 mov	 ecx, esi
  000fe	ff cf		 dec	 edi
  00100	83 c6 08	 add	 esi, 8
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  0010a	d3 e0		 shl	 eax, cl
  0010c	44 03 f0	 add	 r14d, eax
  0010f	83 fe 03	 cmp	 esi, 3
  00112	72 cc		 jb	 SHORT $LL13@inflateBac
  00114	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@
  0011f	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  00123	45 33 d2	 xor	 r10d, r10d
$LN10@inflateBac:

; 287  :             state->last = BITS(1);

  00126	41 8b c6	 mov	 eax, r14d

; 288  :             DROPBITS(1);

  00129	41 d1 ee	 shr	 r14d, 1
  0012c	83 e0 01	 and	 eax, 1
  0012f	41 89 45 0c	 mov	 DWORD PTR [r13+12], eax

; 289  :             switch (BITS(2)) {

  00133	41 8b c6	 mov	 eax, r14d
  00136	83 e0 03	 and	 eax, 3
  00139	74 57		 je	 SHORT $LN259@inflateBac
  0013b	83 e8 01	 sub	 eax, 1
  0013e	74 36		 je	 SHORT $LN260@inflateBac
  00140	83 e8 01	 sub	 eax, 1
  00143	74 1d		 je	 SHORT $LN261@inflateBac
  00145	83 f8 01	 cmp	 eax, 1
  00148	75 50		 jne	 SHORT $LN28@inflateBac

; 297  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 298  :                         state->last ? " (last)" : ""));
; 299  :                 state->mode = LEN;              /* decode codes */
; 300  :                 break;
; 301  :             case 2:                             /* dynamic block */
; 302  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 303  :                         state->last ? " (last)" : ""));
; 304  :                 state->mode = TABLE;
; 305  :                 break;
; 306  :             case 3:
; 307  :                 strm->msg = (z_const char *)"invalid block type";
; 308  :                 state->mode = BAD;
; 309  :             }
; 310  :             DROPBITS(2);

  0014a	41 c1 ee 02	 shr	 r14d, 2
  0014e	49 89 51 20	 mov	 QWORD PTR [r9+32], rdx
  00152	83 c6 fd	 add	 esi, -3			; fffffffdH
  00155	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 311  :             break;

  0015d	e9 04 0d 00 00	 jmp	 $LN2@inflateBac
$LN261@inflateBac:

; 297  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 298  :                         state->last ? " (last)" : ""));
; 299  :                 state->mode = LEN;              /* decode codes */
; 300  :                 break;
; 301  :             case 2:                             /* dynamic block */
; 302  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 303  :                         state->last ? " (last)" : ""));
; 304  :                 state->mode = TABLE;
; 305  :                 break;
; 306  :             case 3:
; 307  :                 strm->msg = (z_const char *)"invalid block type";
; 308  :                 state->mode = BAD;
; 309  :             }
; 310  :             DROPBITS(2);

  00162	41 c1 ee 02	 shr	 r14d, 2
  00166	83 c6 fd	 add	 esi, -3			; fffffffdH
  00169	41 c7 45 08 44
	3f 00 00	 mov	 DWORD PTR [r13+8], 16196 ; 00003f44H

; 311  :             break;

  00171	e9 f0 0c 00 00	 jmp	 $LN2@inflateBac
$LN260@inflateBac:

; 294  :                 break;
; 295  :             case 1:                             /* fixed block */
; 296  :                 fixedtables(state);

  00176	49 8b cd	 mov	 rcx, r13
  00179	e8 00 00 00 00	 call	 fixedtables

; 297  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 298  :                         state->last ? " (last)" : ""));
; 299  :                 state->mode = LEN;              /* decode codes */
; 300  :                 break;
; 301  :             case 2:                             /* dynamic block */
; 302  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 303  :                         state->last ? " (last)" : ""));
; 304  :                 state->mode = TABLE;
; 305  :                 break;
; 306  :             case 3:
; 307  :                 strm->msg = (z_const char *)"invalid block type";
; 308  :                 state->mode = BAD;
; 309  :             }
; 310  :             DROPBITS(2);

  0017e	41 c1 ee 02	 shr	 r14d, 2
  00182	83 c6 fd	 add	 esi, -3			; fffffffdH
  00185	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 311  :             break;

  0018d	e9 d4 0c 00 00	 jmp	 $LN2@inflateBac
$LN259@inflateBac:

; 290  :             case 0:                             /* stored block */
; 291  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 292  :                         state->last ? " (last)" : ""));
; 293  :                 state->mode = STORED;

  00192	41 c7 45 08 41
	3f 00 00	 mov	 DWORD PTR [r13+8], 16193 ; 00003f41H
$LN28@inflateBac:

; 297  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 298  :                         state->last ? " (last)" : ""));
; 299  :                 state->mode = LEN;              /* decode codes */
; 300  :                 break;
; 301  :             case 2:                             /* dynamic block */
; 302  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 303  :                         state->last ? " (last)" : ""));
; 304  :                 state->mode = TABLE;
; 305  :                 break;
; 306  :             case 3:
; 307  :                 strm->msg = (z_const char *)"invalid block type";
; 308  :                 state->mode = BAD;
; 309  :             }
; 310  :             DROPBITS(2);

  0019a	41 c1 ee 02	 shr	 r14d, 2
  0019e	83 c6 fd	 add	 esi, -3			; fffffffdH

; 311  :             break;

  001a1	e9 c0 0c 00 00	 jmp	 $LN2@inflateBac
$LN31@inflateBac:

; 312  : 
; 313  :         case STORED:
; 314  :             /* get and verify stored block length */
; 315  :             BYTEBITS();                         /* go to byte boundary */

  001a6	8b ce		 mov	 ecx, esi
  001a8	83 e1 07	 and	 ecx, 7
  001ab	41 d3 ee	 shr	 r14d, cl
  001ae	2b f1		 sub	 esi, ecx

; 316  :             NEEDBITS(32);

  001b0	83 fe 20	 cmp	 esi, 32			; 00000020H
  001b3	73 3f		 jae	 SHORT $LN32@inflateBac
$LL35@inflateBac:
  001b5	85 ff		 test	 edi, edi
  001b7	75 14		 jne	 SHORT $LN40@inflateBac
  001b9	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  001bd	49 8b cc	 mov	 rcx, r12
  001c0	41 ff d7	 call	 r15
  001c3	8b f8		 mov	 edi, eax
  001c5	85 c0		 test	 eax, eax
  001c7	0f 84 b4 0c 00
	00		 je	 $LN369@inflateBac
$LN40@inflateBac:
  001cd	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  001d1	8b ce		 mov	 ecx, esi
  001d3	ff cf		 dec	 edi
  001d5	83 c6 08	 add	 esi, 8
  001d8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001db	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  001df	d3 e0		 shl	 eax, cl
  001e1	44 03 f0	 add	 r14d, eax
  001e4	83 fe 20	 cmp	 esi, 32			; 00000020H
  001e7	72 cc		 jb	 SHORT $LL35@inflateBac
  001e9	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  001ed	45 33 d2	 xor	 r10d, r10d
  001f0	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
$LN32@inflateBac:

; 317  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  001f4	41 8b c6	 mov	 eax, r14d
  001f7	45 0f b7 fe	 movzx	 r15d, r14w
  001fb	f7 d0		 not	 eax
  001fd	c1 e8 10	 shr	 eax, 16
  00200	44 3b f8	 cmp	 r15d, eax
  00203	74 18		 je	 SHORT $LN266@inflateBac

; 318  :                 strm->msg = (z_const char *)"invalid stored block lengths";

  00205	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  0020c	49 89 41 20	 mov	 QWORD PTR [r9+32], rax

; 319  :                 state->mode = BAD;

  00210	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 320  :                 break;

  00218	e9 49 0c 00 00	 jmp	 $LN2@inflateBac
$LN266@inflateBac:

; 321  :             }
; 322  :             state->length = (unsigned)hold & 0xffff;

  0021d	45 89 7d 50	 mov	 DWORD PTR [r13+80], r15d

; 323  :             Tracev((stderr, "inflate:       stored length %u\n",
; 324  :                     state->length));
; 325  :             INITBITS();

  00221	45 8b f2	 mov	 r14d, r10d
  00224	41 8b f2	 mov	 esi, r10d

; 326  : 
; 327  :             /* copy stored block from input to output */
; 328  :             while (state->length != 0) {

  00227	45 85 ff	 test	 r15d, r15d
  0022a	0f 84 93 00 00
	00		 je	 $LN47@inflateBac
$LL46@inflateBac:

; 329  :                 copy = state->length;
; 330  :                 PULL();

  00230	85 ff		 test	 edi, edi
  00232	75 14		 jne	 SHORT $LN48@inflateBac
  00234	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00238	49 8b cc	 mov	 rcx, r12
  0023b	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  0023e	8b f8		 mov	 edi, eax
  00240	85 c0		 test	 eax, eax
  00242	0f 84 39 0c 00
	00		 je	 $LN369@inflateBac
$LN48@inflateBac:

; 331  :                 ROOM();

  00248	8b 5d b8	 mov	 ebx, DWORD PTR left$1$[rbp-120]
  0024b	85 db		 test	 ebx, ebx
  0024d	75 28		 jne	 SHORT $LN51@inflateBac
  0024f	41 8b 5d 34	 mov	 ebx, DWORD PTR [r13+52]
  00253	44 8b c3	 mov	 r8d, ebx
  00256	49 8b 45 40	 mov	 rax, QWORD PTR [r13+64]
  0025a	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  0025e	48 8b d0	 mov	 rdx, rax
  00261	48 89 45 c8	 mov	 QWORD PTR put$1$[rbp-120], rax
  00265	89 5d b8	 mov	 DWORD PTR left$1$[rbp-120], ebx
  00268	41 89 5d 38	 mov	 DWORD PTR [r13+56], ebx
  0026c	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  0026f	85 c0		 test	 eax, eax
  00271	0f 85 10 0c 00
	00		 jne	 $LN372@inflateBac
$LN51@inflateBac:

; 332  :                 if (copy > have) copy = have;
; 333  :                 if (copy > left) copy = left;
; 334  :                 zmemcpy(put, next, copy);

  00277	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  0027b	44 3b ff	 cmp	 r15d, edi
  0027e	48 8b 4d c8	 mov	 rcx, QWORD PTR put$1$[rbp-120]
  00282	44 0f 47 ff	 cmova	 r15d, edi
  00286	44 3b fb	 cmp	 r15d, ebx
  00289	44 0f 47 fb	 cmova	 r15d, ebx
  0028d	45 8b c7	 mov	 r8d, r15d
  00290	41 8b df	 mov	 ebx, r15d
  00293	e8 00 00 00 00	 call	 memcpy

; 335  :                 have -= copy;
; 336  :                 next += copy;
; 337  :                 left -= copy;

  00298	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  0029c	41 2b ff	 sub	 edi, r15d
  0029f	48 01 5d c0	 add	 QWORD PTR next$[rbp-120], rbx
  002a3	45 2b c7	 sub	 r8d, r15d

; 338  :                 put += copy;

  002a6	48 01 5d c8	 add	 QWORD PTR put$1$[rbp-120], rbx

; 339  :                 state->length -= copy;

  002aa	45 29 7d 50	 sub	 DWORD PTR [r13+80], r15d
  002ae	45 8b 7d 50	 mov	 r15d, DWORD PTR [r13+80]
  002b2	44 89 45 b8	 mov	 DWORD PTR left$1$[rbp-120], r8d
  002b6	0f 85 74 ff ff
	ff		 jne	 $LL46@inflateBac
  002bc	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  002c0	45 33 d2	 xor	 r10d, r10d
$LN47@inflateBac:

; 340  :             }
; 341  :             Tracev((stderr, "inflate:       stored end\n"));
; 342  :             state->mode = TYPE;

  002c3	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH

; 343  :             break;

  002cb	e9 92 0b 00 00	 jmp	 $LN630@inflateBac
$LN56@inflateBac:

; 344  : 
; 345  :         case TABLE:
; 346  :             /* get dynamic table entries descriptor */
; 347  :             NEEDBITS(14);

  002d0	83 fe 0e	 cmp	 esi, 14
  002d3	73 42		 jae	 SHORT $LN54@inflateBac
$LL57@inflateBac:
  002d5	85 ff		 test	 edi, edi
  002d7	75 14		 jne	 SHORT $LN62@inflateBac
  002d9	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  002dd	49 8b cc	 mov	 rcx, r12
  002e0	41 ff d7	 call	 r15
  002e3	8b f8		 mov	 edi, eax
  002e5	85 c0		 test	 eax, eax
  002e7	0f 84 94 0b 00
	00		 je	 $LN369@inflateBac
$LN62@inflateBac:
  002ed	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  002f1	8b ce		 mov	 ecx, esi
  002f3	ff cf		 dec	 edi
  002f5	83 c6 08	 add	 esi, 8
  002f8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002fb	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  002ff	d3 e0		 shl	 eax, cl
  00301	44 03 f0	 add	 r14d, eax
  00304	83 fe 0e	 cmp	 esi, 14
  00307	72 cc		 jb	 SHORT $LL57@inflateBac
  00309	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  0030d	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  00314	45 33 d2	 xor	 r10d, r10d
$LN54@inflateBac:

; 348  :             state->nlen = BITS(5) + 257;

  00317	41 8b ce	 mov	 ecx, r14d

; 349  :             DROPBITS(5);
; 350  :             state->ndist = BITS(5) + 1;
; 351  :             DROPBITS(5);
; 352  :             state->ncode = BITS(4) + 4;
; 353  :             DROPBITS(4);

  0031a	83 c6 f2	 add	 esi, -14		; fffffff2H
  0031d	41 c1 ee 05	 shr	 r14d, 5
  00321	83 e1 1f	 and	 ecx, 31
  00324	41 8b d6	 mov	 edx, r14d
  00327	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  0032d	41 c1 ee 05	 shr	 r14d, 5
  00331	83 e2 1f	 and	 edx, 31
  00334	45 8b c6	 mov	 r8d, r14d
  00337	41 89 4d 7c	 mov	 DWORD PTR [r13+124], ecx
  0033b	41 83 e0 0f	 and	 r8d, 15
  0033f	41 c1 ee 04	 shr	 r14d, 4
  00343	41 83 c0 04	 add	 r8d, 4
  00347	ff c2		 inc	 edx
  00349	41 89 95 80 00
	00 00		 mov	 DWORD PTR [r13+128], edx
  00350	45 89 45 78	 mov	 DWORD PTR [r13+120], r8d

; 354  : #ifndef PKZIP_BUG_WORKAROUND
; 355  :             if (state->nlen > 286 || state->ndist > 30) {

  00354	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  0035a	0f 87 bd 05 00
	00		 ja	 $LN277@inflateBac
  00360	83 fa 1e	 cmp	 edx, 30
  00363	0f 87 b4 05 00
	00		 ja	 $LN277@inflateBac

; 359  :             }
; 360  : #endif
; 361  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 362  : 
; 363  :             /* get code length code lengths (not a typo) */
; 364  :             state->have = 0;

  00369	45 89 95 84 00
	00 00		 mov	 DWORD PTR [r13+132], r10d

; 365  :             while (state->have < state->ncode) {

  00370	41 8b c2	 mov	 eax, r10d
  00373	45 85 c0	 test	 r8d, r8d
  00376	0f 84 a4 00 00
	00		 je	 $LL90@inflateBac
  0037c	0f 1f 40 00	 npad	 4
$LL74@inflateBac:

; 366  :                 NEEDBITS(3);

  00380	83 fe 03	 cmp	 esi, 3
  00383	73 49		 jae	 SHORT $LN76@inflateBac
  00385	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00389	0f 1f 80 00 00
	00 00		 npad	 7
$LL79@inflateBac:
  00390	85 ff		 test	 edi, edi
  00392	75 18		 jne	 SHORT $LN84@inflateBac
  00394	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00398	49 8b cc	 mov	 rcx, r12
  0039b	41 ff d7	 call	 r15
  0039e	8b f8		 mov	 edi, eax
  003a0	85 c0		 test	 eax, eax
  003a2	0f 84 d9 0a 00
	00		 je	 $LN369@inflateBac
  003a8	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN84@inflateBac:
  003ac	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  003af	8b ce		 mov	 ecx, esi
  003b1	d3 e0		 shl	 eax, cl
  003b3	48 ff c2	 inc	 rdx
  003b6	44 03 f0	 add	 r14d, eax
  003b9	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  003bd	ff cf		 dec	 edi
  003bf	83 c6 08	 add	 esi, 8
  003c2	83 fe 03	 cmp	 esi, 3
  003c5	72 c9		 jb	 SHORT $LL79@inflateBac
  003c7	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
$LN76@inflateBac:

; 367  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  003ce	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  003d5	41 0f b7 ce	 movzx	 ecx, r14w
  003d9	66 83 e1 07	 and	 cx, 7

; 368  :                 DROPBITS(3);

  003dd	41 c1 ee 03	 shr	 r14d, 3
  003e1	83 c6 fd	 add	 esi, -3			; fffffffdH
  003e4	41 0f b7 84 43
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[r11+rax*2]
  003ed	66 41 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], cx
  003f6	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  003fd	ff c0		 inc	 eax
  003ff	41 89 85 84 00
	00 00		 mov	 DWORD PTR [r13+132], eax
  00406	41 3b 45 78	 cmp	 eax, DWORD PTR [r13+120]
  0040a	0f 82 70 ff ff
	ff		 jb	 $LL74@inflateBac

; 369  :             }
; 370  :             while (state->have < 19)

  00410	83 f8 13	 cmp	 eax, 19
  00413	73 30		 jae	 SHORT $LN91@inflateBac
  00415	45 33 d2	 xor	 r10d, r10d
  00418	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL90@inflateBac:

; 371  :                 state->lens[order[state->have++]] = 0;

  00420	41 0f b7 84 43
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[r11+rax*2]
  00429	66 45 89 94 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r10w
  00432	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00439	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00440	83 f8 13	 cmp	 eax, 19
  00443	72 db		 jb	 SHORT $LL90@inflateBac
$LN91@inflateBac:

; 372  :             state->next = state->codes;

  00445	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]

; 373  :             state->lencode = (code const FAR *)(state->next);
; 374  :             state->lenbits = 7;

  0044c	41 c7 45 70 07
	00 00 00	 mov	 DWORD PTR [r13+112], 7
  00454	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  0045b	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  0045f	49 89 01	 mov	 QWORD PTR [r9], rax
  00462	49 8d 5d 70	 lea	 rbx, QWORD PTR [r13+112]

; 375  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00466	49 8d 85 10 03
	00 00		 lea	 rax, QWORD PTR [r13+784]
  0046d	33 c9		 xor	 ecx, ecx
  0046f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00474	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  0047b	41 b8 13 00 00
	00		 mov	 r8d, 19
  00481	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00486	e8 00 00 00 00	 call	 inflate_table

; 376  :                                 &(state->lenbits), state->work);
; 377  :             if (ret) {

  0048b	85 c0		 test	 eax, eax
  0048d	74 27		 je	 SHORT $LN280@inflateBac

; 378  :                 strm->msg = (z_const char *)"invalid code lengths set";

  0048f	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  00493	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
  0049a	49 89 41 20	 mov	 QWORD PTR [r9+32], rax

; 379  :                 state->mode = BAD;

  0049e	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
$LN521@inflateBac:

; 271  :     hold = 0;
; 272  :     bits = 0;
; 273  :     put = state->window;
; 274  :     left = state->wsize;
; 275  : 
; 276  :     /* Inflate until end of block marked as last */
; 277  :     for (;;)
; 278  :         switch (state->mode) {

  004a6	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  004aa	45 33 d2	 xor	 r10d, r10d
  004ad	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  004b1	e9 b0 09 00 00	 jmp	 $LN2@inflateBac
$LN280@inflateBac:

; 380  :                 break;
; 381  :             }
; 382  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 383  : 
; 384  :             /* get length and distance code code lengths */
; 385  :             state->have = 0;
; 386  :             while (state->have < state->nlen + state->ndist) {

  004b6	41 8b 85 80 00
	00 00		 mov	 eax, DWORD PTR [r13+128]
  004bd	41 c7 85 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [r13+132], 0
  004c8	41 03 45 7c	 add	 eax, DWORD PTR [r13+124]
  004cc	0f 84 79 02 00
	00		 je	 $LN525@inflateBac
  004d2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL92@inflateBac:

; 387  :                 for (;;) {
; 388  :                     here = state->lencode[BITS(state->lenbits)];

  004e0	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  004e2	b8 01 00 00 00	 mov	 eax, 1

; 389  :                     if ((unsigned)(here.bits) <= bits) break;

  004e7	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
  004eb	d3 e0		 shl	 eax, cl
  004ed	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  004f0	41 8b c6	 mov	 eax, r14d
  004f3	48 23 c8	 and	 rcx, rax
  004f6	49 8b 45 60	 mov	 rax, QWORD PTR [r13+96]
  004fa	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  004fd	8b c8		 mov	 ecx, eax
  004ff	c1 e9 08	 shr	 ecx, 8
  00502	0f b6 d1	 movzx	 edx, cl
  00505	8b c8		 mov	 ecx, eax
  00507	c1 e9 10	 shr	 ecx, 16
  0050a	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  0050d	3b d6		 cmp	 edx, esi
  0050f	76 60		 jbe	 SHORT $LN375@inflateBac
$LL96@inflateBac:

; 390  :                     PULLBYTE();

  00511	85 ff		 test	 edi, edi
  00513	75 18		 jne	 SHORT $LN100@inflateBac
  00515	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00519	49 8b cc	 mov	 rcx, r12
  0051c	41 ff d7	 call	 r15
  0051f	8b f8		 mov	 edi, eax
  00521	85 c0		 test	 eax, eax
  00523	0f 84 58 09 00
	00		 je	 $LN369@inflateBac
  00529	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN100@inflateBac:
  0052d	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00531	8b ce		 mov	 ecx, esi
  00533	d3 e0		 shl	 eax, cl
  00535	49 ff c0	 inc	 r8
  00538	44 03 f0	 add	 r14d, eax
  0053b	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  0053f	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00541	b8 01 00 00 00	 mov	 eax, 1
  00546	d3 e0		 shl	 eax, cl
  00548	ff cf		 dec	 edi
  0054a	41 8b d6	 mov	 edx, r14d
  0054d	83 c6 08	 add	 esi, 8
  00550	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00553	49 8b 45 60	 mov	 rax, QWORD PTR [r13+96]
  00557	48 23 ca	 and	 rcx, rdx
  0055a	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0055d	8b c8		 mov	 ecx, eax
  0055f	c1 e9 08	 shr	 ecx, 8
  00562	0f b6 d1	 movzx	 edx, cl
  00565	8b c8		 mov	 ecx, eax
  00567	c1 e9 10	 shr	 ecx, 16
  0056a	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  0056d	3b d6		 cmp	 edx, esi
  0056f	77 a0		 ja	 SHORT $LL96@inflateBac
$LN375@inflateBac:

; 391  :                 }
; 392  :                 if (here.val < 16) {

  00571	66 83 f9 10	 cmp	 cx, 16
  00575	73 2e		 jae	 SHORT $LN284@inflateBac

; 393  :                     DROPBITS(here.bits);

  00577	0f b6 ca	 movzx	 ecx, dl
  0057a	41 d3 ee	 shr	 r14d, cl
  0057d	2b f1		 sub	 esi, ecx

; 394  :                     state->lens[state->have++] = here.val;

  0057f	41 8b 8d 84 00
	00 00		 mov	 ecx, DWORD PTR [r13+132]
  00586	c1 e8 10	 shr	 eax, 16
  00589	66 41 89 84 4d
	90 00 00 00	 mov	 WORD PTR [r13+rcx*2+144], ax
  00592	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00599	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]

; 395  :                 }

  005a0	e9 92 01 00 00	 jmp	 $LN406@inflateBac
$LN284@inflateBac:

; 396  :                 else {
; 397  :                     if (here.val == 16) {

  005a5	0f b6 da	 movzx	 ebx, dl
  005a8	75 76		 jne	 SHORT $LN286@inflateBac

; 398  :                         NEEDBITS(here.bits + 2);

  005aa	83 c3 02	 add	 ebx, 2
  005ad	3b f3		 cmp	 esi, ebx
  005af	73 37		 jae	 SHORT $LN106@inflateBac
$LL109@inflateBac:
  005b1	85 ff		 test	 edi, edi
  005b3	75 18		 jne	 SHORT $LN114@inflateBac
  005b5	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  005b9	49 8b cc	 mov	 rcx, r12
  005bc	41 ff d7	 call	 r15
  005bf	8b f8		 mov	 edi, eax
  005c1	85 c0		 test	 eax, eax
  005c3	0f 84 b8 08 00
	00		 je	 $LN369@inflateBac
  005c9	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN114@inflateBac:
  005cd	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  005d1	8b ce		 mov	 ecx, esi
  005d3	d3 e0		 shl	 eax, cl
  005d5	49 ff c0	 inc	 r8
  005d8	44 03 f0	 add	 r14d, eax
  005db	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  005df	ff cf		 dec	 edi
  005e1	83 c6 08	 add	 esi, 8
  005e4	3b f3		 cmp	 esi, ebx
  005e6	72 c9		 jb	 SHORT $LL109@inflateBac
$LN106@inflateBac:

; 399  :                         DROPBITS(here.bits);

  005e8	0f b6 4d bd	 movzx	 ecx, BYTE PTR here$[rbp-119]

; 400  :                         if (state->have == 0) {

  005ec	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  005f3	2b f1		 sub	 esi, ecx
  005f5	41 d3 ee	 shr	 r14d, cl
  005f8	85 c0		 test	 eax, eax
  005fa	0f 84 8b 01 00
	00		 je	 $LN380@inflateBac

; 401  :                             strm->msg = (z_const char *)"invalid bit length repeat";
; 402  :                             state->mode = BAD;
; 403  :                             break;
; 404  :                         }
; 405  :                         len = (unsigned)(state->lens[state->have - 1]);
; 406  :                         copy = 3 + BITS(2);

  00600	41 8b d6	 mov	 edx, r14d

; 407  :                         DROPBITS(2);

  00603	83 c6 fe	 add	 esi, -2			; fffffffeH
  00606	83 e2 03	 and	 edx, 3
  00609	41 c1 ee 02	 shr	 r14d, 2
  0060d	83 c2 03	 add	 edx, 3
  00610	ff c8		 dec	 eax
  00612	45 0f b7 8c 45
	90 00 00 00	 movzx	 r9d, WORD PTR [r13+rax*2+144]

; 408  :                     }

  0061b	e9 cc 00 00 00	 jmp	 $LN155@inflateBac
$LN286@inflateBac:

; 409  :                     else if (here.val == 17) {

  00620	66 83 f9 11	 cmp	 cx, 17
  00624	75 65		 jne	 SHORT $LN142@inflateBac

; 410  :                         NEEDBITS(here.bits + 3);

  00626	83 c3 03	 add	 ebx, 3
  00629	3b f3		 cmp	 esi, ebx
  0062b	73 3a		 jae	 SHORT $LN123@inflateBac
  0062d	0f 1f 00	 npad	 3
$LL126@inflateBac:
  00630	85 ff		 test	 edi, edi
  00632	75 18		 jne	 SHORT $LN131@inflateBac
  00634	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00638	49 8b cc	 mov	 rcx, r12
  0063b	41 ff d7	 call	 r15
  0063e	8b f8		 mov	 edi, eax
  00640	85 c0		 test	 eax, eax
  00642	0f 84 39 08 00
	00		 je	 $LN369@inflateBac
  00648	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN131@inflateBac:
  0064c	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00650	8b ce		 mov	 ecx, esi
  00652	d3 e0		 shl	 eax, cl
  00654	49 ff c0	 inc	 r8
  00657	44 03 f0	 add	 r14d, eax
  0065a	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  0065e	ff cf		 dec	 edi
  00660	83 c6 08	 add	 esi, 8
  00663	3b f3		 cmp	 esi, ebx
  00665	72 c9		 jb	 SHORT $LL126@inflateBac
$LN123@inflateBac:

; 411  :                         DROPBITS(here.bits);

  00667	0f b6 4d bd	 movzx	 ecx, BYTE PTR here$[rbp-119]

; 412  :                         len = 0;
; 413  :                         copy = 3 + BITS(3);
; 414  :                         DROPBITS(3);

  0066b	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00670	41 d3 ee	 shr	 r14d, cl
  00673	2b c1		 sub	 eax, ecx
  00675	41 8b d6	 mov	 edx, r14d
  00678	03 f0		 add	 esi, eax
  0067a	83 e2 07	 and	 edx, 7
  0067d	41 c1 ee 03	 shr	 r14d, 3
  00681	83 c2 03	 add	 edx, 3
  00684	33 c0		 xor	 eax, eax
  00686	44 8b c8	 mov	 r9d, eax

; 415  :                     }

  00689	eb 61		 jmp	 SHORT $LN155@inflateBac
$LN142@inflateBac:

; 416  :                     else {
; 417  :                         NEEDBITS(here.bits + 7);

  0068b	83 c3 07	 add	 ebx, 7
  0068e	3b f3		 cmp	 esi, ebx
  00690	73 37		 jae	 SHORT $LN140@inflateBac
$LL143@inflateBac:
  00692	85 ff		 test	 edi, edi
  00694	75 18		 jne	 SHORT $LN148@inflateBac
  00696	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0069a	49 8b cc	 mov	 rcx, r12
  0069d	41 ff d7	 call	 r15
  006a0	8b f8		 mov	 edi, eax
  006a2	85 c0		 test	 eax, eax
  006a4	0f 84 d7 07 00
	00		 je	 $LN369@inflateBac
  006aa	4c 8b 45 c0	 mov	 r8, QWORD PTR next$[rbp-120]
$LN148@inflateBac:
  006ae	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  006b2	8b ce		 mov	 ecx, esi
  006b4	d3 e0		 shl	 eax, cl
  006b6	49 ff c0	 inc	 r8
  006b9	44 03 f0	 add	 r14d, eax
  006bc	4c 89 45 c0	 mov	 QWORD PTR next$[rbp-120], r8
  006c0	ff cf		 dec	 edi
  006c2	83 c6 08	 add	 esi, 8
  006c5	3b f3		 cmp	 esi, ebx
  006c7	72 c9		 jb	 SHORT $LL143@inflateBac
$LN140@inflateBac:

; 418  :                         DROPBITS(here.bits);

  006c9	0f b6 4d bd	 movzx	 ecx, BYTE PTR here$[rbp-119]

; 419  :                         len = 0;
; 420  :                         copy = 11 + BITS(7);
; 421  :                         DROPBITS(7);

  006cd	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  006d2	41 d3 ee	 shr	 r14d, cl
  006d5	2b c1		 sub	 eax, ecx
  006d7	41 8b d6	 mov	 edx, r14d
  006da	03 f0		 add	 esi, eax
  006dc	83 e2 7f	 and	 edx, 127		; 0000007fH
  006df	41 c1 ee 07	 shr	 r14d, 7
  006e3	83 c2 0b	 add	 edx, 11
  006e6	33 c0		 xor	 eax, eax
  006e8	44 0f b7 c8	 movzx	 r9d, ax
$LN155@inflateBac:

; 422  :                     }
; 423  :                     if (state->have + copy > state->nlen + state->ndist) {

  006ec	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]
  006f3	41 8b 8d 80 00
	00 00		 mov	 ecx, DWORD PTR [r13+128]
  006fa	41 03 4d 7c	 add	 ecx, DWORD PTR [r13+124]
  006fe	41 8d 04 10	 lea	 eax, DWORD PTR [r8+rdx]
  00702	3b c1		 cmp	 eax, ecx
  00704	0f 87 81 00 00
	00		 ja	 $LN380@inflateBac
  0070a	66 0f 1f 44 00
	00		 npad	 6
$LL157@inflateBac:

; 424  :                         strm->msg = (z_const char *)"invalid bit length repeat";
; 425  :                         state->mode = BAD;
; 426  :                         break;
; 427  :                     }
; 428  :                     while (copy--)
; 429  :                         state->lens[state->have++] = (unsigned short)len;

  00710	41 8b c0	 mov	 eax, r8d
  00713	66 45 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r9w
  0071c	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]
  00723	45 8d 40 01	 lea	 r8d, DWORD PTR [r8+1]
  00727	45 89 85 84 00
	00 00		 mov	 DWORD PTR [r13+132], r8d
  0072e	83 c2 ff	 add	 edx, -1			; ffffffffH
  00731	75 dd		 jne	 SHORT $LL157@inflateBac

; 416  :                     else {
; 417  :                         NEEDBITS(here.bits + 7);

  00733	49 8d 5d 70	 lea	 rbx, QWORD PTR [r13+112]
$LN406@inflateBac:

; 380  :                 break;
; 381  :             }
; 382  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 383  : 
; 384  :             /* get length and distance code code lengths */
; 385  :             state->have = 0;
; 386  :             while (state->have < state->nlen + state->ndist) {

  00737	41 8b 85 80 00
	00 00		 mov	 eax, DWORD PTR [r13+128]
  0073e	41 03 45 7c	 add	 eax, DWORD PTR [r13+124]
  00742	44 3b c0	 cmp	 r8d, eax
  00745	0f 82 95 fd ff
	ff		 jb	 $LL92@inflateBac
$LN525@inflateBac:

; 430  :                 }
; 431  :             }
; 432  : 
; 433  :             /* handle error breaks in while */
; 434  :             if (state->mode == BAD) break;

  0074b	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
$LN93@inflateBac:
  0074f	41 81 7d 08 51
	3f 00 00	 cmp	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00757	0f 84 49 fd ff
	ff		 je	 $LN521@inflateBac

; 435  : 
; 436  :             /* check for end-of-block code (better have one) */
; 437  :             if (state->lens[256] == 0) {

  0075d	66 41 83 bd 90
	02 00 00 00	 cmp	 WORD PTR [r13+656], 0
  00766	75 3c		 jne	 SHORT $LN299@inflateBac

; 438  :                 strm->msg = (z_const char *)"invalid code -- missing end-of-block";
; 439  :                 state->mode = BAD;
; 440  :                 break;

  00768	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  0076c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
  00773	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  00777	45 33 d2	 xor	 r10d, r10d
  0077a	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  0077e	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00786	e9 db 06 00 00	 jmp	 $LN2@inflateBac
$LN380@inflateBac:

; 430  :                 }
; 431  :             }
; 432  : 
; 433  :             /* handle error breaks in while */
; 434  :             if (state->mode == BAD) break;

  0078b	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  0078f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00796	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  0079a	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  007a2	eb ab		 jmp	 SHORT $LN93@inflateBac
$LN299@inflateBac:

; 441  :             }
; 442  : 
; 443  :             /* build code tables -- note: do not change the lenbits or distbits
; 444  :                values here (9 and 6) without reading the comments in inftrees.h
; 445  :                concerning the ENOUGH constants, which depend on those values */
; 446  :             state->next = state->codes;
; 447  :             state->lencode = (code const FAR *)(state->next);
; 448  :             state->lenbits = 9;
; 449  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  007a4	45 8b 45 7c	 mov	 r8d, DWORD PTR [r13+124]
  007a8	49 8d 4d 70	 lea	 rcx, QWORD PTR [r13+112]
  007ac	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]
  007b3	41 c7 45 70 09
	00 00 00	 mov	 DWORD PTR [r13+112], 9
  007bb	49 89 85 88 00
	00 00		 mov	 QWORD PTR [r13+136], rax
  007c2	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  007c9	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]
  007d0	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  007d4	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  007db	49 8d 85 10 03
	00 00		 lea	 rax, QWORD PTR [r13+784]
  007e2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007e7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  007ec	b9 01 00 00 00	 mov	 ecx, 1
  007f1	e8 00 00 00 00	 call	 inflate_table

; 450  :                                 &(state->lenbits), state->work);
; 451  :             if (ret) {

  007f6	85 c0		 test	 eax, eax
  007f8	74 27		 je	 SHORT $LN300@inflateBac

; 452  :                 strm->msg = (z_const char *)"invalid literal/lengths set";

  007fa	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  007fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@

; 453  :                 state->mode = BAD;
; 454  :                 break;

  00805	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00809	45 33 d2	 xor	 r10d, r10d
  0080c	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  00810	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  00814	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  0081c	e9 45 06 00 00	 jmp	 $LN2@inflateBac
$LN300@inflateBac:

; 455  :             }
; 456  :             state->distcode = (code const FAR *)(state->next);

  00821	49 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR [r13+136]

; 457  :             state->distbits = 6;

  00828	4d 8d 45 74	 lea	 r8, QWORD PTR [r13+116]

; 458  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  0082c	49 8d 8d 10 03
	00 00		 lea	 rcx, QWORD PTR [r13+784]
  00833	49 89 45 68	 mov	 QWORD PTR [r13+104], rax
  00837	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  0083b	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00842	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00847	b9 02 00 00 00	 mov	 ecx, 2
  0084c	41 c7 00 06 00
	00 00		 mov	 DWORD PTR [r8], 6
  00853	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00858	45 8b 85 80 00
	00 00		 mov	 r8d, DWORD PTR [r13+128]
  0085f	48 8d 14 45 90
	00 00 00	 lea	 rdx, QWORD PTR [rax*2+144]
  00867	49 03 d5	 add	 rdx, r13
  0086a	e8 00 00 00 00	 call	 inflate_table

; 459  :                             &(state->next), &(state->distbits), state->work);
; 460  :             if (ret) {

  0086f	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  00873	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00877	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  0087b	85 c0		 test	 eax, eax
  0087d	74 1b		 je	 SHORT $LN301@inflateBac

; 461  :                 strm->msg = (z_const char *)"invalid distances set";

  0087f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set@

; 462  :                 state->mode = BAD;
; 463  :                 break;

  00886	45 33 d2	 xor	 r10d, r10d
  00889	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  0088d	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00895	e9 cc 05 00 00	 jmp	 $LN2@inflateBac
$LN301@inflateBac:

; 464  :             }
; 465  :             Tracev((stderr, "inflate:       codes ok\n"));
; 466  :             state->mode = LEN;

  0089a	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H
$LN302@inflateBac:

; 467  :                 /* fallthrough */
; 468  : 
; 469  :         case LEN:
; 470  :             /* use inflate_fast() if we have enough input and output */
; 471  :             if (have >= 6 && left >= 258) {

  008a2	83 ff 06	 cmp	 edi, 6
  008a5	0f 82 8e 00 00
	00		 jb	 $LN303@inflateBac
  008ab	41 81 f8 02 01
	00 00		 cmp	 r8d, 258		; 00000102H
  008b2	0f 82 81 00 00
	00		 jb	 $LN303@inflateBac

; 472  :                 RESTORE();

  008b8	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  008bc	49 89 01	 mov	 QWORD PTR [r9], rax
  008bf	49 89 59 10	 mov	 QWORD PTR [r9+16], rbx
  008c3	45 89 41 18	 mov	 DWORD PTR [r9+24], r8d
  008c7	41 89 79 08	 mov	 DWORD PTR [r9+8], edi

; 473  :                 if (state->whave < state->wsize)

  008cb	41 8b 55 34	 mov	 edx, DWORD PTR [r13+52]
  008cf	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  008d3	41 89 75 4c	 mov	 DWORD PTR [r13+76], esi
  008d7	41 39 55 38	 cmp	 DWORD PTR [r13+56], edx
  008db	73 09		 jae	 SHORT $LN304@inflateBac

; 474  :                     state->whave = state->wsize - left;

  008dd	8b c2		 mov	 eax, edx
  008df	41 2b c0	 sub	 eax, r8d
  008e2	41 89 45 38	 mov	 DWORD PTR [r13+56], eax
$LN304@inflateBac:

; 475  :                 inflate_fast(strm, state->wsize);

  008e6	49 8b c9	 mov	 rcx, r9
  008e9	e8 00 00 00 00	 call	 inflate_fast

; 476  :                 LOAD();

  008ee	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]

; 477  :                 break;

  008f2	45 33 d2	 xor	 r10d, r10d
  008f5	49 8b 01	 mov	 rax, QWORD PTR [r9]
  008f8	49 8b 59 10	 mov	 rbx, QWORD PTR [r9+16]
  008fc	45 8b 41 18	 mov	 r8d, DWORD PTR [r9+24]
  00900	41 8b 79 08	 mov	 edi, DWORD PTR [r9+8]
  00904	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
  00908	45 8b 75 48	 mov	 r14d, DWORD PTR [r13+72]
  0090c	41 8b 75 4c	 mov	 esi, DWORD PTR [r13+76]
  00910	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00914	44 89 45 b8	 mov	 DWORD PTR left$1$[rbp-120], r8d
  00918	e9 49 05 00 00	 jmp	 $LN2@inflateBac
$LN277@inflateBac:

; 356  :                 strm->msg = (z_const char *)"too many length or distance symbols";
; 357  :                 state->mode = BAD;
; 358  :                 break;

  0091d	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  00921	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  00928	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  0092c	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00934	e9 2d 05 00 00	 jmp	 $LN2@inflateBac
$LN303@inflateBac:

; 478  :             }
; 479  : 
; 480  :             /* get a literal, length, or end-of-block code */
; 481  :             for (;;) {
; 482  :                 here = state->lencode[BITS(state->lenbits)];

  00939	41 8b 4d 70	 mov	 ecx, DWORD PTR [r13+112]
  0093d	bb 01 00 00 00	 mov	 ebx, 1
  00942	4d 8b 4d 60	 mov	 r9, QWORD PTR [r13+96]
  00946	8b c3		 mov	 eax, ebx
  00948	d3 e0		 shl	 eax, cl
  0094a	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  0094d	41 8b c6	 mov	 eax, r14d
  00950	48 23 c8	 and	 rcx, rax
  00953	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  00957	8b c8		 mov	 ecx, eax
  00959	c1 e9 08	 shr	 ecx, 8
  0095c	0f b6 c9	 movzx	 ecx, cl

; 483  :                 if ((unsigned)(here.bits) <= bits) break;

  0095f	3b ce		 cmp	 ecx, esi
  00961	76 53		 jbe	 SHORT $LN505@inflateBac
$LL167@inflateBac:

; 484  :                 PULLBYTE();

  00963	85 ff		 test	 edi, edi
  00965	75 14		 jne	 SHORT $LN171@inflateBac
  00967	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0096b	49 8b cc	 mov	 rcx, r12
  0096e	41 ff d7	 call	 r15
  00971	8b f8		 mov	 edi, eax
  00973	85 c0		 test	 eax, eax
  00975	0f 84 06 05 00
	00		 je	 $LN369@inflateBac
$LN171@inflateBac:
  0097b	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  0097f	8b ce		 mov	 ecx, esi
  00981	ff cf		 dec	 edi
  00983	83 c6 08	 add	 esi, 8
  00986	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00989	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  0098d	4d 8b 4d 60	 mov	 r9, QWORD PTR [r13+96]
  00991	d3 e0		 shl	 eax, cl
  00993	41 8b 4d 70	 mov	 ecx, DWORD PTR [r13+112]
  00997	44 03 f0	 add	 r14d, eax
  0099a	8b c3		 mov	 eax, ebx
  0099c	41 8b d6	 mov	 edx, r14d
  0099f	d3 e0		 shl	 eax, cl
  009a1	ff c8		 dec	 eax
  009a3	48 23 c2	 and	 rax, rdx
  009a6	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  009aa	8b c8		 mov	 ecx, eax
  009ac	c1 e9 08	 shr	 ecx, 8
  009af	0f b6 c9	 movzx	 ecx, cl
  009b2	3b ce		 cmp	 ecx, esi
  009b4	77 ad		 ja	 SHORT $LL167@inflateBac
$LN505@inflateBac:

; 485  :             }
; 486  :             if (here.op && (here.op & 0xf0) == 0) {

  009b6	84 c0		 test	 al, al
  009b8	0f 84 c8 00 00
	00		 je	 $LN184@inflateBac
  009be	a8 f0		 test	 al, 240			; 000000f0H
  009c0	0f 85 c0 00 00
	00		 jne	 $LN184@inflateBac

; 487  :                 last = here;
; 488  :                 for (;;) {
; 489  :                     here = state->lencode[last.val +

  009c6	8b c8		 mov	 ecx, eax
  009c8	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 490  :                             (BITS(last.bits + last.op) >> last.bits)];
; 491  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  009cb	44 0f b6 7d bd	 movzx	 r15d, BYTE PTR last$[rbp-119]
  009d0	ba 01 00 00 00	 mov	 edx, 1
  009d5	c1 e9 08	 shr	 ecx, 8
  009d8	8b d8		 mov	 ebx, eax
  009da	44 0f b6 c1	 movzx	 r8d, cl
  009de	0f b6 c8	 movzx	 ecx, al
  009e1	41 03 c8	 add	 ecx, r8d
  009e4	c1 e8 10	 shr	 eax, 16
  009e7	d3 e2		 shl	 edx, cl
  009e9	41 8b c8	 mov	 ecx, r8d
  009ec	ff ca		 dec	 edx
  009ee	41 23 d6	 and	 edx, r14d
  009f1	d3 ea		 shr	 edx, cl
  009f3	03 d0		 add	 edx, eax
  009f5	41 8b 04 91	 mov	 eax, DWORD PTR [r9+rdx*4]
  009f9	8b c8		 mov	 ecx, eax
  009fb	c1 e9 08	 shr	 ecx, 8
  009fe	0f b6 d1	 movzx	 edx, cl
  00a01	41 03 d0	 add	 edx, r8d
  00a04	3b d6		 cmp	 edx, esi
  00a06	76 6c		 jbe	 SHORT $LN185@inflateBac
  00a08	44 0f b7 65 be	 movzx	 r12d, WORD PTR last$[rbp-118]
  00a0d	0f 1f 00	 npad	 3
$LL176@inflateBac:

; 492  :                     PULLBYTE();

  00a10	85 ff		 test	 edi, edi
  00a12	75 15		 jne	 SHORT $LN180@inflateBac
  00a14	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00a18	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00a1c	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00a1f	8b f8		 mov	 edi, eax
  00a21	85 c0		 test	 eax, eax
  00a23	0f 84 58 04 00
	00		 je	 $LN369@inflateBac
$LN180@inflateBac:
  00a29	48 8b 45 c0	 mov	 rax, QWORD PTR next$[rbp-120]
  00a2d	8b ce		 mov	 ecx, esi
  00a2f	ba 01 00 00 00	 mov	 edx, 1
  00a34	ff cf		 dec	 edi
  00a36	83 c6 08	 add	 esi, 8
  00a39	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a3c	48 ff 45 c0	 inc	 QWORD PTR next$[rbp-120]
  00a40	d3 e0		 shl	 eax, cl
  00a42	44 03 f0	 add	 r14d, eax
  00a45	0f b6 cb	 movzx	 ecx, bl
  00a48	49 8b 45 60	 mov	 rax, QWORD PTR [r13+96]
  00a4c	41 03 cf	 add	 ecx, r15d
  00a4f	d3 e2		 shl	 edx, cl
  00a51	41 8b cf	 mov	 ecx, r15d
  00a54	ff ca		 dec	 edx
  00a56	41 23 d6	 and	 edx, r14d
  00a59	d3 ea		 shr	 edx, cl
  00a5b	41 03 d4	 add	 edx, r12d
  00a5e	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00a61	8b c8		 mov	 ecx, eax
  00a63	c1 e9 08	 shr	 ecx, 8
  00a66	0f b6 d1	 movzx	 edx, cl
  00a69	41 03 d7	 add	 edx, r15d
  00a6c	3b d6		 cmp	 edx, esi
  00a6e	77 a0		 ja	 SHORT $LL176@inflateBac
  00a70	4c 8b 65 38	 mov	 r12, QWORD PTR in_desc$[rbp-120]
$LN185@inflateBac:

; 493  :                 }
; 494  :                 DROPBITS(last.bits);

  00a74	41 8b cf	 mov	 ecx, r15d
  00a77	bb 01 00 00 00	 mov	 ebx, 1
  00a7c	41 d3 ee	 shr	 r14d, cl
  00a7f	41 2b f7	 sub	 esi, r15d
  00a82	4c 8b 7d 30	 mov	 r15, QWORD PTR in$[rbp-120]
$LN184@inflateBac:

; 495  :             }
; 496  :             DROPBITS(here.bits);

  00a86	8b c8		 mov	 ecx, eax
  00a88	c1 e9 08	 shr	 ecx, 8
  00a8b	0f b6 c9	 movzx	 ecx, cl
  00a8e	41 d3 ee	 shr	 r14d, cl
  00a91	2b f1		 sub	 esi, ecx

; 497  :             state->length = (unsigned)here.val;

  00a93	8b c8		 mov	 ecx, eax
  00a95	c1 e9 10	 shr	 ecx, 16
  00a98	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 498  : 
; 499  :             /* process literal */
; 500  :             if (here.op == 0) {

  00a9c	84 c0		 test	 al, al
  00a9e	75 5c		 jne	 SHORT $LN312@inflateBac

; 501  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 502  :                         "inflate:         literal '%c'\n" :
; 503  :                         "inflate:         literal 0x%02x\n", here.val));
; 504  :                 ROOM();

  00aa0	44 8b 7d b8	 mov	 r15d, DWORD PTR left$1$[rbp-120]
  00aa4	45 85 ff	 test	 r15d, r15d
  00aa7	75 2d		 jne	 SHORT $LN522@inflateBac
  00aa9	45 8b 7d 34	 mov	 r15d, DWORD PTR [r13+52]
  00aad	45 8b c7	 mov	 r8d, r15d
  00ab0	49 8b 5d 40	 mov	 rbx, QWORD PTR [r13+64]
  00ab4	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00ab8	48 8b d3	 mov	 rdx, rbx
  00abb	4c 8b 65 40	 mov	 r12, QWORD PTR out$[rbp-120]
  00abf	45 89 7d 38	 mov	 DWORD PTR [r13+56], r15d
  00ac3	41 ff d4	 call	 r12
  00ac6	85 c0		 test	 eax, eax
  00ac8	74 10		 je	 SHORT $LN189@inflateBac
$LN394@inflateBac:

; 606  :             goto inf_leave;
; 607  :         }
; 608  : 
; 609  :     /* Write leftover output and return unused input */
; 610  :   inf_leave:
; 611  :     if (left < state->wsize) {

  00aca	be fb ff ff ff	 mov	 esi, -5
  00acf	8b de		 mov	 ebx, esi
  00ad1	e9 da 03 00 00	 jmp	 $inf_leave$637
$LN522@inflateBac:

; 501  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 502  :                         "inflate:         literal '%c'\n" :
; 503  :                         "inflate:         literal 0x%02x\n", here.val));
; 504  :                 ROOM();

  00ad6	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN189@inflateBac:

; 505  :                 *put++ = (unsigned char)(state->length);

  00ada	41 0f b6 45 50	 movzx	 eax, BYTE PTR [r13+80]
  00adf	88 03		 mov	 BYTE PTR [rbx], al
  00ae1	48 ff c3	 inc	 rbx

; 506  :                 left--;

  00ae4	41 ff cf	 dec	 r15d
  00ae7	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00aeb	44 89 7d b8	 mov	 DWORD PTR left$1$[rbp-120], r15d

; 507  :                 state->mode = LEN;

  00aef	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 508  :                 break;

  00af7	e9 60 03 00 00	 jmp	 $LN523@inflateBac
$LN312@inflateBac:

; 509  :             }
; 510  : 
; 511  :             /* process end of block */
; 512  :             if (here.op & 32) {

  00afc	a8 20		 test	 al, 32			; 00000020H
  00afe	74 15		 je	 SHORT $LN315@inflateBac

; 513  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 514  :                 state->mode = TYPE;
; 515  :                 break;

  00b00	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00b04	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  00b08	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
  00b10	e9 4a 03 00 00	 jmp	 $LN631@inflateBac
$LN315@inflateBac:

; 516  :             }
; 517  : 
; 518  :             /* invalid code */
; 519  :             if (here.op & 64) {

  00b15	a8 40		 test	 al, 64			; 00000040H
  00b17	74 27		 je	 SHORT $LN316@inflateBac

; 520  :                 strm->msg = (z_const char *)"invalid literal/length code";

  00b19	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  00b1d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@

; 521  :                 state->mode = BAD;
; 522  :                 break;

  00b24	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00b28	45 33 d2	 xor	 r10d, r10d
  00b2b	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  00b2f	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  00b33	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00b3b	e9 26 03 00 00	 jmp	 $LN2@inflateBac
$LN316@inflateBac:

; 523  :             }
; 524  : 
; 525  :             /* length code -- get extra bits, if any */
; 526  :             state->extra = (unsigned)(here.op) & 15;

  00b40	0f b6 c8	 movzx	 ecx, al
  00b43	83 e1 0f	 and	 ecx, 15
  00b46	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx

; 527  :             if (state->extra != 0) {

  00b4a	74 54		 je	 SHORT $LN204@inflateBac

; 528  :                 NEEDBITS(state->extra);

  00b4c	3b f1		 cmp	 esi, ecx
  00b4e	73 3e		 jae	 SHORT $LN192@inflateBac
  00b50	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL195@inflateBac:
  00b54	85 ff		 test	 edi, edi
  00b56	75 18		 jne	 SHORT $LN200@inflateBac
  00b58	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00b5c	49 8b cc	 mov	 rcx, r12
  00b5f	41 ff d7	 call	 r15
  00b62	8b f8		 mov	 edi, eax
  00b64	85 c0		 test	 eax, eax
  00b66	0f 84 15 03 00
	00		 je	 $LN369@inflateBac
  00b6c	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN200@inflateBac:
  00b70	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00b73	8b ce		 mov	 ecx, esi
  00b75	d3 e0		 shl	 eax, cl
  00b77	48 ff c2	 inc	 rdx
  00b7a	44 03 f0	 add	 r14d, eax
  00b7d	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00b81	41 8b 4d 58	 mov	 ecx, DWORD PTR [r13+88]
  00b85	ff cf		 dec	 edi
  00b87	83 c6 08	 add	 esi, 8
  00b8a	3b f1		 cmp	 esi, ecx
  00b8c	72 c6		 jb	 SHORT $LL195@inflateBac
$LN192@inflateBac:

; 529  :                 state->length += BITS(state->extra);

  00b8e	8b c3		 mov	 eax, ebx
  00b90	d3 e0		 shl	 eax, cl
  00b92	ff c8		 dec	 eax
  00b94	41 23 c6	 and	 eax, r14d

; 530  :                 DROPBITS(state->extra);

  00b97	41 d3 ee	 shr	 r14d, cl
  00b9a	41 01 45 50	 add	 DWORD PTR [r13+80], eax
  00b9e	2b f1		 sub	 esi, ecx
$LN204@inflateBac:

; 531  :             }
; 532  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 533  : 
; 534  :             /* get distance code */
; 535  :             for (;;) {
; 536  :                 here = state->distcode[BITS(state->distbits)];

  00ba0	41 8b 4d 74	 mov	 ecx, DWORD PTR [r13+116]
  00ba4	8b c3		 mov	 eax, ebx
  00ba6	4d 8b 55 68	 mov	 r10, QWORD PTR [r13+104]

; 537  :                 if ((unsigned)(here.bits) <= bits) break;

  00baa	4c 8b 4d c0	 mov	 r9, QWORD PTR next$[rbp-120]
  00bae	d3 e0		 shl	 eax, cl
  00bb0	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00bb3	41 8b c6	 mov	 eax, r14d
  00bb6	48 23 c8	 and	 rcx, rax
  00bb9	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  00bbd	8b c8		 mov	 ecx, eax
  00bbf	c1 e9 08	 shr	 ecx, 8
  00bc2	0f b6 c9	 movzx	 ecx, cl
  00bc5	3b ce		 cmp	 ecx, esi
  00bc7	76 5e		 jbe	 SHORT $LN507@inflateBac
  00bc9	0f 1f 80 00 00
	00 00		 npad	 7
$LL208@inflateBac:

; 538  :                 PULLBYTE();

  00bd0	85 ff		 test	 edi, edi
  00bd2	75 18		 jne	 SHORT $LN212@inflateBac
  00bd4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00bd8	49 8b cc	 mov	 rcx, r12
  00bdb	41 ff d7	 call	 r15
  00bde	8b f8		 mov	 edi, eax
  00be0	85 c0		 test	 eax, eax
  00be2	0f 84 99 02 00
	00		 je	 $LN369@inflateBac
  00be8	4c 8b 4d c0	 mov	 r9, QWORD PTR next$[rbp-120]
$LN212@inflateBac:
  00bec	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00bf0	8b ce		 mov	 ecx, esi
  00bf2	d3 e0		 shl	 eax, cl
  00bf4	49 ff c1	 inc	 r9
  00bf7	44 03 f0	 add	 r14d, eax
  00bfa	4c 89 4d c0	 mov	 QWORD PTR next$[rbp-120], r9
  00bfe	41 8b 4d 74	 mov	 ecx, DWORD PTR [r13+116]
  00c02	8b c3		 mov	 eax, ebx
  00c04	4d 8b 55 68	 mov	 r10, QWORD PTR [r13+104]
  00c08	ff cf		 dec	 edi
  00c0a	d3 e0		 shl	 eax, cl
  00c0c	83 c6 08	 add	 esi, 8
  00c0f	ff c8		 dec	 eax
  00c11	41 8b d6	 mov	 edx, r14d
  00c14	48 23 c2	 and	 rax, rdx
  00c17	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]
  00c1b	8b c8		 mov	 ecx, eax
  00c1d	c1 e9 08	 shr	 ecx, 8
  00c20	0f b6 c9	 movzx	 ecx, cl
  00c23	3b ce		 cmp	 ecx, esi
  00c25	77 a9		 ja	 SHORT $LL208@inflateBac
$LN507@inflateBac:

; 539  :             }
; 540  :             if ((here.op & 0xf0) == 0) {

  00c27	a8 f0		 test	 al, 240			; 000000f0H
  00c29	0f 85 b9 00 00
	00		 jne	 $LN225@inflateBac

; 541  :                 last = here;
; 542  :                 for (;;) {
; 543  :                     here = state->distcode[last.val +

  00c2f	8b c8		 mov	 ecx, eax
  00c31	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 544  :                             (BITS(last.bits + last.op) >> last.bits)];
; 545  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00c34	44 0f b6 65 bd	 movzx	 r12d, BYTE PTR last$[rbp-119]
  00c39	ba 01 00 00 00	 mov	 edx, 1
  00c3e	c1 e9 08	 shr	 ecx, 8
  00c41	8b d8		 mov	 ebx, eax
  00c43	44 0f b6 c1	 movzx	 r8d, cl
  00c47	0f b6 c8	 movzx	 ecx, al
  00c4a	41 03 c8	 add	 ecx, r8d
  00c4d	c1 e8 10	 shr	 eax, 16
  00c50	d3 e2		 shl	 edx, cl
  00c52	41 8b c8	 mov	 ecx, r8d
  00c55	ff ca		 dec	 edx
  00c57	41 23 d6	 and	 edx, r14d
  00c5a	d3 ea		 shr	 edx, cl
  00c5c	03 d0		 add	 edx, eax
  00c5e	41 8b 04 92	 mov	 eax, DWORD PTR [r10+rdx*4]
  00c62	8b c8		 mov	 ecx, eax
  00c64	c1 e9 08	 shr	 ecx, 8
  00c67	0f b6 d1	 movzx	 edx, cl
  00c6a	41 03 d0	 add	 edx, r8d
  00c6d	3b d6		 cmp	 edx, esi
  00c6f	76 69		 jbe	 SHORT $LN226@inflateBac
  00c71	44 0f b7 7d be	 movzx	 r15d, WORD PTR last$[rbp-118]
$LL217@inflateBac:

; 546  :                     PULLBYTE();

  00c76	85 ff		 test	 edi, edi
  00c78	75 19		 jne	 SHORT $LN221@inflateBac
  00c7a	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00c7e	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00c82	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00c85	8b f8		 mov	 edi, eax
  00c87	85 c0		 test	 eax, eax
  00c89	0f 84 f2 01 00
	00		 je	 $LN369@inflateBac
  00c8f	4c 8b 4d c0	 mov	 r9, QWORD PTR next$[rbp-120]
$LN221@inflateBac:
  00c93	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00c97	8b ce		 mov	 ecx, esi
  00c99	d3 e0		 shl	 eax, cl
  00c9b	ba 01 00 00 00	 mov	 edx, 1
  00ca0	44 03 f0	 add	 r14d, eax
  00ca3	0f b6 cb	 movzx	 ecx, bl
  00ca6	41 03 cc	 add	 ecx, r12d
  00ca9	49 ff c1	 inc	 r9
  00cac	d3 e2		 shl	 edx, cl
  00cae	ff cf		 dec	 edi
  00cb0	ff ca		 dec	 edx
  00cb2	4c 89 4d c0	 mov	 QWORD PTR next$[rbp-120], r9
  00cb6	49 8b 45 68	 mov	 rax, QWORD PTR [r13+104]
  00cba	41 23 d6	 and	 edx, r14d
  00cbd	41 8b cc	 mov	 ecx, r12d
  00cc0	83 c6 08	 add	 esi, 8
  00cc3	d3 ea		 shr	 edx, cl
  00cc5	41 03 d7	 add	 edx, r15d
  00cc8	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00ccb	8b c8		 mov	 ecx, eax
  00ccd	c1 e9 08	 shr	 ecx, 8
  00cd0	0f b6 d1	 movzx	 edx, cl
  00cd3	41 03 d4	 add	 edx, r12d
  00cd6	3b d6		 cmp	 edx, esi
  00cd8	77 9c		 ja	 SHORT $LL217@inflateBac
$LN226@inflateBac:

; 547  :                 }
; 548  :                 DROPBITS(last.bits);

  00cda	41 8b cc	 mov	 ecx, r12d
  00cdd	bb 01 00 00 00	 mov	 ebx, 1
  00ce2	41 d3 ee	 shr	 r14d, cl
  00ce5	41 2b f4	 sub	 esi, r12d
$LN225@inflateBac:

; 549  :             }
; 550  :             DROPBITS(here.bits);

  00ce8	8b c8		 mov	 ecx, eax
  00cea	c1 e9 08	 shr	 ecx, 8
  00ced	0f b6 c9	 movzx	 ecx, cl
  00cf0	41 d3 ee	 shr	 r14d, cl
  00cf3	2b f1		 sub	 esi, ecx

; 551  :             if (here.op & 64) {

  00cf5	a8 40		 test	 al, 64			; 00000040H
  00cf7	74 27		 je	 SHORT $LN327@inflateBac

; 552  :                 strm->msg = (z_const char *)"invalid distance code";

  00cf9	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  00cfd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@

; 553  :                 state->mode = BAD;
; 554  :                 break;

  00d04	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00d08	45 33 d2	 xor	 r10d, r10d
  00d0b	44 8b 45 b8	 mov	 r8d, DWORD PTR left$1$[rbp-120]
  00d0f	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  00d13	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00d1b	e9 46 01 00 00	 jmp	 $LN2@inflateBac
$LN327@inflateBac:

; 555  :             }
; 556  :             state->offset = (unsigned)here.val;

  00d20	8b d0		 mov	 edx, eax

; 557  : 
; 558  :             /* get distance extra bits, if any */
; 559  :             state->extra = (unsigned)(here.op) & 15;

  00d22	0f b6 c8	 movzx	 ecx, al
  00d25	c1 ea 10	 shr	 edx, 16
  00d28	83 e1 0f	 and	 ecx, 15
  00d2b	41 89 55 54	 mov	 DWORD PTR [r13+84], edx
  00d2f	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx

; 560  :             if (state->extra != 0) {

  00d33	74 5c		 je	 SHORT $LN242@inflateBac

; 561  :                 NEEDBITS(state->extra);

  00d35	3b f1		 cmp	 esi, ecx
  00d37	73 42		 jae	 SHORT $LN230@inflateBac
  00d39	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00d3d	0f 1f 00	 npad	 3
$LL233@inflateBac:
  00d40	85 ff		 test	 edi, edi
  00d42	75 19		 jne	 SHORT $LN238@inflateBac
  00d44	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00d48	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00d4c	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00d4f	8b f8		 mov	 edi, eax
  00d51	85 c0		 test	 eax, eax
  00d53	0f 84 28 01 00
	00		 je	 $LN369@inflateBac
  00d59	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN238@inflateBac:
  00d5d	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00d60	8b ce		 mov	 ecx, esi
  00d62	d3 e0		 shl	 eax, cl
  00d64	48 ff c2	 inc	 rdx
  00d67	44 03 f0	 add	 r14d, eax
  00d6a	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00d6e	41 8b 4d 58	 mov	 ecx, DWORD PTR [r13+88]
  00d72	ff cf		 dec	 edi
  00d74	83 c6 08	 add	 esi, 8
  00d77	3b f1		 cmp	 esi, ecx
  00d79	72 c5		 jb	 SHORT $LL233@inflateBac
$LN230@inflateBac:

; 562  :                 state->offset += BITS(state->extra);

  00d7b	8b d3		 mov	 edx, ebx
  00d7d	d3 e2		 shl	 edx, cl
  00d7f	ff ca		 dec	 edx
  00d81	41 23 d6	 and	 edx, r14d

; 563  :                 DROPBITS(state->extra);

  00d84	41 d3 ee	 shr	 r14d, cl
  00d87	41 03 55 54	 add	 edx, DWORD PTR [r13+84]
  00d8b	41 89 55 54	 mov	 DWORD PTR [r13+84], edx
  00d8f	2b f1		 sub	 esi, ecx
$LN242@inflateBac:

; 564  :             }
; 565  :             if (state->offset > state->wsize - (state->whave < state->wsize ?

  00d91	41 8b 4d 34	 mov	 ecx, DWORD PTR [r13+52]
  00d95	45 33 d2	 xor	 r10d, r10d
  00d98	41 39 4d 38	 cmp	 DWORD PTR [r13+56], ecx
  00d9c	41 8b c2	 mov	 eax, r10d
  00d9f	44 8b 7d b8	 mov	 r15d, DWORD PTR left$1$[rbp-120]
  00da3	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00da7	41 0f 42 c7	 cmovb	 eax, r15d
  00dab	2b c8		 sub	 ecx, eax
  00dad	3b d1		 cmp	 edx, ecx
  00daf	76 1f		 jbe	 SHORT $LL246@inflateBac

; 566  :                                                 left : 0)) {
; 567  :                 strm->msg = (z_const char *)"invalid distance too far back";

  00db1	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
  00db5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@

; 568  :                 state->mode = BAD;
; 569  :                 break;

  00dbc	45 8b c7	 mov	 r8d, r15d
  00dbf	49 89 41 20	 mov	 QWORD PTR [r9+32], rax
  00dc3	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00dcb	e9 96 00 00 00	 jmp	 $LN2@inflateBac
$LL246@inflateBac:

; 570  :             }
; 571  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 572  : 
; 573  :             /* copy match from window to output */
; 574  :             do {
; 575  :                 ROOM();

  00dd0	45 85 ff	 test	 r15d, r15d
  00dd3	75 25		 jne	 SHORT $LN247@inflateBac
  00dd5	45 8b 7d 34	 mov	 r15d, DWORD PTR [r13+52]
  00dd9	45 8b c7	 mov	 r8d, r15d
  00ddc	49 8b 5d 40	 mov	 rbx, QWORD PTR [r13+64]
  00de0	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00de4	48 8b d3	 mov	 rdx, rbx
  00de7	4c 8b 65 40	 mov	 r12, QWORD PTR out$[rbp-120]
  00deb	45 89 7d 38	 mov	 DWORD PTR [r13+56], r15d
  00def	41 ff d4	 call	 r12
  00df2	85 c0		 test	 eax, eax
  00df4	0f 85 d0 fc ff
	ff		 jne	 $LN394@inflateBac
$LN247@inflateBac:

; 576  :                 copy = state->wsize - state->offset;

  00dfa	41 8b 4d 54	 mov	 ecx, DWORD PTR [r13+84]

; 577  :                 if (copy < left) {

  00dfe	45 8b c7	 mov	 r8d, r15d
  00e01	41 8b 45 34	 mov	 eax, DWORD PTR [r13+52]
  00e05	2b c1		 sub	 eax, ecx
  00e07	41 3b c7	 cmp	 eax, r15d
  00e0a	73 0a		 jae	 SHORT $LN334@inflateBac

; 578  :                     from = put + copy;

  00e0c	8b d0		 mov	 edx, eax
  00e0e	48 03 d3	 add	 rdx, rbx

; 579  :                     copy = left - copy;

  00e11	44 2b c0	 sub	 r8d, eax

; 580  :                 }

  00e14	eb 06		 jmp	 SHORT $LN335@inflateBac
$LN334@inflateBac:

; 581  :                 else {
; 582  :                     from = put - state->offset;

  00e16	48 8b d3	 mov	 rdx, rbx
  00e19	48 2b d1	 sub	 rdx, rcx
$LN335@inflateBac:

; 583  :                     copy = left;
; 584  :                 }
; 585  :                 if (copy > state->length) copy = state->length;

  00e1c	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]

; 586  :                 state->length -= copy;

  00e20	44 3b c0	 cmp	 r8d, eax
  00e23	8b c8		 mov	 ecx, eax
  00e25	41 0f 46 c8	 cmovbe	 ecx, r8d
  00e29	2b c1		 sub	 eax, ecx

; 587  :                 left -= copy;

  00e2b	44 2b f9	 sub	 r15d, ecx
  00e2e	41 89 45 50	 mov	 DWORD PTR [r13+80], eax
  00e32	48 2b d3	 sub	 rdx, rbx
  00e35	44 89 7d b8	 mov	 DWORD PTR left$1$[rbp-120], r15d
  00e39	0f 1f 80 00 00
	00 00		 npad	 7
$LL252@inflateBac:

; 588  :                 do {
; 589  :                     *put++ = *from++;

  00e40	0f b6 04 1a	 movzx	 eax, BYTE PTR [rdx+rbx]
  00e44	88 03		 mov	 BYTE PTR [rbx], al
  00e46	48 ff c3	 inc	 rbx

; 590  :                 } while (--copy);

  00e49	83 c1 ff	 add	 ecx, -1			; ffffffffH
  00e4c	75 f2		 jne	 SHORT $LL252@inflateBac

; 591  :             } while (state->length != 0);

  00e4e	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00e52	41 39 4d 50	 cmp	 DWORD PTR [r13+80], ecx
  00e56	0f 85 74 ff ff
	ff		 jne	 $LL246@inflateBac
$LN523@inflateBac:

; 271  :     hold = 0;
; 272  :     bits = 0;
; 273  :     put = state->window;
; 274  :     left = state->wsize;
; 275  : 
; 276  :     /* Inflate until end of block marked as last */
; 277  :     for (;;)
; 278  :         switch (state->mode) {

  00e5c	45 8b c7	 mov	 r8d, r15d
$LN631@inflateBac:
  00e5f	45 33 d2	 xor	 r10d, r10d
$LN630@inflateBac:
  00e62	4c 8b 4d 28	 mov	 r9, QWORD PTR strm$[rbp-120]
$LN2@inflateBac:
  00e66	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  00e6a	2d 3f 3f 00 00	 sub	 eax, 16191		; 00003f3fH
  00e6f	83 f8 12	 cmp	 eax, 18
  00e72	77 2a		 ja	 SHORT $LN339@inflateBac
  00e74	4c 8b 65 38	 mov	 r12, QWORD PTR in_desc$[rbp-120]
  00e78	4c 8b 7d 30	 mov	 r15, QWORD PTR in$[rbp-120]
  00e7c	e9 1e f2 ff ff	 jmp	 $LN632@inflateBac
$LN369@inflateBac:

; 606  :             goto inf_leave;
; 607  :         }
; 608  : 
; 609  :     /* Write leftover output and return unused input */
; 610  :   inf_leave:
; 611  :     if (left < state->wsize) {

  00e81	33 c0		 xor	 eax, eax
  00e83	48 89 45 c0	 mov	 QWORD PTR next$[rbp-120], rax
$LN372@inflateBac:
  00e87	be fb ff ff ff	 mov	 esi, -5
  00e8c	8b de		 mov	 ebx, esi
  00e8e	eb 18		 jmp	 SHORT $LN633@inflateBac
$LN337@inflateBac:

; 592  :             break;
; 593  : 
; 594  :         case DONE:
; 595  :             /* inflate stream terminated properly */
; 596  :             ret = Z_STREAM_END;
; 597  :             goto inf_leave;

  00e90	bb 01 00 00 00	 mov	 ebx, 1
  00e95	eb 0c		 jmp	 SHORT $LN634@inflateBac
$LN338@inflateBac:

; 598  : 
; 599  :         case BAD:
; 600  :             ret = Z_DATA_ERROR;

  00e97	bb fd ff ff ff	 mov	 ebx, -3

; 601  :             goto inf_leave;

  00e9c	eb 05		 jmp	 SHORT $LN634@inflateBac
$LN339@inflateBac:

; 602  : 
; 603  :         default:
; 604  :             /* can't happen, but makes compilers happy */
; 605  :             ret = Z_STREAM_ERROR;

  00e9e	bb fe ff ff ff	 mov	 ebx, -2
$LN634@inflateBac:

; 606  :             goto inf_leave;
; 607  :         }
; 608  : 
; 609  :     /* Write leftover output and return unused input */
; 610  :   inf_leave:
; 611  :     if (left < state->wsize) {

  00ea3	be fb ff ff ff	 mov	 esi, -5
$LN633@inflateBac:
  00ea8	44 8b 7d b8	 mov	 r15d, DWORD PTR left$1$[rbp-120]
  00eac	4c 8b 65 40	 mov	 r12, QWORD PTR out$[rbp-120]
$inf_leave$637:
  00eb0	45 8b 45 34	 mov	 r8d, DWORD PTR [r13+52]
  00eb4	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00eb9	45 3b f8	 cmp	 r15d, r8d
  00ebc	73 18		 jae	 SHORT $LN517@inflateBac

; 612  :         if (out(out_desc, state->window, state->wsize - left) &&

  00ebe	49 8b 55 40	 mov	 rdx, QWORD PTR [r13+64]
  00ec2	45 2b c7	 sub	 r8d, r15d
  00ec5	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00ec9	41 ff d4	 call	 r12
  00ecc	85 c0		 test	 eax, eax
  00ece	74 06		 je	 SHORT $LN517@inflateBac
  00ed0	83 fb 01	 cmp	 ebx, 1
  00ed3	0f 44 de	 cmove	 ebx, esi
$LN517@inflateBac:

; 613  :             ret == Z_STREAM_END)
; 614  :             ret = Z_BUF_ERROR;
; 615  :     }
; 616  :     strm->next_in = next;

  00ed6	48 8b 45 28	 mov	 rax, QWORD PTR strm$[rbp-120]
  00eda	48 8b 4d c0	 mov	 rcx, QWORD PTR next$[rbp-120]

; 617  :     strm->avail_in = have;
; 618  :     return ret;

  00ede	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00ee3	89 78 08	 mov	 DWORD PTR [rax+8], edi
  00ee6	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00eeb	48 89 08	 mov	 QWORD PTR [rax], rcx
  00eee	8b c3		 mov	 eax, ebx
  00ef0	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]

; 619  : }

  00ef5	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00ef9	41 5f		 pop	 r15
  00efb	41 5d		 pop	 r13
  00efd	41 5c		 pop	 r12
  00eff	5d		 pop	 rbp
  00f00	c3		 ret	 0
$LN254@inflateBac:

; 261  :         return Z_STREAM_ERROR;

  00f01	b8 fe ff ff ff	 mov	 eax, -2

; 619  : }

  00f06	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00f0a	41 5f		 pop	 r15
  00f0c	41 5d		 pop	 r13
  00f0e	41 5c		 pop	 r12
  00f10	5d		 pop	 rbp
  00f11	c3		 ret	 0
  00f12	66 90		 npad	 2
$LN511@inflateBac:
  00f14	00 00 00 00	 DD	 $LN255@inflateBac
  00f18	00 00 00 00	 DD	 $LN339@inflateBac
  00f1c	00 00 00 00	 DD	 $LN31@inflateBac
  00f20	00 00 00 00	 DD	 $LN339@inflateBac
  00f24	00 00 00 00	 DD	 $LN339@inflateBac
  00f28	00 00 00 00	 DD	 $LN56@inflateBac
  00f2c	00 00 00 00	 DD	 $LN339@inflateBac
  00f30	00 00 00 00	 DD	 $LN339@inflateBac
  00f34	00 00 00 00	 DD	 $LN339@inflateBac
  00f38	00 00 00 00	 DD	 $LN302@inflateBac
  00f3c	00 00 00 00	 DD	 $LN339@inflateBac
  00f40	00 00 00 00	 DD	 $LN339@inflateBac
  00f44	00 00 00 00	 DD	 $LN339@inflateBac
  00f48	00 00 00 00	 DD	 $LN339@inflateBac
  00f4c	00 00 00 00	 DD	 $LN339@inflateBac
  00f50	00 00 00 00	 DD	 $LN339@inflateBac
  00f54	00 00 00 00	 DD	 $LN339@inflateBac
  00f58	00 00 00 00	 DD	 $LN337@inflateBac
  00f5c	00 00 00 00	 DD	 $LN338@inflateBac
inflateBack ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\infback.c
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 621  : int ZEXPORT inflateBackEnd(z_streamp strm) {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 622  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 28		 je	 SHORT $LN3@inflateBac
  0000e	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00012	48 85 d2	 test	 rdx, rdx
  00015	74 1f		 je	 SHORT $LN3@inflateBac
  00017	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0001b	48 85 c0	 test	 rax, rax
  0001e	74 16		 je	 SHORT $LN3@inflateBac

; 624  :     ZFREE(strm, strm->state);

  00020	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00024	ff d0		 call	 rax

; 625  :     strm->state = Z_NULL;
; 626  :     Tracev((stderr, "inflate: end\n"));
; 627  :     return Z_OK;

  00026	33 c0		 xor	 eax, eax
  00028	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 628  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN3@inflateBac:

; 623  :         return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2

; 628  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
inflateBackEnd ENDP
_TEXT	ENDS
END
