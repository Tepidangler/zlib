; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35209.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@		; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_C@_06DIJPEION@?$CFs?$CFs?$CFs@		; `string'
EXTRN	__imp_malloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp_wcstombs:PROC
EXTRN	__imp_open:PROC
EXTRN	__imp__wopen:PROC
EXTRN	__imp__lseeki64:PROC
;	COMDAT ??_C@_06DIJPEION@?$CFs?$CFs?$CFs@
CONST	SEGMENT
??_C@_06DIJPEION@?$CFs?$CFs?$CFs@ DB '%s%s%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@ DB '<fd:%d>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
PUBLIC	gz_error
PUBLIC	gzclearerr
PUBLIC	gzerror
PUBLIC	gzeof
PUBLIC	gzoffset
PUBLIC	gzoffset64
PUBLIC	gztell
PUBLIC	gztell64
PUBLIC	gzseek
PUBLIC	gzseek64
PUBLIC	gzrewind
PUBLIC	gzbuffer
PUBLIC	gzopen_w
PUBLIC	gzdopen
PUBLIC	gzopen
PUBLIC	snprintf
PUBLIC	vsnprintf
PUBLIC	__local_stdio_printf_options
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_error DD imagerel $LN26
	DD	imagerel $LN26+260
	DD	imagerel $unwind$gz_error
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzoffset64 DD imagerel $LN15
	DD	imagerel $LN15+91
	DD	imagerel $unwind$gzoffset64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzseek64 DD imagerel $LN50
	DD	imagerel $LN50+331
	DD	imagerel $unwind$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzrewind DD imagerel $LN14
	DD	imagerel $LN14+84
	DD	imagerel $unwind$gzrewind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdopen DD imagerel $LN8
	DD	imagerel $LN8+129
	DD	imagerel $unwind$gzdopen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_open DD imagerel gz_open
	DD	imagerel gz_open+64
	DD	imagerel $unwind$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_open DD imagerel gz_open+64
	DD	imagerel gz_open+576
	DD	imagerel $chain$1$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gz_open DD imagerel gz_open+576
	DD	imagerel gz_open+673
	DD	imagerel $chain$3$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$gz_open DD imagerel gz_open+673
	DD	imagerel gz_open+818
	DD	imagerel $chain$4$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_reset DD imagerel gz_reset
	DD	imagerel gz_reset+72
	DD	imagerel $unwind$gz_reset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$snprintf DD imagerel $LN6
	DD	imagerel $LN6+92
	DD	imagerel $unwind$snprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vsnprintf DD imagerel $LN4
	DD	imagerel $LN4+104
	DD	imagerel $unwind$vsnprintf
;	COMDAT xdata
xdata	SEGMENT
$unwind$vsnprintf DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$snprintf DD 051201H
	DD	0700e6212H
	DD	0500c600dH
	DD	0300bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_reset DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$gz_open DD 021H
	DD	imagerel gz_open
	DD	imagerel gz_open+64
	DD	imagerel $unwind$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gz_open DD 040021H
	DD	0b7400H
	DD	0a5400H
	DD	imagerel gz_open
	DD	imagerel gz_open+64
	DD	imagerel $unwind$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_open DD 043321H
	DD	0a5433H
	DD	0b7405H
	DD	imagerel gz_open
	DD	imagerel gz_open+64
	DD	imagerel $unwind$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_open DD 081201H
	DD	0c3412H
	DD	0f00e3212H
	DD	0d00ae00cH
	DD	06006c008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdopen DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzrewind DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzseek64 DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzoffset64 DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_error DD 081501H
	DD	0a7415H
	DD	096415H
	DD	083415H
	DD	0e0115215H
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT vsnprintf
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
vsnprintf PROC						; COMDAT

; 1438 :     {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	49 8b d9	 mov	 rbx, r9
  00017	49 8b f8	 mov	 rdi, r8
  0001a	48 8b f2	 mov	 rsi, rdx
  0001d	48 8b e9	 mov	 rbp, rcx

; 1439 :         int const _Result = __stdio_common_vsprintf(

  00020	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00025	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  0002a	4c 8b cf	 mov	 r9, rdi
  0002d	4c 8b c6	 mov	 r8, rsi
  00030	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00039	48 8b d5	 mov	 rdx, rbp
  0003c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003f	48 83 c9 02	 or	 rcx, 2
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf

; 1440 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1441 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1442 : 
; 1443 :         return _Result < 0 ? -1 : _Result;
; 1444 :     }

  00049	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004e	b9 ff ff ff ff	 mov	 ecx, -1
  00053	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00058	85 c0		 test	 eax, eax
  0005a	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0005f	0f 48 c1	 cmovs	 eax, ecx
  00062	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT snprintf
_TEXT	SEGMENT
_Buffer$ = 96
_BufferCount$ = 104
_Format$ = 112
snprintf PROC						; COMDAT

; 1927 :     {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00012	49 8b f0	 mov	 rsi, r8

; 1928 :         int _Result;
; 1929 :         va_list _ArgList;
; 1930 :         __crt_va_start(_ArgList, _Format);

  00015	48 8d 6c 24 78	 lea	 rbp, QWORD PTR _Format$[rsp+8]
  0001a	48 8b da	 mov	 rbx, rdx
  0001d	48 8b f9	 mov	 rdi, rcx

; 1439 :         int const _Result = __stdio_common_vsprintf(

  00020	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00025	48 89 6c 24 28	 mov	 QWORD PTR [rsp+40], rbp
  0002a	4c 8b ce	 mov	 r9, rsi
  0002d	4c 8b c3	 mov	 r8, rbx
  00030	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00039	48 8b d7	 mov	 rdx, rdi
  0003c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003f	48 83 c9 02	 or	 rcx, 2
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf

; 1440 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1441 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1442 : 
; 1443 :         return _Result < 0 ? -1 : _Result;

  00049	85 c0		 test	 eax, eax
  0004b	b9 ff ff ff ff	 mov	 ecx, -1
  00050	0f 48 c1	 cmovs	 eax, ecx

; 1931 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1932 :         __crt_va_end(_ArgList);
; 1933 :         return _Result;
; 1934 :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	5f		 pop	 rdi
  00058	5e		 pop	 rsi
  00059	5d		 pop	 rbp
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gz_reset
_TEXT	SEGMENT
state$ = 48
gz_reset PROC						; COMDAT

; 69   : local void gz_reset(gz_statep state) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 70   :     state->x.have = 0;              /* no output data available */

  0000a	33 ff		 xor	 edi, edi
  0000c	48 8b d9	 mov	 rbx, rcx

; 71   :     if (state->mode == GZ_READ) {   /* for reading ... */

  0000f	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00016	89 39		 mov	 DWORD PTR [rcx], edi
  00018	75 09		 jne	 SHORT $LN2@gz_reset

; 72   :         state->eof = 0;             /* not at end of file */

  0001a	48 89 79 50	 mov	 QWORD PTR [rcx+80], rdi

; 73   :         state->past = 0;            /* have not read past end yet */
; 74   :         state->how = LOOK;          /* look for gzip header */

  0001e	89 79 44	 mov	 DWORD PTR [rcx+68], edi

; 75   :     }

  00021	eb 03		 jmp	 SHORT $LN3@gz_reset
$LN2@gz_reset:

; 76   :     else                            /* for writing ... */
; 77   :         state->reset = 0;           /* no deflateReset pending */

  00023	89 79 60	 mov	 DWORD PTR [rcx+96], edi
$LN3@gz_reset:

; 78   :     state->seek = 0;                /* no seek request pending */
; 79   :     gz_error(state, Z_OK, NULL);    /* clear error */

  00026	45 33 c0	 xor	 r8d, r8d
  00029	89 79 70	 mov	 DWORD PTR [rcx+112], edi
  0002c	33 d2		 xor	 edx, edx
  0002e	e8 00 00 00 00	 call	 gz_error

; 80   :     state->x.pos = 0;               /* no uncompressed data yet */

  00033	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 81   :     state->strm.avail_in = 0;       /* no input data yet */

  00037	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi

; 82   : }

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
gz_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gz_open
_TEXT	SEGMENT
path$ = 80
fd$ = 88
mode$ = 96
gz_open	PROC						; COMDAT

; 85   : local gzFile gz_open(const void *path, int fd, const char *mode) {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 86   :     gz_statep state;
; 87   :     z_size_t len;
; 88   :     int oflag;
; 89   : #ifdef O_CLOEXEC
; 90   :     int cloexec = 0;
; 91   : #endif
; 92   : #ifdef O_EXCL
; 93   :     int exclusive = 0;

  00012	45 33 ed	 xor	 r13d, r13d
  00015	4d 8b f8	 mov	 r15, r8
  00018	8b f2		 mov	 esi, edx
  0001a	4c 8b f1	 mov	 r14, rcx
  0001d	45 8b e5	 mov	 r12d, r13d

; 94   : #endif
; 95   : 
; 96   :     /* check input */
; 97   :     if (path == NULL)

  00020	48 85 c9	 test	 rcx, rcx
  00023	0f 84 78 02 00
	00		 je	 $LN54@gz_open

; 98   :         return NULL;
; 99   : 
; 100  :     /* allocate gzFile structure to return */
; 101  :     state = (gz_statep)malloc(sizeof(gz_state));

  00029	b9 d8 00 00 00	 mov	 ecx, 216		; 000000d8H
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00034	48 8b d8	 mov	 rbx, rax

; 102  :     if (state == NULL)

  00037	48 85 c0	 test	 rax, rax
  0003a	0f 84 61 02 00
	00		 je	 $LN54@gz_open
  00040	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi

; 103  :         return NULL;
; 104  :     state->size = 0;            /* no buffers allocated yet */
; 105  :     state->want = GZBUFSIZE;    /* requested buffer size */
; 106  :     state->msg = NULL;          /* no error message yet */
; 107  : 
; 108  :     /* interpret mode */
; 109  :     state->mode = GZ_NONE;
; 110  :     state->level = Z_DEFAULT_COMPRESSION;

  00045	48 c7 c7 ff ff
	ff ff		 mov	 rdi, -1
  0004c	89 78 58	 mov	 DWORD PTR [rax+88], edi
  0004f	44 89 68 28	 mov	 DWORD PTR [rax+40], r13d
  00053	c7 40 2c 00 20
	00 00		 mov	 DWORD PTR [rax+44], 8192 ; 00002000H
  0005a	4c 89 68 78	 mov	 QWORD PTR [rax+120], r13
  0005e	44 89 68 18	 mov	 DWORD PTR [rax+24], r13d

; 111  :     state->strategy = Z_DEFAULT_STRATEGY;

  00062	44 89 68 5c	 mov	 DWORD PTR [rax+92], r13d

; 112  :     state->direct = 0;

  00066	44 89 68 40	 mov	 DWORD PTR [rax+64], r13d

; 113  :     while (*mode) {

  0006a	41 0f b6 07	 movzx	 eax, BYTE PTR [r15]
  0006e	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00073	84 c0		 test	 al, al
  00075	0f 84 95 00 00
	00		 je	 $LN50@gz_open
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
$LL2@gz_open:

; 114  :         if (*mode >= '0' && *mode <= '9')

  00082	0f be c8	 movsx	 ecx, al
  00085	2c 30		 sub	 al, 48			; 00000030H
  00087	3c 09		 cmp	 al, 9
  00089	77 08		 ja	 SHORT $LN8@gz_open

; 115  :             state->level = *mode - '0';

  0008b	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  0008e	89 43 58	 mov	 DWORD PTR [rbx+88], eax
  00091	eb 6d		 jmp	 SHORT $LN21@gz_open
$LN8@gz_open:

; 116  :         else
; 117  :             switch (*mode) {

  00093	83 c1 d5	 add	 ecx, -43		; ffffffd5H
  00096	83 f9 4d	 cmp	 ecx, 77			; 0000004dH
  00099	77 65		 ja	 SHORT $LN21@gz_open
  0009b	48 63 c1	 movsxd	 rax, ecx
  0009e	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN57@gz_open[rdx+rax]
  000a6	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN58@gz_open[rdx+rax*4]
  000ad	48 03 ca	 add	 rcx, rdx
  000b0	ff e1		 jmp	 rcx
$LN10@gz_open:

; 118  :             case 'r':
; 119  :                 state->mode = GZ_READ;

  000b2	c7 43 18 4f 1c
	00 00		 mov	 DWORD PTR [rbx+24], 7247 ; 00001c4fH

; 120  :                 break;

  000b9	eb 45		 jmp	 SHORT $LN21@gz_open
$LN11@gz_open:

; 121  : #ifndef NO_GZCOMPRESS
; 122  :             case 'w':
; 123  :                 state->mode = GZ_WRITE;

  000bb	c7 43 18 b1 79
	00 00		 mov	 DWORD PTR [rbx+24], 31153 ; 000079b1H

; 124  :                 break;

  000c2	eb 3c		 jmp	 SHORT $LN21@gz_open
$LN12@gz_open:

; 125  :             case 'a':
; 126  :                 state->mode = GZ_APPEND;

  000c4	c7 43 18 01 00
	00 00		 mov	 DWORD PTR [rbx+24], 1

; 127  :                 break;

  000cb	eb 33		 jmp	 SHORT $LN21@gz_open
$LN15@gz_open:

; 128  : #endif
; 129  :             case '+':       /* can't read and write at the same time */
; 130  :                 free(state);
; 131  :                 return NULL;
; 132  :             case 'b':       /* ignore -- will request binary anyway */
; 133  :                 break;
; 134  : #ifdef O_CLOEXEC
; 135  :             case 'e':
; 136  :                 cloexec = 1;
; 137  :                 break;
; 138  : #endif
; 139  : #ifdef O_EXCL
; 140  :             case 'x':
; 141  :                 exclusive = 1;

  000cd	41 bc 01 00 00
	00		 mov	 r12d, 1

; 142  :                 break;

  000d3	eb 2b		 jmp	 SHORT $LN21@gz_open
$LN16@gz_open:

; 143  : #endif
; 144  :             case 'f':
; 145  :                 state->strategy = Z_FILTERED;

  000d5	c7 43 5c 01 00
	00 00		 mov	 DWORD PTR [rbx+92], 1

; 146  :                 break;

  000dc	eb 22		 jmp	 SHORT $LN21@gz_open
$LN17@gz_open:

; 147  :             case 'h':
; 148  :                 state->strategy = Z_HUFFMAN_ONLY;

  000de	c7 43 5c 02 00
	00 00		 mov	 DWORD PTR [rbx+92], 2

; 149  :                 break;

  000e5	eb 19		 jmp	 SHORT $LN21@gz_open
$LN18@gz_open:

; 150  :             case 'R':
; 151  :                 state->strategy = Z_RLE;

  000e7	c7 43 5c 03 00
	00 00		 mov	 DWORD PTR [rbx+92], 3

; 152  :                 break;

  000ee	eb 10		 jmp	 SHORT $LN21@gz_open
$LN19@gz_open:

; 153  :             case 'F':
; 154  :                 state->strategy = Z_FIXED;

  000f0	c7 43 5c 04 00
	00 00		 mov	 DWORD PTR [rbx+92], 4

; 155  :                 break;

  000f7	eb 07		 jmp	 SHORT $LN21@gz_open
$LN20@gz_open:

; 156  :             case 'T':
; 157  :                 state->direct = 1;

  000f9	c7 43 40 01 00
	00 00		 mov	 DWORD PTR [rbx+64], 1
$LN21@gz_open:

; 113  :     while (*mode) {

  00100	41 0f b6 47 01	 movzx	 eax, BYTE PTR [r15+1]

; 158  :                 break;
; 159  :             default:        /* could consider as an error, but just ignore */
; 160  :                 ;
; 161  :             }
; 162  :         mode++;

  00105	49 ff c7	 inc	 r15
  00108	84 c0		 test	 al, al
  0010a	0f 85 72 ff ff
	ff		 jne	 $LL2@gz_open
$LN50@gz_open:

; 163  :     }
; 164  : 
; 165  :     /* must provide an "r", "w", or "a" */
; 166  :     if (state->mode == GZ_NONE) {

  00110	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  00113	85 c0		 test	 eax, eax
  00115	0f 84 fd 00 00
	00		 je	 $LN51@gz_open

; 167  :         free(state);
; 168  :         return NULL;
; 169  :     }
; 170  : 
; 171  :     /* can't force transparent read */
; 172  :     if (state->mode == GZ_READ) {

  0011b	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00120	75 11		 jne	 SHORT $LN23@gz_open

; 173  :         if (state->direct) {

  00122	44 39 6b 40	 cmp	 DWORD PTR [rbx+64], r13d
  00126	0f 85 ec 00 00
	00		 jne	 $LN51@gz_open

; 174  :             free(state);
; 175  :             return NULL;
; 176  :         }
; 177  :         state->direct = 1;      /* for empty file */

  0012c	c7 43 40 01 00
	00 00		 mov	 DWORD PTR [rbx+64], 1
$LN23@gz_open:

; 178  :     }
; 179  : 
; 180  :     /* save the path name for error messages */
; 181  : #ifdef WIDECHAR
; 182  :     if (fd == -2)

  00133	83 fe fe	 cmp	 esi, -2
  00136	75 18		 jne	 SHORT $LL25@gz_open

; 183  :         len = wcstombs(NULL, path, 0);

  00138	45 33 c0	 xor	 r8d, r8d
  0013b	49 8b d6	 mov	 rdx, r14
  0013e	33 c9		 xor	 ecx, ecx
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs
  00146	48 8b f8	 mov	 rdi, rax
  00149	eb 0e		 jmp	 SHORT $LN26@gz_open
  0014b	0f 1f 44 00 00	 npad	 5
$LL25@gz_open:

; 184  :     else
; 185  : #endif
; 186  :         len = strlen((const char *)path);

  00150	48 ff c7	 inc	 rdi
  00153	45 38 2c 3e	 cmp	 BYTE PTR [r14+rdi], r13b
  00157	75 f7		 jne	 SHORT $LL25@gz_open
$LN26@gz_open:

; 187  :     state->path = (char *)malloc(len + 1);

  00159	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00163	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 188  :     if (state->path == NULL) {

  00167	48 85 c0	 test	 rax, rax
  0016a	0f 84 a8 00 00
	00		 je	 $LN51@gz_open

; 189  :         free(state);
; 190  :         return NULL;
; 191  :     }
; 192  : #ifdef WIDECHAR
; 193  :     if (fd == -2) {

  00170	83 fe fe	 cmp	 esi, -2
  00173	75 1c		 jne	 SHORT $LN28@gz_open

; 194  :         if (len)

  00175	48 85 ff	 test	 rdi, rdi
  00178	74 12		 je	 SHORT $LN30@gz_open

; 195  :             wcstombs(state->path, path, len + 1);

  0017a	4c 8d 47 01	 lea	 r8, QWORD PTR [rdi+1]
  0017e	49 8b d6	 mov	 rdx, r14
  00181	48 8b c8	 mov	 rcx, rax
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs
  0018a	eb 1b		 jmp	 SHORT $LN29@gz_open
$LN30@gz_open:

; 196  :         else
; 197  :             *(state->path) = 0;

  0018c	44 88 28	 mov	 BYTE PTR [rax], r13b

; 198  :     }

  0018f	eb 16		 jmp	 SHORT $LN29@gz_open
$LN28@gz_open:

; 199  :     else
; 200  : #endif
; 201  :     {
; 202  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 203  :         (void)snprintf(state->path, len + 1, "%s", (const char *)path);

  00191	4d 8b ce	 mov	 r9, r14
  00194	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs@
  0019b	48 8d 57 01	 lea	 rdx, QWORD PTR [rdi+1]
  0019f	48 8b c8	 mov	 rcx, rax
  001a2	e8 00 00 00 00	 call	 snprintf
$LN29@gz_open:

; 204  : #else
; 205  :         strcpy(state->path, path);
; 206  : #endif
; 207  :     }
; 208  : 
; 209  :     /* compute the flags for open() */
; 210  :     oflag =

  001a7	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  001aa	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  001af	75 05		 jne	 SHORT $LN41@gz_open
  001b1	41 8b d5	 mov	 edx, r13d
  001b4	eb 1e		 jmp	 SHORT $LN42@gz_open
$LN41@gz_open:
  001b6	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  001bb	ba 09 01 00 00	 mov	 edx, 265		; 00000109H
  001c0	b9 01 03 00 00	 mov	 ecx, 769		; 00000301H
  001c5	0f 44 d1	 cmove	 edx, ecx
  001c8	41 f7 dc	 neg	 r12d
  001cb	1b c0		 sbb	 eax, eax
  001cd	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  001d2	0b d0		 or	 edx, eax
$LN42@gz_open:
  001d4	0f ba ea 0f	 bts	 edx, 15

; 211  : #ifdef O_LARGEFILE
; 212  :         O_LARGEFILE |
; 213  : #endif
; 214  : #ifdef O_BINARY
; 215  :         O_BINARY |
; 216  : #endif
; 217  : #ifdef O_CLOEXEC
; 218  :         (cloexec ? O_CLOEXEC : 0) |
; 219  : #endif
; 220  :         (state->mode == GZ_READ ?
; 221  :          O_RDONLY :
; 222  :          (O_WRONLY | O_CREAT |
; 223  : #ifdef O_EXCL
; 224  :           (exclusive ? O_EXCL : 0) |
; 225  : #endif
; 226  :           (state->mode == GZ_WRITE ?
; 227  :            O_TRUNC :
; 228  :            O_APPEND)));
; 229  : 
; 230  :     /* open the file with the appropriate flags (or just use fd) */
; 231  :     if (fd == -1)

  001d8	83 fe ff	 cmp	 esi, -1
  001db	75 11		 jne	 SHORT $LN32@gz_open

; 232  :         state->fd = open((const char *)path, oflag, 0666);

  001dd	41 b8 b6 01 00
	00		 mov	 r8d, 438		; 000001b6H
  001e3	49 8b ce	 mov	 rcx, r14
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open
  001ec	eb 14		 jmp	 SHORT $LN81@gz_open
$LN32@gz_open:

; 233  : #ifdef WIDECHAR
; 234  :     else if (fd == -2)

  001ee	83 fe fe	 cmp	 esi, -2
  001f1	75 4d		 jne	 SHORT $LN34@gz_open

; 235  :         state->fd = _wopen(path, oflag, _S_IREAD | _S_IWRITE);

  001f3	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  001f9	49 8b ce	 mov	 rcx, r14
  001fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wopen
$LN81@gz_open:

; 239  :     if (state->fd == -1) {

  00202	89 43 1c	 mov	 DWORD PTR [rbx+28], eax
  00205	8b f0		 mov	 esi, eax
  00207	8b c8		 mov	 ecx, eax
  00209	83 f8 ff	 cmp	 eax, -1
  0020c	75 37		 jne	 SHORT $LN36@gz_open

; 240  :         free(state->path);

  0020e	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN51@gz_open:

; 241  :         free(state);

  00218	48 8b cb	 mov	 rcx, rbx
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 242  :         return NULL;

  00221	33 c0		 xor	 eax, eax
$LN80@gz_open:
  00223	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00228	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 260  : }

  0022d	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00232	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00236	41 5f		 pop	 r15
  00238	41 5e		 pop	 r14
  0023a	41 5d		 pop	 r13
  0023c	41 5c		 pop	 r12
  0023e	5e		 pop	 rsi
  0023f	c3		 ret	 0
$LN34@gz_open:

; 236  : #endif
; 237  :     else
; 238  :         state->fd = fd;

  00240	89 73 1c	 mov	 DWORD PTR [rbx+28], esi
  00243	8b ce		 mov	 ecx, esi
$LN36@gz_open:

; 243  :     }
; 244  :     if (state->mode == GZ_APPEND) {

  00245	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  00248	83 f8 01	 cmp	 eax, 1
  0024b	75 24		 jne	 SHORT $LN37@gz_open

; 245  :         LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */

  0024d	33 d2		 xor	 edx, edx
  0024f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00255	8b ce		 mov	 ecx, esi
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64

; 253  :     }
; 254  : 
; 255  :     /* initialize stream */
; 256  :     gz_reset(state);

  0025d	48 8b cb	 mov	 rcx, rbx
  00260	c7 43 18 b1 79
	00 00		 mov	 DWORD PTR [rbx+24], 31153 ; 000079b1H
  00267	e8 00 00 00 00	 call	 gz_reset

; 257  : 
; 258  :     /* return stream */
; 259  :     return (gzFile)state;

  0026c	48 8b c3	 mov	 rax, rbx
  0026f	eb b2		 jmp	 SHORT $LN80@gz_open
$LN37@gz_open:

; 246  :         state->mode = GZ_WRITE;         /* simplify later checks */
; 247  :     }
; 248  : 
; 249  :     /* save the current position for rewinding (only if reading) */
; 250  :     if (state->mode == GZ_READ) {

  00271	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00276	75 1c		 jne	 SHORT $LN39@gz_open

; 251  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  00278	33 d2		 xor	 edx, edx
  0027a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00286	48 89 43 48	 mov	 QWORD PTR [rbx+72], rax

; 252  :         if (state->start == -1) state->start = 0;

  0028a	48 83 f8 ff	 cmp	 rax, -1
  0028e	75 04		 jne	 SHORT $LN39@gz_open
  00290	4c 89 6b 48	 mov	 QWORD PTR [rbx+72], r13
$LN39@gz_open:

; 253  :     }
; 254  : 
; 255  :     /* initialize stream */
; 256  :     gz_reset(state);

  00294	48 8b cb	 mov	 rcx, rbx
  00297	e8 00 00 00 00	 call	 gz_reset

; 257  : 
; 258  :     /* return stream */
; 259  :     return (gzFile)state;

  0029c	48 8b c3	 mov	 rax, rbx
  0029f	eb 82		 jmp	 SHORT $LN80@gz_open
$LN54@gz_open:

; 260  : }

  002a1	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  002a6	33 c0		 xor	 eax, eax
  002a8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002ac	41 5f		 pop	 r15
  002ae	41 5e		 pop	 r14
  002b0	41 5d		 pop	 r13
  002b2	41 5c		 pop	 r12
  002b4	5e		 pop	 rsi
  002b5	c3		 ret	 0
  002b6	66 90		 npad	 2
$LN58@gz_open:
  002b8	00 00 00 00	 DD	 $LN51@gz_open
  002bc	00 00 00 00	 DD	 $LN19@gz_open
  002c0	00 00 00 00	 DD	 $LN18@gz_open
  002c4	00 00 00 00	 DD	 $LN20@gz_open
  002c8	00 00 00 00	 DD	 $LN12@gz_open
  002cc	00 00 00 00	 DD	 $LN16@gz_open
  002d0	00 00 00 00	 DD	 $LN17@gz_open
  002d4	00 00 00 00	 DD	 $LN10@gz_open
  002d8	00 00 00 00	 DD	 $LN11@gz_open
  002dc	00 00 00 00	 DD	 $LN15@gz_open
  002e0	00 00 00 00	 DD	 $LN21@gz_open
$LN57@gz_open:
  002e4	00		 DB	 0
  002e5	0a		 DB	 10
  002e6	0a		 DB	 10
  002e7	0a		 DB	 10
  002e8	0a		 DB	 10
  002e9	0a		 DB	 10
  002ea	0a		 DB	 10
  002eb	0a		 DB	 10
  002ec	0a		 DB	 10
  002ed	0a		 DB	 10
  002ee	0a		 DB	 10
  002ef	0a		 DB	 10
  002f0	0a		 DB	 10
  002f1	0a		 DB	 10
  002f2	0a		 DB	 10
  002f3	0a		 DB	 10
  002f4	0a		 DB	 10
  002f5	0a		 DB	 10
  002f6	0a		 DB	 10
  002f7	0a		 DB	 10
  002f8	0a		 DB	 10
  002f9	0a		 DB	 10
  002fa	0a		 DB	 10
  002fb	0a		 DB	 10
  002fc	0a		 DB	 10
  002fd	0a		 DB	 10
  002fe	0a		 DB	 10
  002ff	01		 DB	 1
  00300	0a		 DB	 10
  00301	0a		 DB	 10
  00302	0a		 DB	 10
  00303	0a		 DB	 10
  00304	0a		 DB	 10
  00305	0a		 DB	 10
  00306	0a		 DB	 10
  00307	0a		 DB	 10
  00308	0a		 DB	 10
  00309	0a		 DB	 10
  0030a	0a		 DB	 10
  0030b	02		 DB	 2
  0030c	0a		 DB	 10
  0030d	03		 DB	 3
  0030e	0a		 DB	 10
  0030f	0a		 DB	 10
  00310	0a		 DB	 10
  00311	0a		 DB	 10
  00312	0a		 DB	 10
  00313	0a		 DB	 10
  00314	0a		 DB	 10
  00315	0a		 DB	 10
  00316	0a		 DB	 10
  00317	0a		 DB	 10
  00318	0a		 DB	 10
  00319	0a		 DB	 10
  0031a	04		 DB	 4
  0031b	0a		 DB	 10
  0031c	0a		 DB	 10
  0031d	0a		 DB	 10
  0031e	0a		 DB	 10
  0031f	05		 DB	 5
  00320	0a		 DB	 10
  00321	06		 DB	 6
  00322	0a		 DB	 10
  00323	0a		 DB	 10
  00324	0a		 DB	 10
  00325	0a		 DB	 10
  00326	0a		 DB	 10
  00327	0a		 DB	 10
  00328	0a		 DB	 10
  00329	0a		 DB	 10
  0032a	0a		 DB	 10
  0032b	07		 DB	 7
  0032c	0a		 DB	 10
  0032d	0a		 DB	 10
  0032e	0a		 DB	 10
  0032f	0a		 DB	 10
  00330	08		 DB	 8
  00331	09		 DB	 9
gz_open	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gzopen
_TEXT	SEGMENT
path$ = 8
mode$ = 16
gzopen	PROC						; COMDAT

; 264  :     return gz_open(path, -1, mode);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	ba ff ff ff ff	 mov	 edx, -1
  00008	e9 00 00 00 00	 jmp	 gz_open
gzopen	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gzdopen
_TEXT	SEGMENT
fd$ = 48
mode$ = 56
gzdopen	PROC						; COMDAT

; 273  : gzFile ZEXPORT gzdopen(int fd, const char *mode) {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f2	 mov	 rsi, rdx
  00012	8b d9		 mov	 ebx, ecx

; 274  :     char *path;         /* identifier for error messages */
; 275  :     gzFile gz;
; 276  : 
; 277  :     if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)

  00014	83 f9 ff	 cmp	 ecx, -1
  00017	74 56		 je	 SHORT $LN3@gzdopen
  00019	b9 13 00 00 00	 mov	 ecx, 19
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00024	48 8b f8	 mov	 rdi, rax
  00027	48 85 c0	 test	 rax, rax
  0002a	74 43		 je	 SHORT $LN3@gzdopen

; 278  :         return NULL;
; 279  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 280  :     (void)snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd);

  0002c	44 8b cb	 mov	 r9d, ebx
  0002f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO@
  00036	ba 13 00 00 00	 mov	 edx, 19
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 snprintf

; 281  : #else
; 282  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */
; 283  : #endif
; 284  :     gz = gz_open(path, fd, mode);

  00043	4c 8b c6	 mov	 r8, rsi
  00046	8b d3		 mov	 edx, ebx
  00048	48 8b cf	 mov	 rcx, rdi
  0004b	e8 00 00 00 00	 call	 gz_open

; 285  :     free(path);

  00050	48 8b cf	 mov	 rcx, rdi
  00053	48 8b d8	 mov	 rbx, rax
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 286  :     return gz;

  0005c	48 8b c3	 mov	 rax, rbx

; 287  : }

  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00064	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN3@gzdopen:
  0006f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00074	33 c0		 xor	 eax, eax
  00076	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
gzdopen	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gzopen_w
_TEXT	SEGMENT
path$ = 8
mode$ = 16
gzopen_w PROC						; COMDAT

; 292  :     return gz_open(path, -2, mode);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	ba fe ff ff ff	 mov	 edx, -2
  00008	e9 00 00 00 00	 jmp	 gz_open
gzopen_w ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gzbuffer
_TEXT	SEGMENT
file$ = 8
size$ = 16
gzbuffer PROC						; COMDAT

; 298  :     gz_statep state;
; 299  : 
; 300  :     /* get internal structure and check integrity */
; 301  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2e		 je	 SHORT $LN8@gzbuffer

; 302  :         return -1;
; 303  :     state = (gz_statep)file;
; 304  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00005	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  00008	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0000d	74 07		 je	 SHORT $LN3@gzbuffer
  0000f	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00014	75 1d		 jne	 SHORT $LN8@gzbuffer
$LN3@gzbuffer:

; 305  :         return -1;
; 306  : 
; 307  :     /* make sure we haven't already allocated memory */
; 308  :     if (state->size != 0)

  00016	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  0001a	75 17		 jne	 SHORT $LN8@gzbuffer

; 309  :         return -1;
; 310  : 
; 311  :     /* check and set requested size */
; 312  :     if ((size << 1) < size)

  0001c	8d 04 12	 lea	 eax, DWORD PTR [rdx+rdx]
  0001f	3b c2		 cmp	 eax, edx
  00021	72 10		 jb	 SHORT $LN8@gzbuffer

; 314  :     if (size < 8)
; 315  :         size = 8;               /* needed to behave well with flushing */
; 316  :     state->want = size;

  00023	b8 08 00 00 00	 mov	 eax, 8
  00028	3b d0		 cmp	 edx, eax
  0002a	0f 43 c2	 cmovae	 eax, edx
  0002d	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 317  :     return 0;

  00030	33 c0		 xor	 eax, eax

; 318  : }

  00032	c3		 ret	 0
$LN8@gzbuffer:

; 313  :         return -1;              /* need to be able to double it */

  00033	b8 ff ff ff ff	 mov	 eax, -1

; 318  : }

  00038	c3		 ret	 0
gzbuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gzrewind
_TEXT	SEGMENT
file$ = 48
gzrewind PROC						; COMDAT

; 321  : int ZEXPORT gzrewind(gzFile file) {

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 322  :     gz_statep state;
; 323  : 
; 324  :     /* get internal structure */
; 325  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 3b		 je	 SHORT $LN4@gzrewind

; 326  :         return -1;
; 327  :     state = (gz_statep)file;
; 328  : 
; 329  :     /* check that we're reading and that there's no error */
; 330  :     if (state->mode != GZ_READ ||

  0000e	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00015	75 32		 jne	 SHORT $LN4@gzrewind
  00017	8b 41 74	 mov	 eax, DWORD PTR [rcx+116]
  0001a	85 c0		 test	 eax, eax
  0001c	74 05		 je	 SHORT $LN3@gzrewind
  0001e	83 f8 fb	 cmp	 eax, -5
  00021	75 26		 jne	 SHORT $LN4@gzrewind
$LN3@gzrewind:

; 333  : 
; 334  :     /* back up and start over */
; 335  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  00023	48 8b 51 48	 mov	 rdx, QWORD PTR [rcx+72]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00033	48 83 f8 ff	 cmp	 rax, -1
  00037	74 10		 je	 SHORT $LN4@gzrewind

; 336  :         return -1;
; 337  :     gz_reset(state);

  00039	48 8b cb	 mov	 rcx, rbx
  0003c	e8 00 00 00 00	 call	 gz_reset

; 338  :     return 0;

  00041	33 c0		 xor	 eax, eax

; 339  : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
$LN4@gzrewind:

; 331  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 332  :         return -1;

  00049	b8 ff ff ff ff	 mov	 eax, -1

; 339  : }

  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5b		 pop	 rbx
  00053	c3		 ret	 0
gzrewind ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gzseek64
_TEXT	SEGMENT
file$ = 48
tv287 = 48
offset$ = 56
whence$ = 64
gzseek64 PROC						; COMDAT

; 342  : z_off64_t ZEXPORT gzseek64(gzFile file, z_off64_t offset, int whence) {

$LN50:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fa	 mov	 rdi, rdx
  00017	48 8b d9	 mov	 rbx, rcx

; 343  :     unsigned n;
; 344  :     z_off64_t ret;
; 345  :     gz_statep state;
; 346  : 
; 347  :     /* get internal structure and check integrity */
; 348  :     if (file == NULL)

  0001a	48 85 c9	 test	 rcx, rcx
  0001d	0f 84 0c 01 00
	00		 je	 $LN26@gzseek64

; 349  :         return -1;
; 350  :     state = (gz_statep)file;
; 351  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00023	8b 51 18	 mov	 edx, DWORD PTR [rcx+24]
  00026	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  0002c	74 0c		 je	 SHORT $LN23@gzseek64
  0002e	81 fa b1 79 00
	00		 cmp	 edx, 31153		; 000079b1H
  00034	0f 85 f5 00 00
	00		 jne	 $LN26@gzseek64
$LN23@gzseek64:

; 352  :         return -1;
; 353  : 
; 354  :     /* check that there's no error */
; 355  :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  0003a	8b 41 74	 mov	 eax, DWORD PTR [rcx+116]
  0003d	85 c0		 test	 eax, eax
  0003f	74 09		 je	 SHORT $LN4@gzseek64
  00041	83 f8 fb	 cmp	 eax, -5
  00044	0f 85 e5 00 00
	00		 jne	 $LN26@gzseek64
$LN4@gzseek64:

; 356  :         return -1;
; 357  : 
; 358  :     /* can only seek from start or relative to current position */
; 359  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  0004a	45 85 c0	 test	 r8d, r8d
  0004d	74 1a		 je	 SHORT $LN22@gzseek64
  0004f	41 83 f8 01	 cmp	 r8d, 1
  00053	0f 85 d6 00 00
	00		 jne	 $LN26@gzseek64

; 365  :     else if (state->seek)

  00059	83 79 70 00	 cmp	 DWORD PTR [rcx+112], 0
  0005d	48 8d 71 70	 lea	 rsi, QWORD PTR [rcx+112]
  00061	74 0e		 je	 SHORT $LN8@gzseek64

; 366  :         offset += state->skip;

  00063	48 03 79 68	 add	 rdi, QWORD PTR [rcx+104]
  00067	eb 08		 jmp	 SHORT $LN8@gzseek64
$LN22@gzseek64:

; 360  :         return -1;
; 361  : 
; 362  :     /* normalize offset to a SEEK_CUR specification */
; 363  :     if (whence == SEEK_SET)
; 364  :         offset -= state->x.pos;

  00069	48 2b 79 10	 sub	 rdi, QWORD PTR [rcx+16]
  0006d	48 8d 71 70	 lea	 rsi, QWORD PTR [rcx+112]
$LN8@gzseek64:

; 367  :     state->seek = 0;

  00071	33 ed		 xor	 ebp, ebp
  00073	89 2e		 mov	 DWORD PTR [rsi], ebp

; 368  : 
; 369  :     /* if within raw area while reading, just go there */
; 370  :     if (state->mode == GZ_READ && state->how == COPY &&

  00075	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  0007b	75 55		 jne	 SHORT $LN9@gzseek64
  0007d	83 79 44 01	 cmp	 DWORD PTR [rcx+68], 1
  00081	75 4f		 jne	 SHORT $LN9@gzseek64
  00083	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00087	48 03 cf	 add	 rcx, rdi
  0008a	78 46		 js	 SHORT $LN9@gzseek64

; 371  :             state->x.pos + offset >= 0) {
; 372  :         ret = LSEEK(state->fd, offset - (z_off64_t)state->x.have, SEEK_CUR);

  0008c	8b 03		 mov	 eax, DWORD PTR [rbx]
  0008e	48 8b d7	 mov	 rdx, rdi
  00091	8b 4b 1c	 mov	 ecx, DWORD PTR [rbx+28]
  00094	48 2b d0	 sub	 rdx, rax
  00097	41 b8 01 00 00
	00		 mov	 r8d, 1
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64

; 373  :         if (ret == -1)

  000a3	48 83 f8 ff	 cmp	 rax, -1
  000a7	0f 84 82 00 00
	00		 je	 $LN26@gzseek64

; 374  :             return -1;
; 375  :         state->x.have = 0;
; 376  :         state->eof = 0;
; 377  :         state->past = 0;
; 378  :         state->seek = 0;
; 379  :         gz_error(state, Z_OK, NULL);

  000ad	45 33 c0	 xor	 r8d, r8d
  000b0	89 2b		 mov	 DWORD PTR [rbx], ebp
  000b2	33 d2		 xor	 edx, edx
  000b4	48 89 6b 50	 mov	 QWORD PTR [rbx+80], rbp
  000b8	48 8b cb	 mov	 rcx, rbx
  000bb	89 2e		 mov	 DWORD PTR [rsi], ebp
  000bd	e8 00 00 00 00	 call	 gz_error

; 380  :         state->strm.avail_in = 0;
; 381  :         state->x.pos += offset;

  000c2	48 01 7b 10	 add	 QWORD PTR [rbx+16], rdi

; 382  :         return state->x.pos;

  000c6	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000ca	89 ab 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ebp
  000d0	eb 64		 jmp	 SHORT $LN1@gzseek64
$LN9@gzseek64:

; 383  :     }
; 384  : 
; 385  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 386  :     if (offset < 0) {

  000d2	48 85 ff	 test	 rdi, rdi
  000d5	79 1b		 jns	 SHORT $LN24@gzseek64

; 387  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  000d7	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  000dd	75 50		 jne	 SHORT $LN26@gzseek64

; 388  :             return -1;
; 389  :         offset += state->x.pos;

  000df	48 03 7b 10	 add	 rdi, QWORD PTR [rbx+16]

; 390  :         if (offset < 0)                     /* before start of file! */

  000e3	78 4a		 js	 SHORT $LN26@gzseek64

; 391  :             return -1;
; 392  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  000e5	48 8b cb	 mov	 rcx, rbx
  000e8	e8 00 00 00 00	 call	 gzrewind
  000ed	83 f8 ff	 cmp	 eax, -1
  000f0	74 3d		 je	 SHORT $LN26@gzseek64
$LN24@gzseek64:

; 394  :     }
; 395  : 
; 396  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 397  :     if (state->mode == GZ_READ) {

  000f2	81 7b 18 4f 1c
	00 00		 cmp	 DWORD PTR [rbx+24], 7247 ; 00001c4fH
  000f9	75 1b		 jne	 SHORT $LN25@gzseek64

; 398  :         n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?

  000fb	8b 13		 mov	 edx, DWORD PTR [rbx]

; 399  :             (unsigned)offset : state->x.have;
; 400  :         state->x.have -= n;

  000fd	48 3b d7	 cmp	 rdx, rdi
  00100	8b c2		 mov	 eax, edx
  00102	0f 47 c7	 cmova	 eax, edi
  00105	8b c8		 mov	 ecx, eax
  00107	2b d0		 sub	 edx, eax

; 401  :         state->x.next += n;

  00109	48 01 4b 08	 add	 QWORD PTR [rbx+8], rcx

; 402  :         state->x.pos += n;

  0010d	48 01 4b 10	 add	 QWORD PTR [rbx+16], rcx

; 403  :         offset -= n;

  00111	48 2b f9	 sub	 rdi, rcx
  00114	89 13		 mov	 DWORD PTR [rbx], edx
$LN25@gzseek64:

; 404  :     }
; 405  : 
; 406  :     /* request skip (if not zero) */
; 407  :     if (offset) {

  00116	48 85 ff	 test	 rdi, rdi
  00119	74 0b		 je	 SHORT $LN16@gzseek64

; 408  :         state->seek = 1;

  0011b	c7 43 70 01 00
	00 00		 mov	 DWORD PTR [rbx+112], 1

; 409  :         state->skip = offset;

  00122	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi
$LN16@gzseek64:

; 410  :     }
; 411  :     return state->x.pos + offset;

  00126	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0012a	48 03 c7	 add	 rax, rdi
  0012d	eb 07		 jmp	 SHORT $LN1@gzseek64
$LN26@gzseek64:

; 393  :             return -1;

  0012f	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN1@gzseek64:

; 412  : }

  00136	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0013b	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00140	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00145	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00149	5f		 pop	 rdi
  0014a	c3		 ret	 0
gzseek64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gzseek
_TEXT	SEGMENT
file$ = 8
offset$ = 16
whence$ = 24
gzseek	PROC						; COMDAT

; 416  :     z_off64_t ret;
; 417  : 
; 418  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00000	e9 00 00 00 00	 jmp	 gzseek64
gzseek	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gztell64
_TEXT	SEGMENT
file$ = 8
gztell64 PROC						; COMDAT

; 424  :     gz_statep state;
; 425  : 
; 426  :     /* get internal structure and check integrity */
; 427  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2d		 je	 SHORT $LN7@gztell64

; 428  :         return -1;
; 429  :     state = (gz_statep)file;
; 430  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00005	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  00008	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0000d	74 07		 je	 SHORT $LN3@gztell64
  0000f	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00014	75 1c		 jne	 SHORT $LN7@gztell64
$LN3@gztell64:

; 432  : 
; 433  :     /* return position */
; 434  :     return state->x.pos + (state->seek ? state->skip : 0);

  00016	83 79 70 00	 cmp	 DWORD PTR [rcx+112], 0
  0001a	74 0c		 je	 SHORT $LN5@gztell64
  0001c	48 8b 51 68	 mov	 rdx, QWORD PTR [rcx+104]
  00020	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00024	48 03 c2	 add	 rax, rdx

; 435  : }

  00027	c3		 ret	 0
$LN5@gztell64:

; 432  : 
; 433  :     /* return position */
; 434  :     return state->x.pos + (state->seek ? state->skip : 0);

  00028	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0002c	33 d2		 xor	 edx, edx
  0002e	48 03 c2	 add	 rax, rdx

; 435  : }

  00031	c3		 ret	 0
$LN7@gztell64:

; 431  :         return -1;

  00032	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1

; 435  : }

  00039	c3		 ret	 0
gztell64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gztell
_TEXT	SEGMENT
file$ = 8
gztell	PROC						; COMDAT

; 439  :     z_off64_t ret;
; 440  : 
; 441  :     ret = gztell64(file);

  00000	e9 00 00 00 00	 jmp	 gztell64
gztell	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gzoffset64
_TEXT	SEGMENT
file$ = 48
gzoffset64 PROC						; COMDAT

; 446  : z_off64_t ZEXPORT gzoffset64(gzFile file) {

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 447  :     z_off64_t offset;
; 448  :     gz_statep state;
; 449  : 
; 450  :     /* get internal structure and check integrity */
; 451  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 40		 je	 SHORT $LN7@gzoffset64

; 452  :         return -1;
; 453  :     state = (gz_statep)file;
; 454  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  0000e	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  00011	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00016	74 07		 je	 SHORT $LN3@gzoffset64
  00018	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  0001d	75 2f		 jne	 SHORT $LN7@gzoffset64
$LN3@gzoffset64:

; 455  :         return -1;
; 456  : 
; 457  :     /* compute and return effective offset in file */
; 458  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  0001f	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  00022	33 d2		 xor	 edx, edx
  00024	41 b8 01 00 00
	00		 mov	 r8d, 1
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64

; 459  :     if (offset == -1)

  00030	48 83 f8 ff	 cmp	 rax, -1
  00034	74 18		 je	 SHORT $LN7@gzoffset64

; 461  :     if (state->mode == GZ_READ)             /* reading */

  00036	81 7b 18 4f 1c
	00 00		 cmp	 DWORD PTR [rbx+24], 7247 ; 00001c4fH
  0003d	75 16		 jne	 SHORT $LN1@gzoffset64

; 462  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  0003f	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [rbx+136]
  00045	48 2b c1	 sub	 rax, rcx

; 463  :     return offset;
; 464  : }

  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5b		 pop	 rbx
  0004d	c3		 ret	 0
$LN7@gzoffset64:

; 460  :         return -1;

  0004e	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN1@gzoffset64:

; 463  :     return offset;
; 464  : }

  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5b		 pop	 rbx
  0005a	c3		 ret	 0
gzoffset64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gzoffset
_TEXT	SEGMENT
file$ = 8
gzoffset PROC						; COMDAT

; 468  :     z_off64_t ret;
; 469  : 
; 470  :     ret = gzoffset64(file);

  00000	e9 00 00 00 00	 jmp	 gzoffset64
gzoffset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gzeof
_TEXT	SEGMENT
file$ = 8
gzeof	PROC						; COMDAT

; 476  :     gz_statep state;
; 477  : 
; 478  :     /* get internal structure and check integrity */
; 479  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 0e		 je	 SHORT $LN8@gzeof

; 480  :         return 0;
; 481  :     state = (gz_statep)file;
; 482  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00005	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  00008	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0000d	75 04		 jne	 SHORT $LN8@gzeof

; 483  :         return 0;
; 484  : 
; 485  :     /* return end-of-file state */
; 486  :     return state->mode == GZ_READ ? state->past : 0;

  0000f	8b 41 54	 mov	 eax, DWORD PTR [rcx+84]

; 487  : }

  00012	c3		 ret	 0
$LN8@gzeof:
  00013	33 c0		 xor	 eax, eax
  00015	c3		 ret	 0
gzeof	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gzerror
_TEXT	SEGMENT
file$ = 8
errnum$ = 16
gzerror	PROC						; COMDAT

; 491  :     gz_statep state;
; 492  : 
; 493  :     /* get internal structure and check integrity */
; 494  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 3c		 je	 SHORT $LN11@gzerror

; 495  :         return NULL;
; 496  :     state = (gz_statep)file;
; 497  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00005	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  00008	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0000d	74 07		 je	 SHORT $LN3@gzerror
  0000f	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00014	75 2b		 jne	 SHORT $LN11@gzerror
$LN3@gzerror:

; 499  : 
; 500  :     /* return error information */
; 501  :     if (errnum != NULL)

  00016	48 85 d2	 test	 rdx, rdx
  00019	74 05		 je	 SHORT $LN4@gzerror

; 502  :         *errnum = state->err;

  0001b	8b 41 74	 mov	 eax, DWORD PTR [rcx+116]
  0001e	89 02		 mov	 DWORD PTR [rdx], eax
$LN4@gzerror:

; 503  :     return state->err == Z_MEM_ERROR ? "out of memory" :

  00020	83 79 74 fc	 cmp	 DWORD PTR [rcx+116], -4
  00024	75 08		 jne	 SHORT $LN8@gzerror
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@

; 504  :                                        (state->msg == NULL ? "" : state->msg);
; 505  : }

  0002d	c3		 ret	 0
$LN8@gzerror:

; 503  :     return state->err == Z_MEM_ERROR ? "out of memory" :

  0002e	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@@
  00039	48 85 c9	 test	 rcx, rcx
  0003c	48 0f 45 c1	 cmovne	 rax, rcx

; 504  :                                        (state->msg == NULL ? "" : state->msg);
; 505  : }

  00040	c3		 ret	 0
$LN11@gzerror:

; 498  :         return NULL;

  00041	33 c0		 xor	 eax, eax

; 504  :                                        (state->msg == NULL ? "" : state->msg);
; 505  : }

  00043	c3		 ret	 0
gzerror	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gzclearerr
_TEXT	SEGMENT
file$ = 8
gzclearerr PROC						; COMDAT

; 509  :     gz_statep state;
; 510  : 
; 511  :     /* get internal structure and check integrity */
; 512  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2b		 je	 SHORT $LN1@gzclearerr

; 513  :         return;
; 514  :     state = (gz_statep)file;
; 515  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00005	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  00008	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0000d	74 11		 je	 SHORT $LN6@gzclearerr
  0000f	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00014	75 1a		 jne	 SHORT $LN1@gzclearerr

; 521  :         state->past = 0;
; 522  :     }
; 523  :     gz_error(state, Z_OK, NULL);

  00016	45 33 c0	 xor	 r8d, r8d
  00019	33 d2		 xor	 edx, edx
  0001b	e9 00 00 00 00	 jmp	 gz_error
$LN6@gzclearerr:

; 516  :         return;
; 517  : 
; 518  :     /* clear error and end-of-file */
; 519  :     if (state->mode == GZ_READ) {
; 520  :         state->eof = 0;

  00020	33 c0		 xor	 eax, eax

; 521  :         state->past = 0;
; 522  :     }
; 523  :     gz_error(state, Z_OK, NULL);

  00022	45 33 c0	 xor	 r8d, r8d
  00025	33 d2		 xor	 edx, edx
  00027	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
  0002b	e9 00 00 00 00	 jmp	 gz_error
$LN1@gzclearerr:

; 524  : }

  00030	c3		 ret	 0
gzclearerr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzlib.c
;	COMDAT gz_error
_TEXT	SEGMENT
state$ = 64
err$ = 72
msg$ = 80
gz_error PROC						; COMDAT

; 532  : void ZLIB_INTERNAL gz_error(gz_statep state, int err, const char *msg) {

$LN26:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00015	4c 8b f1	 mov	 r14, rcx
  00018	49 8b f8	 mov	 rdi, r8

; 533  :     /* free previously allocated message and clear */
; 534  :     if (state->msg != NULL) {

  0001b	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0001f	8b da		 mov	 ebx, edx
  00021	48 85 c9	 test	 rcx, rcx
  00024	74 15		 je	 SHORT $LN9@gz_error

; 535  :         if (state->err != Z_MEM_ERROR)

  00026	41 83 7e 74 fc	 cmp	 DWORD PTR [r14+116], -4
  0002b	74 06		 je	 SHORT $LN3@gz_error

; 536  :             free(state->msg);

  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@gz_error:

; 537  :         state->msg = NULL;

  00033	49 c7 46 78 00
	00 00 00	 mov	 QWORD PTR [r14+120], 0
$LN9@gz_error:

; 538  :     }
; 539  : 
; 540  :     /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
; 541  :     if (err != Z_OK && err != Z_BUF_ERROR)

  0003b	85 db		 test	 ebx, ebx
  0003d	74 0c		 je	 SHORT $LN4@gz_error
  0003f	83 fb fb	 cmp	 ebx, -5
  00042	74 07		 je	 SHORT $LN4@gz_error

; 542  :         state->x.have = 0;

  00044	41 c7 06 00 00
	00 00		 mov	 DWORD PTR [r14], 0
$LN4@gz_error:

; 543  : 
; 544  :     /* set error code, and if no message, then done */
; 545  :     state->err = err;

  0004b	41 89 5e 74	 mov	 DWORD PTR [r14+116], ebx

; 546  :     if (msg == NULL)

  0004f	48 85 ff	 test	 rdi, rdi
  00052	0f 84 96 00 00
	00		 je	 $LN1@gz_error

; 547  :         return;
; 548  : 
; 549  :     /* for an out of memory error, return literal string when requested */
; 550  :     if (err == Z_MEM_ERROR)

  00058	83 fb fc	 cmp	 ebx, -4
  0005b	0f 84 8d 00 00
	00		 je	 $LN1@gz_error

; 551  :         return;
; 552  : 
; 553  :     /* construct error message with path */
; 554  :     if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==

  00061	48 c7 c3 ff ff
	ff ff		 mov	 rbx, -1
  00068	48 8b c3	 mov	 rax, rbx
  0006b	0f 1f 44 00 00	 npad	 5
$LL13@gz_error:
  00070	48 ff c0	 inc	 rax
  00073	80 3c 07 00	 cmp	 BYTE PTR [rdi+rax], 0
  00077	75 f7		 jne	 SHORT $LL13@gz_error
  00079	49 8b 56 20	 mov	 rdx, QWORD PTR [r14+32]
  0007d	48 8b cb	 mov	 rcx, rbx
$LL12@gz_error:
  00080	48 ff c1	 inc	 rcx
  00083	80 3c 0a 00	 cmp	 BYTE PTR [rdx+rcx], 0
  00087	75 f7		 jne	 SHORT $LL12@gz_error
  00089	48 83 c0 03	 add	 rax, 3
  0008d	48 03 c8	 add	 rcx, rax
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00096	49 89 46 78	 mov	 QWORD PTR [r14+120], rax
  0009a	48 8b c8	 mov	 rcx, rax
  0009d	48 85 c0	 test	 rax, rax
  000a0	75 0a		 jne	 SHORT $LN7@gz_error

; 555  :             NULL) {
; 556  :         state->err = Z_MEM_ERROR;

  000a2	41 c7 46 74 fc
	ff ff ff	 mov	 DWORD PTR [r14+116], -4

; 557  :         return;

  000aa	eb 42		 jmp	 SHORT $LN1@gz_error
$LN7@gz_error:

; 558  :     }
; 559  : #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
; 560  :     (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,

  000ac	4d 8b 4e 20	 mov	 r9, QWORD PTR [r14+32]
  000b0	48 8b c3	 mov	 rax, rbx
$LL11@gz_error:
  000b3	80 7c 07 01 00	 cmp	 BYTE PTR [rdi+rax+1], 0
  000b8	48 8d 40 01	 lea	 rax, QWORD PTR [rax+1]
  000bc	75 f5		 jne	 SHORT $LL11@gz_error
  000be	66 90		 npad	 2
$LL10@gz_error:
  000c0	48 ff c3	 inc	 rbx
  000c3	41 80 3c 19 00	 cmp	 BYTE PTR [r9+rbx], 0
  000c8	75 f6		 jne	 SHORT $LL10@gz_error
  000ca	48 8d 50 03	 lea	 rdx, QWORD PTR [rax+3]
  000ce	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  000d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5@
  000da	48 03 d3	 add	 rdx, rbx
  000dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06DIJPEION@?$CFs?$CFs?$CFs@
  000e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e9	e8 00 00 00 00	 call	 snprintf
$LN1@gz_error:

; 561  :                    "%s%s%s", state->path, ": ", msg);
; 562  : #else
; 563  :     strcpy(state->msg, state->path);
; 564  :     strcat(state->msg, ": ");
; 565  :     strcat(state->msg, msg);
; 566  : #endif
; 567  : }

  000ee	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000f3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f8	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000fd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00101	41 5e		 pop	 r14
  00103	c3		 ret	 0
gz_error ENDP
_TEXT	ENDS
END
