; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35209.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@	; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error@	; `string'
PUBLIC	??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int@ ; `string'
PUBLIC	??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@ ; `string'
EXTRN	__imp_close:PROC
EXTRN	__imp_strerror:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_read:PROC
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@ DB 'out of room t'
	DB	'o push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@
CONST	SEGMENT
??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@ DB 'request doe'
	DB	's not fit in a size_t', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int@
CONST	SEGMENT
??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int@ DB 'request does'
	DB	' not fit in an int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error@ DB 'compressed data error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@ DB 'internal err'
	DB	'or: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@ DB 'unexpected end of file', 00H ; `string'
PUBLIC	gzdirect
PUBLIC	gzgets
PUBLIC	gzungetc
PUBLIC	gzgetc_
PUBLIC	gzgetc
PUBLIC	gzfread
PUBLIC	gzread
PUBLIC	gzclose_r
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdirect DD imagerel $LN10
	DD	imagerel $LN10+56
	DD	imagerel $unwind$gzdirect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgets DD imagerel $LN41
	DD	imagerel $LN41+301
	DD	imagerel $unwind$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzungetc DD imagerel $LN37
	DD	imagerel $LN37+315
	DD	imagerel $unwind$gzungetc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgetc DD imagerel $LN11
	DD	imagerel $LN11+115
	DD	imagerel $unwind$gzgetc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzfread DD imagerel $LN17
	DD	imagerel $LN17+120
	DD	imagerel $unwind$gzfread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzread DD imagerel $LN17
	DD	imagerel $LN17+103
	DD	imagerel $unwind$gzread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_read DD imagerel gz_read
	DD	imagerel gz_read+346
	DD	imagerel $unwind$gz_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_skip DD imagerel gz_skip
	DD	imagerel gz_skip+121
	DD	imagerel $unwind$gz_skip
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_fetch DD imagerel gz_fetch
	DD	imagerel gz_fetch+169
	DD	imagerel $unwind$gz_fetch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_decomp DD imagerel gz_decomp
	DD	imagerel gz_decomp+275
	DD	imagerel $unwind$gz_decomp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_look DD imagerel gz_look
	DD	imagerel gz_look+405
	DD	imagerel $unwind$gz_look
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_avail DD imagerel gz_avail
	DD	imagerel gz_avail+144
	DD	imagerel $unwind$gz_avail
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_load DD imagerel gz_load
	DD	imagerel gz_load+169
	DD	imagerel $unwind$gz_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose_r DD imagerel $LN12
	DD	imagerel $LN12+35
	DD	imagerel $unwind$gzclose_r
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gzclose_r DD imagerel $LN12+35
	DD	imagerel $LN12+160
	DD	imagerel $chain$1$gzclose_r
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gzclose_r DD imagerel $LN12+160
	DD	imagerel $LN12+171
	DD	imagerel $chain$2$gzclose_r
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gzclose_r DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+35
	DD	imagerel $unwind$gzclose_r
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gzclose_r DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN12
	DD	imagerel $LN12+35
	DD	imagerel $unwind$gzclose_r
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_r DD 020601H
	DD	060023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_load DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_avail DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_look DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_decomp DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_fetch DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_skip DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_read DD 0c1c01H
	DD	0d641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzread DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzfread DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgetc DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzungetc DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgets DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdirect DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gzclose_r
_TEXT	SEGMENT
file$ = 48
gzclose_r PROC						; COMDAT

; 578  : int ZEXPORT gzclose_r(gzFile file) {

$LN12:
  00000	40 56		 push	 rsi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f1	 mov	 rsi, rcx

; 579  :     int ret, err;
; 580  :     gz_statep state;
; 581  : 
; 582  :     /* get internal structure */
; 583  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	0f 84 8e 00 00
	00		 je	 $LN6@gzclose_r

; 584  :         return Z_STREAM_ERROR;
; 585  :     state = (gz_statep)file;
; 586  : 
; 587  :     /* check that we're reading */
; 588  :     if (state->mode != GZ_READ)

  00012	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00019	0f 85 81 00 00
	00		 jne	 $LN6@gzclose_r

; 590  : 
; 591  :     /* free memory and close file */
; 592  :     if (state->size) {

  0001f	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  00023	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00028	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0002d	74 1d		 je	 SHORT $LN4@gzclose_r

; 593  :         inflateEnd(&(state->strm));

  0002f	48 83 e9 80	 sub	 rcx, -128		; ffffffffffffff80H
  00033	e8 00 00 00 00	 call	 inflateEnd

; 594  :         free(state->out);

  00038	48 8b 4e 38	 mov	 rcx, QWORD PTR [rsi+56]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 595  :         free(state->in);

  00042	48 8b 4e 30	 mov	 rcx, QWORD PTR [rsi+48]
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@gzclose_r:

; 596  :     }
; 597  :     err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;

  0004c	b8 fb ff ff ff	 mov	 eax, -5
  00051	33 ff		 xor	 edi, edi
  00053	39 46 74	 cmp	 DWORD PTR [rsi+116], eax

; 598  :     gz_error(state, Z_OK, NULL);

  00056	48 8b ce	 mov	 rcx, rsi
  00059	0f 44 f8	 cmove	 edi, eax
  0005c	45 33 c0	 xor	 r8d, r8d
  0005f	33 d2		 xor	 edx, edx
  00061	e8 00 00 00 00	 call	 gz_error

; 599  :     free(state->path);

  00066	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 600  :     ret = close(state->fd);

  00070	8b 4e 1c	 mov	 ecx, DWORD PTR [rsi+28]
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 601  :     free(state);

  00079	48 8b ce	 mov	 rcx, rsi
  0007c	8b d8		 mov	 ebx, eax
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 602  :     return ret ? Z_ERRNO : err;

  00084	85 db		 test	 ebx, ebx
  00086	b8 ff ff ff ff	 mov	 eax, -1
  0008b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00090	0f 45 f8	 cmovne	 edi, eax
  00093	8b c7		 mov	 eax, edi
  00095	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 603  : }

  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5e		 pop	 rsi
  0009f	c3		 ret	 0
$LN6@gzclose_r:

; 589  :         return Z_STREAM_ERROR;

  000a0	b8 fe ff ff ff	 mov	 eax, -2

; 603  : }

  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5e		 pop	 rsi
  000aa	c3		 ret	 0
gzclose_r ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gz_load
_TEXT	SEGMENT
state$ = 48
buf$ = 56
len$ = 64
have$ = 72
gz_load	PROC						; COMDAT

; 13   :                   unsigned *have) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 14   :     int ret;
; 15   :     unsigned get, max = ((unsigned)-1 >> 2) + 1;
; 16   : 
; 17   :     *have = 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	49 8b d9	 mov	 rbx, r9
  0001f	41 89 01	 mov	 DWORD PTR [r9], eax
  00022	41 8b f8	 mov	 edi, r8d
  00025	48 8b ea	 mov	 rbp, rdx
  00028	48 8b f1	 mov	 rsi, rcx
  0002b	41 be 00 00 00
	40		 mov	 r14d, 1073741824	; 40000000H
$LL4@gz_load:

; 18   :     do {
; 19   :         get = len - *have;
; 20   :         if (get > max)
; 21   :             get = max;
; 22   :         ret = read(state->fd, buf + *have, get);

  00031	8b 4e 1c	 mov	 ecx, DWORD PTR [rsi+28]
  00034	44 8b c7	 mov	 r8d, edi
  00037	44 2b c0	 sub	 r8d, eax
  0003a	8b d0		 mov	 edx, eax
  0003c	45 3b c6	 cmp	 r8d, r14d
  0003f	45 0f 47 c6	 cmova	 r8d, r14d
  00043	48 03 d5	 add	 rdx, rbp
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  0004c	8b c8		 mov	 ecx, eax

; 23   :         if (ret <= 0)

  0004e	85 c0		 test	 eax, eax
  00050	7e 08		 jle	 SHORT $LN3@gz_load

; 24   :             break;
; 25   :         *have += (unsigned)ret;

  00052	01 03		 add	 DWORD PTR [rbx], eax
  00054	8b 03		 mov	 eax, DWORD PTR [rbx]

; 26   :     } while (*have < len);

  00056	3b c7		 cmp	 eax, edi
  00058	72 d7		 jb	 SHORT $LL4@gz_load
$LN3@gz_load:

; 27   :     if (ret < 0) {

  0005a	85 c9		 test	 ecx, ecx
  0005c	79 25		 jns	 SHORT $LN18@gz_load

; 28   :         gz_error(state, Z_ERRNO, zstrerror());

  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00064	8b 08		 mov	 ecx, DWORD PTR [rax]
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  0006c	ba ff ff ff ff	 mov	 edx, -1
  00071	48 8b ce	 mov	 rcx, rsi
  00074	4c 8b c0	 mov	 r8, rax
  00077	e8 00 00 00 00	 call	 gz_error

; 29   :         return -1;

  0007c	b8 ff ff ff ff	 mov	 eax, -1
  00081	eb 0b		 jmp	 SHORT $LN1@gz_load
$LN18@gz_load:

; 30   :     }
; 31   :     if (ret == 0)

  00083	75 07		 jne	 SHORT $LN8@gz_load

; 32   :         state->eof = 1;

  00085	c7 46 50 01 00
	00 00		 mov	 DWORD PTR [rsi+80], 1
$LN8@gz_load:

; 33   :     return 0;

  0008c	33 c0		 xor	 eax, eax
$LN1@gz_load:

; 34   : }

  0008e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00093	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00098	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a6	41 5e		 pop	 r14
  000a8	c3		 ret	 0
gz_load	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gz_avail
_TEXT	SEGMENT
state$ = 48
got$ = 48
gz_avail PROC						; COMDAT

; 43   : local int gz_avail(gz_statep state) {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 44   :     unsigned got;
; 45   :     z_streamp strm = &(state->strm);
; 46   : 
; 47   :     if (state->err != Z_OK && state->err != Z_BUF_ERROR)

  00006	8b 41 74	 mov	 eax, DWORD PTR [rcx+116]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	85 c0		 test	 eax, eax
  0000e	74 05		 je	 SHORT $LN5@gz_avail
  00010	83 f8 fb	 cmp	 eax, -5
  00013	75 53		 jne	 SHORT $LN16@gz_avail
$LN5@gz_avail:

; 48   :         return -1;
; 49   :     if (state->eof == 0) {

  00015	83 79 50 00	 cmp	 DWORD PTR [rcx+80], 0
  00019	75 6d		 jne	 SHORT $LN6@gz_avail

; 50   :         if (strm->avail_in) {       /* copy what's there to the start */

  0001b	44 8b 81 88 00
	00 00		 mov	 r8d, DWORD PTR [rcx+136]
  00022	45 85 c0	 test	 r8d, r8d
  00025	74 1e		 je	 SHORT $LN3@gz_avail

; 51   :             unsigned char *p = state->in;

  00027	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]

; 52   :             unsigned const char *q = strm->next_in;

  0002b	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
$LL4@gz_avail:

; 53   :             unsigned n = strm->avail_in;
; 54   :             do {
; 55   :                 *p++ = *q++;

  00032	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00035	48 8d 52 01	 lea	 rdx, QWORD PTR [rdx+1]
  00039	88 01		 mov	 BYTE PTR [rcx], al
  0003b	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]

; 56   :             } while (--n);

  0003f	41 83 c0 ff	 add	 r8d, -1			; ffffffffH
  00043	75 ed		 jne	 SHORT $LL4@gz_avail
$LN3@gz_avail:

; 57   :         }
; 58   :         if (gz_load(state, state->in + strm->avail_in,
; 59   :                     state->size - strm->avail_in, &got) == -1)

  00045	8b 93 88 00 00
	00		 mov	 edx, DWORD PTR [rbx+136]
  0004b	4c 8d 4c 24 30	 lea	 r9, QWORD PTR got$[rsp]
  00050	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00054	48 8b cb	 mov	 rcx, rbx
  00057	44 2b c2	 sub	 r8d, edx
  0005a	48 03 53 30	 add	 rdx, QWORD PTR [rbx+48]
  0005e	e8 00 00 00 00	 call	 gz_load
  00063	83 f8 ff	 cmp	 eax, -1
  00066	75 0b		 jne	 SHORT $LN8@gz_avail
$LN16@gz_avail:

; 60   :             return -1;

  00068	b8 ff ff ff ff	 mov	 eax, -1

; 65   : }

  0006d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00071	5b		 pop	 rbx
  00072	c3		 ret	 0
$LN8@gz_avail:

; 61   :         strm->avail_in += got;

  00073	8b 44 24 30	 mov	 eax, DWORD PTR got$[rsp]
  00077	01 83 88 00 00
	00		 add	 DWORD PTR [rbx+136], eax

; 62   :         strm->next_in = state->in;

  0007d	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00081	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax
$LN6@gz_avail:

; 63   :     }
; 64   :     return 0;

  00088	33 c0		 xor	 eax, eax

; 65   : }

  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5b		 pop	 rbx
  0008f	c3		 ret	 0
gz_avail ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gz_look
_TEXT	SEGMENT
state$ = 48
gz_look	PROC						; COMDAT

; 76   : local int gz_look(gz_statep state) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 77   :     z_streamp strm = &(state->strm);
; 78   : 
; 79   :     /* allocate read buffers and inflate memory */
; 80   :     if (state->size == 0) {

  00014	33 ed		 xor	 ebp, ebp
  00016	48 8d b9 80 00
	00 00		 lea	 rdi, QWORD PTR [rcx+128]
  0001d	48 8d 71 38	 lea	 rsi, QWORD PTR [rcx+56]
  00021	48 8b d9	 mov	 rbx, rcx
  00024	39 69 28	 cmp	 DWORD PTR [rcx+40], ebp
  00027	0f 85 ce 00 00
	00		 jne	 $LN12@gz_look

; 81   :         /* allocate buffers */
; 82   :         state->in = (unsigned char *)malloc(state->want);

  0002d	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00036	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax

; 83   :         state->out = (unsigned char *)malloc(state->want << 1);

  0003a	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  0003d	8d 0c 00	 lea	 ecx, DWORD PTR [rax+rax]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00046	48 89 06	 mov	 QWORD PTR [rsi], rax

; 84   :         if (state->in == NULL || state->out == NULL) {

  00049	48 39 6b 30	 cmp	 QWORD PTR [rbx+48], rbp
  0004d	74 7b		 je	 SHORT $LN4@gz_look
  0004f	48 85 c0	 test	 rax, rax
  00052	74 76		 je	 SHORT $LN4@gz_look

; 88   :             return -1;
; 89   :         }
; 90   :         state->size = state->want;

  00054	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]

; 91   : 
; 92   :         /* allocate inflate memory */
; 93   :         state->strm.zalloc = Z_NULL;
; 94   :         state->strm.zfree = Z_NULL;
; 95   :         state->strm.opaque = Z_NULL;
; 96   :         state->strm.avail_in = 0;
; 97   :         state->strm.next_in = Z_NULL;
; 98   :         if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */

  00057	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@CNPFHDLN@1?43?41?41?9motley@
  0005e	41 b9 58 00 00
	00		 mov	 r9d, 88			; 00000058H
  00064	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  00067	ba 1f 00 00 00	 mov	 edx, 31
  0006c	48 89 ab b0 00
	00 00		 mov	 QWORD PTR [rbx+176], rbp
  00073	48 8b cf	 mov	 rcx, rdi
  00076	48 89 ab b8 00
	00 00		 mov	 QWORD PTR [rbx+184], rbp
  0007d	48 89 ab c0 00
	00 00		 mov	 QWORD PTR [rbx+192], rbp
  00084	89 ab 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ebp
  0008a	48 89 2f	 mov	 QWORD PTR [rdi], rbp
  0008d	e8 00 00 00 00	 call	 inflateInit2_
  00092	85 c0		 test	 eax, eax
  00094	74 65		 je	 SHORT $LN12@gz_look

; 99   :             free(state->out);

  00096	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 100  :             free(state->in);

  0009f	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 101  :             state->size = 0;
; 102  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@
  000b0	89 6b 28	 mov	 DWORD PTR [rbx+40], ebp
  000b3	ba fc ff ff ff	 mov	 edx, -4
  000b8	48 8b cb	 mov	 rcx, rbx
  000bb	e8 00 00 00 00	 call	 gz_error

; 103  :             return -1;

  000c0	b8 ff ff ff ff	 mov	 eax, -1
  000c5	e9 b6 00 00 00	 jmp	 $LN1@gz_look
$LN4@gz_look:

; 85   :             free(state->out);

  000ca	48 8b c8	 mov	 rcx, rax
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 86   :             free(state->in);

  000d3	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 87   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@
  000e4	ba fc ff ff ff	 mov	 edx, -4
  000e9	48 8b cb	 mov	 rcx, rbx
  000ec	e8 00 00 00 00	 call	 gz_error
$LN26@gz_look:

; 148  :     return 0;
; 149  : }

  000f1	b8 ff ff ff ff	 mov	 eax, -1
  000f6	e9 85 00 00 00	 jmp	 $LN1@gz_look
$LN12@gz_look:

; 104  :         }
; 105  :     }
; 106  : 
; 107  :     /* get at least the magic bytes in the input buffer */
; 108  :     if (strm->avail_in < 2) {

  000fb	8b 47 08	 mov	 eax, DWORD PTR [rdi+8]
  000fe	83 f8 02	 cmp	 eax, 2
  00101	73 18		 jae	 SHORT $LN8@gz_look

; 109  :         if (gz_avail(state) == -1)

  00103	48 8b cb	 mov	 rcx, rbx
  00106	e8 00 00 00 00	 call	 gz_avail
  0010b	83 f8 ff	 cmp	 eax, -1
  0010e	74 e1		 je	 SHORT $LN26@gz_look

; 110  :             return -1;
; 111  :         if (strm->avail_in == 0)

  00110	8b 47 08	 mov	 eax, DWORD PTR [rdi+8]
  00113	85 c0		 test	 eax, eax
  00115	74 67		 je	 SHORT $LN25@gz_look
  00117	48 8d 73 38	 lea	 rsi, QWORD PTR [rbx+56]
$LN8@gz_look:

; 112  :             return 0;
; 113  :     }
; 114  : 
; 115  :     /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
; 116  :        a logical dilemma here when considering the case of a partially written
; 117  :        gzip file, to wit, if a single 31 byte is written, then we cannot tell
; 118  :        whether this is a single-byte file, or just a partially written gzip
; 119  :        file -- for here we assume that if a gzip file is being written, then
; 120  :        the header will be written in a single operation, so that reading a
; 121  :        single byte is sufficient indication that it is not a gzip file) */
; 122  :     if (strm->avail_in > 1 &&
; 123  :             strm->next_in[0] == 31 && strm->next_in[1] == 139) {

  0011b	83 f8 01	 cmp	 eax, 1
  0011e	76 22		 jbe	 SHORT $LN9@gz_look
  00120	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00123	80 38 1f	 cmp	 BYTE PTR [rax], 31
  00126	75 1a		 jne	 SHORT $LN9@gz_look
  00128	80 78 01 8b	 cmp	 BYTE PTR [rax+1], 139	; 0000008bH
  0012c	75 14		 jne	 SHORT $LN9@gz_look

; 124  :         inflateReset(strm);

  0012e	48 8b cf	 mov	 rcx, rdi
  00131	e8 00 00 00 00	 call	 inflateReset

; 125  :         state->how = GZIP;

  00136	c7 43 44 02 00
	00 00		 mov	 DWORD PTR [rbx+68], 2

; 126  :         state->direct = 0;

  0013d	89 6b 40	 mov	 DWORD PTR [rbx+64], ebp

; 127  :         return 0;

  00140	eb 3c		 jmp	 SHORT $LN25@gz_look
$LN9@gz_look:

; 128  :     }
; 129  : 
; 130  :     /* no gzip header -- if we were decoding gzip before, then this is trailing
; 131  :        garbage.  Ignore the trailing garbage and finish. */
; 132  :     if (state->direct == 0) {

  00142	39 6b 40	 cmp	 DWORD PTR [rbx+64], ebp
  00145	75 0e		 jne	 SHORT $LN10@gz_look

; 133  :         strm->avail_in = 0;

  00147	89 6f 08	 mov	 DWORD PTR [rdi+8], ebp

; 134  :         state->eof = 1;

  0014a	c7 43 50 01 00
	00 00		 mov	 DWORD PTR [rbx+80], 1

; 135  :         state->x.have = 0;

  00151	89 2b		 mov	 DWORD PTR [rbx], ebp

; 136  :         return 0;

  00153	eb 29		 jmp	 SHORT $LN25@gz_look
$LN10@gz_look:

; 137  :     }
; 138  : 
; 139  :     /* doing raw i/o, copy any leftover input to output -- this assumes that
; 140  :        the output buffer is larger than the input buffer, which also assures
; 141  :        space for gzungetc() */
; 142  :     state->x.next = state->out;

  00155	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00158	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx

; 143  :     memcpy(state->x.next, strm->next_in, strm->avail_in);

  0015c	44 8b 47 08	 mov	 r8d, DWORD PTR [rdi+8]
  00160	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00163	e8 00 00 00 00	 call	 memcpy

; 144  :     state->x.have = strm->avail_in;

  00168	8b 47 08	 mov	 eax, DWORD PTR [rdi+8]
  0016b	89 03		 mov	 DWORD PTR [rbx], eax

; 145  :     strm->avail_in = 0;

  0016d	89 6f 08	 mov	 DWORD PTR [rdi+8], ebp

; 146  :     state->how = COPY;

  00170	c7 43 44 01 00
	00 00		 mov	 DWORD PTR [rbx+68], 1

; 147  :     state->direct = 1;

  00177	c7 43 40 01 00
	00 00		 mov	 DWORD PTR [rbx+64], 1
$LN25@gz_look:

; 148  :     return 0;
; 149  : }

  0017e	33 c0		 xor	 eax, eax
$LN1@gz_look:
  00180	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00185	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0018a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0018f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00193	5f		 pop	 rdi
  00194	c3		 ret	 0
gz_look	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gz_decomp
_TEXT	SEGMENT
state$ = 48
gz_decomp PROC						; COMDAT

; 156  : local int gz_decomp(gz_statep state) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 157  :     int ret = Z_OK;
; 158  :     unsigned had;
; 159  :     z_streamp strm = &(state->strm);

  00014	48 8d 99 80 00
	00 00		 lea	 rbx, QWORD PTR [rcx+128]
  0001b	48 8b f1	 mov	 rsi, rcx

; 160  : 
; 161  :     /* fill output buffer up to end of deflate stream */
; 162  :     had = strm->avail_out;

  0001e	8b 6b 18	 mov	 ebp, DWORD PTR [rbx+24]
  00021	33 ff		 xor	 edi, edi
$LL4@gz_decomp:

; 163  :     do {
; 164  :         /* get more input for inflate() */
; 165  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00023	83 7b 08 00	 cmp	 DWORD PTR [rbx+8], 0
  00027	75 17		 jne	 SHORT $LN34@gz_decomp
  00029	48 8b ce	 mov	 rcx, rsi
  0002c	e8 00 00 00 00	 call	 gz_avail
  00031	83 f8 ff	 cmp	 eax, -1
  00034	74 72		 je	 SHORT $LN17@gz_decomp

; 166  :             return -1;
; 167  :         if (strm->avail_in == 0) {

  00036	83 7b 08 00	 cmp	 DWORD PTR [rbx+8], 0
  0003a	0f 84 8a 00 00
	00		 je	 $LN18@gz_decomp
$LN34@gz_decomp:

; 169  :             break;
; 170  :         }
; 171  : 
; 172  :         /* decompress and handle errors */
; 173  :         ret = inflate(strm, Z_NO_FLUSH);

  00040	33 d2		 xor	 edx, edx
  00042	48 8b cb	 mov	 rcx, rbx
  00045	e8 00 00 00 00	 call	 inflate
  0004a	8b f8		 mov	 edi, eax

; 174  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  0004c	8d 48 02	 lea	 ecx, DWORD PTR [rax+2]
  0004f	f7 c1 fb ff ff
	ff		 test	 ecx, -5			; fffffffbH
  00055	74 58		 je	 SHORT $LN19@gz_decomp

; 178  :         }
; 179  :         if (ret == Z_MEM_ERROR) {

  00057	83 f8 fc	 cmp	 eax, -4
  0005a	74 38		 je	 SHORT $LN20@gz_decomp

; 181  :             return -1;
; 182  :         }
; 183  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  0005c	83 f8 fd	 cmp	 eax, -3
  0005f	74 0d		 je	 SHORT $LN21@gz_decomp

; 187  :         }
; 188  :     } while (strm->avail_out && ret != Z_STREAM_END);

  00061	83 7b 18 00	 cmp	 DWORD PTR [rbx+24], 0
  00065	74 77		 je	 SHORT $LN3@gz_decomp
  00067	83 f8 01	 cmp	 eax, 1
  0006a	75 b7		 jne	 SHORT $LL4@gz_decomp
  0006c	eb 70		 jmp	 SHORT $LN3@gz_decomp
$LN21@gz_decomp:

; 184  :             gz_error(state, Z_DATA_ERROR,

  0006e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00072	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@HCKBMIHF@compressed?5data?5error@
  00079	48 85 c0	 test	 rax, rax
  0007c	ba fd ff ff ff	 mov	 edx, -3
  00081	48 8b ce	 mov	 rcx, rsi
  00084	4c 0f 45 c0	 cmovne	 r8, rax
  00088	e8 00 00 00 00	 call	 gz_error

; 185  :                      strm->msg == NULL ? "compressed data error" : strm->msg);
; 186  :             return -1;

  0008d	b8 ff ff ff ff	 mov	 eax, -1
  00092	eb 6a		 jmp	 SHORT $LN1@gz_decomp
$LN20@gz_decomp:

; 180  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  00094	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@
  0009b	ba fc ff ff ff	 mov	 edx, -4
  000a0	48 8b ce	 mov	 rcx, rsi
  000a3	e8 00 00 00 00	 call	 gz_error
$LN17@gz_decomp:

; 200  : }

  000a8	b8 ff ff ff ff	 mov	 eax, -1
  000ad	eb 4f		 jmp	 SHORT $LN1@gz_decomp
$LN19@gz_decomp:

; 175  :             gz_error(state, Z_STREAM_ERROR,

  000af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5@
  000b6	ba fe ff ff ff	 mov	 edx, -2
  000bb	48 8b ce	 mov	 rcx, rsi
  000be	e8 00 00 00 00	 call	 gz_error

; 176  :                      "internal error: inflate stream corrupt");
; 177  :             return -1;

  000c3	b8 ff ff ff ff	 mov	 eax, -1
  000c8	eb 34		 jmp	 SHORT $LN1@gz_decomp
$LN18@gz_decomp:

; 168  :             gz_error(state, Z_BUF_ERROR, "unexpected end of file");

  000ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file@
  000d1	ba fb ff ff ff	 mov	 edx, -5
  000d6	48 8b ce	 mov	 rcx, rsi
  000d9	e8 00 00 00 00	 call	 gz_error
$LN3@gz_decomp:

; 189  : 
; 190  :     /* update available output */
; 191  :     state->x.have = had - strm->avail_out;

  000de	2b 6b 18	 sub	 ebp, DWORD PTR [rbx+24]
  000e1	8b cd		 mov	 ecx, ebp
  000e3	89 0e		 mov	 DWORD PTR [rsi], ecx

; 192  :     state->x.next = strm->next_out - state->x.have;

  000e5	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000e9	48 2b c1	 sub	 rax, rcx
  000ec	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 193  : 
; 194  :     /* if the gzip stream completed successfully, look for another */
; 195  :     if (ret == Z_STREAM_END)

  000f0	83 ff 01	 cmp	 edi, 1
  000f3	75 07		 jne	 SHORT $LN12@gz_decomp

; 196  :         state->how = LOOK;

  000f5	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [rsi+68], 0
$LN12@gz_decomp:

; 197  : 
; 198  :     /* good decompression */
; 199  :     return 0;

  000fc	33 c0		 xor	 eax, eax
$LN1@gz_decomp:

; 200  : }

  000fe	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00103	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00108	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0010d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
gz_decomp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gz_fetch
_TEXT	SEGMENT
state$ = 48
gz_fetch PROC						; COMDAT

; 208  : local int gz_fetch(gz_statep state) {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@gz_fetch:

; 209  :     z_streamp strm = &(state->strm);
; 210  : 
; 211  :     do {
; 212  :         switch(state->how) {

  00010	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  00013	85 c9		 test	 ecx, ecx
  00015	74 38		 je	 SHORT $LN7@gz_fetch
  00017	83 e9 01	 sub	 ecx, 1
  0001a	74 62		 je	 SHORT $LN10@gz_fetch
  0001c	83 f9 01	 cmp	 ecx, 1
  0001f	75 41		 jne	 SHORT $LN2@gz_fetch

; 224  :             return 0;
; 225  :         case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
; 226  :             strm->avail_out = state->size << 1;

  00021	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 227  :             strm->next_out = state->out;
; 228  :             if (gz_decomp(state) == -1)

  00024	48 8b cb	 mov	 rcx, rbx
  00027	03 c0		 add	 eax, eax
  00029	89 83 98 00 00
	00		 mov	 DWORD PTR [rbx+152], eax
  0002f	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00033	48 89 83 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rax
  0003a	e8 00 00 00 00	 call	 gz_decomp
  0003f	83 f8 ff	 cmp	 eax, -1
  00042	75 1e		 jne	 SHORT $LN2@gz_fetch
$LN19@gz_fetch:

; 215  :                 return -1;

  00044	b8 ff ff ff ff	 mov	 eax, -1

; 232  :     return 0;
; 233  : }

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
$LN7@gz_fetch:

; 213  :         case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
; 214  :             if (gz_look(state) == -1)

  0004f	48 8b cb	 mov	 rcx, rbx
  00052	e8 00 00 00 00	 call	 gz_look
  00057	83 f8 ff	 cmp	 eax, -1
  0005a	74 e8		 je	 SHORT $LN19@gz_fetch

; 216  :             if (state->how == LOOK)

  0005c	83 7b 44 00	 cmp	 DWORD PTR [rbx+68], 0
  00060	74 3f		 je	 SHORT $LN20@gz_fetch
$LN2@gz_fetch:

; 229  :                 return -1;
; 230  :         }
; 231  :     } while (state->x.have == 0 && (!state->eof || strm->avail_in));

  00062	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  00065	75 3a		 jne	 SHORT $LN20@gz_fetch
  00067	83 7b 50 00	 cmp	 DWORD PTR [rbx+80], 0
  0006b	74 a3		 je	 SHORT $LL4@gz_fetch
  0006d	83 bb 88 00 00
	00 00		 cmp	 DWORD PTR [rbx+136], 0
  00074	75 9a		 jne	 SHORT $LL4@gz_fetch

; 232  :     return 0;
; 233  : }

  00076	33 c0		 xor	 eax, eax
  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5b		 pop	 rbx
  0007d	c3		 ret	 0
$LN10@gz_fetch:

; 217  :                 return 0;
; 218  :             break;
; 219  :         case COPY:      /* -> COPY */
; 220  :             if (gz_load(state, state->out, state->size << 1, &(state->x.have))
; 221  :                     == -1)

  0007e	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00082	4c 8b cb	 mov	 r9, rbx
  00085	48 8b 53 38	 mov	 rdx, QWORD PTR [rbx+56]
  00089	45 03 c0	 add	 r8d, r8d
  0008c	48 8b cb	 mov	 rcx, rbx
  0008f	e8 00 00 00 00	 call	 gz_load
  00094	83 f8 ff	 cmp	 eax, -1
  00097	74 ab		 je	 SHORT $LN19@gz_fetch

; 222  :                 return -1;
; 223  :             state->x.next = state->out;

  00099	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0009d	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
$LN20@gz_fetch:

; 232  :     return 0;
; 233  : }

  000a1	33 c0		 xor	 eax, eax
  000a3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a7	5b		 pop	 rbx
  000a8	c3		 ret	 0
gz_fetch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gz_skip
_TEXT	SEGMENT
state$ = 48
len$ = 56
gz_skip	PROC						; COMDAT

; 236  : local int gz_skip(gz_statep state, z_off64_t len) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 237  :     unsigned n;
; 238  : 
; 239  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 240  :     while (len)

  00010	48 85 d2	 test	 rdx, rdx
  00013	74 47		 je	 SHORT $LN3@gz_skip
$LL2@gz_skip:

; 241  :         /* skip over whatever is in output buffer */
; 242  :         if (state->x.have) {

  00015	44 8b 03	 mov	 r8d, DWORD PTR [rbx]
  00018	45 85 c0	 test	 r8d, r8d
  0001b	74 1e		 je	 SHORT $LN4@gz_skip

; 243  :             n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
; 244  :                 (unsigned)len : state->x.have;
; 245  :             state->x.have -= n;

  0001d	4c 3b c7	 cmp	 r8, rdi
  00020	41 8b c8	 mov	 ecx, r8d
  00023	0f 4f cf	 cmovg	 ecx, edi
  00026	8b c1		 mov	 eax, ecx
  00028	44 2b c1	 sub	 r8d, ecx

; 246  :             state->x.next += n;

  0002b	48 01 43 08	 add	 QWORD PTR [rbx+8], rax

; 247  :             state->x.pos += n;

  0002f	48 01 43 10	 add	 QWORD PTR [rbx+16], rax

; 248  :             len -= n;

  00033	48 2b f8	 sub	 rdi, rax
  00036	44 89 03	 mov	 DWORD PTR [rbx], r8d

; 249  :         }

  00039	eb 1c		 jmp	 SHORT $LN8@gz_skip
$LN4@gz_skip:

; 250  : 
; 251  :         /* output buffer empty -- return if we're at the end of the input */
; 252  :         else if (state->eof && state->strm.avail_in == 0)

  0003b	83 7b 50 00	 cmp	 DWORD PTR [rbx+80], 0
  0003f	74 09		 je	 SHORT $LN6@gz_skip
  00041	83 bb 88 00 00
	00 00		 cmp	 DWORD PTR [rbx+136], 0
  00048	74 12		 je	 SHORT $LN3@gz_skip
$LN6@gz_skip:

; 253  :             break;
; 254  : 
; 255  :         /* need more data to skip -- load up output buffer */
; 256  :         else {
; 257  :             /* get more output, looking for header if required */
; 258  :             if (gz_fetch(state) == -1)

  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	e8 00 00 00 00	 call	 gz_fetch
  00052	83 f8 ff	 cmp	 eax, -1
  00055	74 12		 je	 SHORT $LN14@gz_skip
$LN8@gz_skip:

; 237  :     unsigned n;
; 238  : 
; 239  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 240  :     while (len)

  00057	48 85 ff	 test	 rdi, rdi
  0005a	75 b9		 jne	 SHORT $LL2@gz_skip
$LN3@gz_skip:

; 259  :                 return -1;
; 260  :         }
; 261  :     return 0;

  0005c	33 c0		 xor	 eax, eax

; 262  : }

  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN14@gz_skip:
  00069	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006e	b8 ff ff ff ff	 mov	 eax, -1
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
gz_skip	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gz_read
_TEXT	SEGMENT
state$ = 80
buf$ = 88
len$ = 96
n$ = 96
gz_read	PROC						; COMDAT

; 268  : local z_size_t gz_read(gz_statep state, voidp buf, z_size_t len) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001c	4d 8b f0	 mov	 r14, r8
  0001f	4c 8b fa	 mov	 r15, rdx
  00022	48 8b d9	 mov	 rbx, rcx

; 269  :     z_size_t got;
; 270  :     unsigned n;
; 271  : 
; 272  :     /* if len is zero, avoid unnecessary operations */
; 273  :     if (len == 0)

  00025	4d 85 c0	 test	 r8, r8
  00028	0f 84 0d 01 00
	00		 je	 $LN27@gz_read

; 274  :         return 0;
; 275  : 
; 276  :     /* process a skip request */
; 277  :     if (state->seek) {

  0002e	83 79 70 00	 cmp	 DWORD PTR [rcx+112], 0
  00032	74 19		 je	 SHORT $LN7@gz_read

; 278  :         state->seek = 0;
; 279  :         if (gz_skip(state, state->skip) == -1)

  00034	48 8b 51 68	 mov	 rdx, QWORD PTR [rcx+104]
  00038	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [rcx+112], 0
  0003f	e8 00 00 00 00	 call	 gz_skip
  00044	83 f8 ff	 cmp	 eax, -1
  00047	0f 84 ee 00 00
	00		 je	 $LN27@gz_read
$LN7@gz_read:

; 280  :             return 0;
; 281  :     }
; 282  : 
; 283  :     /* get len bytes to buf, or less than len if at the end */
; 284  :     got = 0;

  0004d	45 33 e4	 xor	 r12d, r12d
  00050	41 bd ff ff ff
	ff		 mov	 r13d, -1		; ffffffffH
  00056	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@gz_read:

; 285  :     do {
; 286  :         /* set n to the maximum amount of len that fits in an unsigned int */
; 287  :         n = (unsigned)-1;

  00060	44 89 6c 24 60	 mov	 DWORD PTR n$[rsp], r13d
  00065	41 8b f5	 mov	 esi, r13d

; 288  :         if (n > len)

  00068	41 8b ed	 mov	 ebp, r13d
  0006b	4d 3b f5	 cmp	 r14, r13
  0006e	73 0b		 jae	 SHORT $LN8@gz_read

; 289  :             n = (unsigned)len;

  00070	41 8b f6	 mov	 esi, r14d
  00073	44 89 74 24 60	 mov	 DWORD PTR n$[rsp], r14d
  00078	41 8b ee	 mov	 ebp, r14d
$LN8@gz_read:

; 290  : 
; 291  :         /* first just try copying data from the output buffer */
; 292  :         if (state->x.have) {

  0007b	8b 03		 mov	 eax, DWORD PTR [rbx]
  0007d	85 c0		 test	 eax, eax
  0007f	74 21		 je	 SHORT $LN9@gz_read

; 293  :             if (state->x.have < n)

  00081	3b c5		 cmp	 eax, ebp
  00083	73 04		 jae	 SHORT $LN11@gz_read

; 294  :                 n = state->x.have;

  00085	8b f0		 mov	 esi, eax
  00087	8b e8		 mov	 ebp, eax
$LN11@gz_read:

; 295  :             memcpy(buf, state->x.next, n);

  00089	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  0008d	49 8b cf	 mov	 rcx, r15
  00090	44 8b c5	 mov	 r8d, ebp
  00093	8b fd		 mov	 edi, ebp
  00095	e8 00 00 00 00	 call	 memcpy

; 296  :             state->x.next += n;

  0009a	48 01 7b 08	 add	 QWORD PTR [rbx+8], rdi

; 297  :             state->x.have -= n;

  0009e	29 2b		 sub	 DWORD PTR [rbx], ebp

; 298  :         }

  000a0	eb 61		 jmp	 SHORT $LN19@gz_read
$LN9@gz_read:

; 299  : 
; 300  :         /* output buffer empty -- return if we're at the end of the input */
; 301  :         else if (state->eof && state->strm.avail_in == 0) {

  000a2	83 7b 50 00	 cmp	 DWORD PTR [rbx+80], 0
  000a6	74 09		 je	 SHORT $LN12@gz_read
  000a8	83 bb 88 00 00
	00 00		 cmp	 DWORD PTR [rbx+136], 0
  000af	74 7e		 je	 SHORT $LN24@gz_read
$LN12@gz_read:

; 303  :             break;
; 304  :         }
; 305  : 
; 306  :         /* need output data -- for small len or new stream load up our output
; 307  :            buffer */
; 308  :         else if (state->how == LOOK || n < (state->size << 1)) {

  000b1	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  000b4	85 c9		 test	 ecx, ecx
  000b6	74 5c		 je	 SHORT $LN16@gz_read
  000b8	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  000bb	03 c0		 add	 eax, eax
  000bd	3b e8		 cmp	 ebp, eax
  000bf	72 53		 jb	 SHORT $LN16@gz_read

; 312  :             continue;       /* no progress yet -- go back to copy above */
; 313  :             /* the copy above assures that we will leave with space in the
; 314  :                output buffer, allowing at least one gzungetc() to succeed */
; 315  :         }
; 316  : 
; 317  :         /* large len -- read directly into user buffer */
; 318  :         else if (state->how == COPY) {      /* read directly */

  000c1	83 f9 01	 cmp	 ecx, 1
  000c4	48 8b cb	 mov	 rcx, rbx
  000c7	75 1b		 jne	 SHORT $LN18@gz_read

; 319  :             if (gz_load(state, (unsigned char *)buf, n, &n) == -1)

  000c9	4c 8d 4c 24 60	 lea	 r9, QWORD PTR n$[rsp]
  000ce	44 8b c6	 mov	 r8d, esi
  000d1	49 8b d7	 mov	 rdx, r15
  000d4	e8 00 00 00 00	 call	 gz_load
  000d9	83 f8 ff	 cmp	 eax, -1
  000dc	74 5d		 je	 SHORT $LN27@gz_read

; 320  :                 return 0;
; 321  :         }

  000de	8b 74 24 60	 mov	 esi, DWORD PTR n$[rsp]
  000e2	eb 1f		 jmp	 SHORT $LN19@gz_read
$LN18@gz_read:

; 322  : 
; 323  :         /* large len -- decompress directly into user buffer */
; 324  :         else {  /* state->how == GZIP */
; 325  :             state->strm.avail_out = n;

  000e4	89 b3 98 00 00
	00		 mov	 DWORD PTR [rbx+152], esi

; 326  :             state->strm.next_out = (unsigned char *)buf;

  000ea	4c 89 bb 90 00
	00 00		 mov	 QWORD PTR [rbx+144], r15

; 327  :             if (gz_decomp(state) == -1)

  000f1	e8 00 00 00 00	 call	 gz_decomp
  000f6	83 f8 ff	 cmp	 eax, -1
  000f9	74 40		 je	 SHORT $LN27@gz_read

; 328  :                 return 0;
; 329  :             n = state->x.have;

  000fb	8b 33		 mov	 esi, DWORD PTR [rbx]

; 330  :             state->x.have = 0;

  000fd	c7 03 00 00 00
	00		 mov	 DWORD PTR [rbx], 0
$LN19@gz_read:

; 331  :         }
; 332  : 
; 333  :         /* update progress */
; 334  :         len -= n;

  00103	8b c6		 mov	 eax, esi
  00105	4c 2b f0	 sub	 r14, rax

; 335  :         buf = (char *)buf + n;

  00108	4c 03 f8	 add	 r15, rax

; 336  :         got += n;

  0010b	4c 03 e0	 add	 r12, rax

; 337  :         state->x.pos += n;

  0010e	48 01 43 10	 add	 QWORD PTR [rbx+16], rax
  00112	eb 0d		 jmp	 SHORT $LN2@gz_read
$LN16@gz_read:

; 309  :             /* get more output, looking for header if required */
; 310  :             if (gz_fetch(state) == -1)

  00114	48 8b cb	 mov	 rcx, rbx
  00117	e8 00 00 00 00	 call	 gz_fetch
  0011c	83 f8 ff	 cmp	 eax, -1
  0011f	74 1a		 je	 SHORT $LN27@gz_read
$LN2@gz_read:

; 338  :     } while (len);

  00121	4d 85 f6	 test	 r14, r14
  00124	0f 85 36 ff ff
	ff		 jne	 $LL4@gz_read

; 339  : 
; 340  :     /* return number of bytes read into user buffer */
; 341  :     return got;

  0012a	49 8b c4	 mov	 rax, r12
  0012d	eb 0e		 jmp	 SHORT $LN1@gz_read
$LN24@gz_read:

; 302  :             state->past = 1;        /* tried to read past end */

  0012f	c7 43 54 01 00
	00 00		 mov	 DWORD PTR [rbx+84], 1

; 339  : 
; 340  :     /* return number of bytes read into user buffer */
; 341  :     return got;

  00136	49 8b c4	 mov	 rax, r12
  00139	eb 02		 jmp	 SHORT $LN1@gz_read
$LN27@gz_read:

; 311  :                 return 0;

  0013b	33 c0		 xor	 eax, eax
$LN1@gz_read:

; 342  : }

  0013d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00142	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00147	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0014c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00150	41 5f		 pop	 r15
  00152	41 5e		 pop	 r14
  00154	41 5d		 pop	 r13
  00156	41 5c		 pop	 r12
  00158	5f		 pop	 rdi
  00159	c3		 ret	 0
gz_read	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gzread
_TEXT	SEGMENT
file$ = 48
buf$ = 56
len$ = 64
gzread	PROC						; COMDAT

; 345  : int ZEXPORT gzread(gzFile file, voidp buf, unsigned len) {

$LN17:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 346  :     gz_statep state;
; 347  : 
; 348  :     /* get internal structure */
; 349  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 4e		 je	 SHORT $LN4@gzread

; 350  :         return -1;
; 351  :     state = (gz_statep)file;
; 352  : 
; 353  :     /* check that we're reading and that there's no (serious) error */
; 354  :     if (state->mode != GZ_READ ||

  0000e	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00015	75 45		 jne	 SHORT $LN4@gzread
  00017	8b 41 74	 mov	 eax, DWORD PTR [rcx+116]
  0001a	85 c0		 test	 eax, eax
  0001c	74 05		 je	 SHORT $LN3@gzread
  0001e	83 f8 fb	 cmp	 eax, -5
  00021	75 39		 jne	 SHORT $LN4@gzread
$LN3@gzread:

; 355  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 356  :         return -1;
; 357  : 
; 358  :     /* since an int is returned, make sure len fits in one, otherwise return
; 359  :        with an error (this avoids a flaw in the interface) */
; 360  :     if ((int)len < 0) {

  00023	45 85 c0	 test	 r8d, r8d
  00026	79 1c		 jns	 SHORT $LN5@gzread

; 361  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in an int");

  00028	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@HLDABFKK@request?5does?5not?5fit?5in?5an?5int@
  0002f	ba fe ff ff ff	 mov	 edx, -2
  00034	e8 00 00 00 00	 call	 gz_error

; 370  :         return -1;
; 371  : 
; 372  :     /* return the number of bytes read (this is assured to fit in an int) */
; 373  :     return (int)len;
; 374  : }

  00039	b8 ff ff ff ff	 mov	 eax, -1
  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
$LN5@gzread:

; 362  :         return -1;
; 363  :     }
; 364  : 
; 365  :     /* read len or fewer bytes to buf */
; 366  :     len = (unsigned)gz_read(state, buf, len);

  00044	45 8b c0	 mov	 r8d, r8d
  00047	e8 00 00 00 00	 call	 gz_read

; 367  : 
; 368  :     /* check for an error */
; 369  :     if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)

  0004c	85 c0		 test	 eax, eax
  0004e	75 11		 jne	 SHORT $LN1@gzread
  00050	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  00053	85 c9		 test	 ecx, ecx
  00055	74 0a		 je	 SHORT $LN1@gzread
  00057	83 f9 fb	 cmp	 ecx, -5
  0005a	74 05		 je	 SHORT $LN1@gzread
$LN4@gzread:

; 370  :         return -1;
; 371  : 
; 372  :     /* return the number of bytes read (this is assured to fit in an int) */
; 373  :     return (int)len;
; 374  : }

  0005c	b8 ff ff ff ff	 mov	 eax, -1
$LN1@gzread:
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5b		 pop	 rbx
  00066	c3		 ret	 0
gzread	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gzfread
_TEXT	SEGMENT
buf$ = 48
size$ = 56
nitems$ = 64
file$ = 72
gzfread	PROC						; COMDAT

; 378  :                          gzFile file) {

$LN17:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4d 8b d0	 mov	 r10, r8
  00009	48 8b da	 mov	 rbx, rdx

; 379  :     z_size_t len;
; 380  :     gz_statep state;
; 381  : 
; 382  :     /* get internal structure */
; 383  :     if (file == NULL)

  0000c	4d 85 c9	 test	 r9, r9
  0000f	74 44		 je	 SHORT $LN4@gzfread

; 384  :         return 0;
; 385  :     state = (gz_statep)file;
; 386  : 
; 387  :     /* check that we're reading and that there's no (serious) error */
; 388  :     if (state->mode != GZ_READ ||

  00011	41 81 79 18 4f
	1c 00 00	 cmp	 DWORD PTR [r9+24], 7247	; 00001c4fH
  00019	75 3a		 jne	 SHORT $LN4@gzfread
  0001b	41 8b 41 74	 mov	 eax, DWORD PTR [r9+116]
  0001f	85 c0		 test	 eax, eax
  00021	74 05		 je	 SHORT $LN3@gzfread
  00023	83 f8 fb	 cmp	 eax, -5
  00026	75 2d		 jne	 SHORT $LN4@gzfread
$LN3@gzfread:

; 389  :             (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 390  :         return 0;
; 391  : 
; 392  :     /* compute bytes to read -- error on overflow */
; 393  :     len = nitems * size;

  00028	4c 8b c3	 mov	 r8, rbx
  0002b	4d 0f af c2	 imul	 r8, r10

; 394  :     if (size && len / size != nitems) {

  0002f	48 85 db	 test	 rbx, rbx
  00032	74 29		 je	 SHORT $LN5@gzfread
  00034	33 d2		 xor	 edx, edx
  00036	49 8b c0	 mov	 rax, r8
  00039	48 f7 f3	 div	 rbx
  0003c	49 3b c2	 cmp	 rax, r10
  0003f	74 1c		 je	 SHORT $LN5@gzfread

; 395  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");

  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@
  00048	ba fe ff ff ff	 mov	 edx, -2
  0004d	49 8b c9	 mov	 rcx, r9
  00050	e8 00 00 00 00	 call	 gz_error
$LN4@gzfread:

; 401  : }

  00055	33 c0		 xor	 eax, eax
  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5b		 pop	 rbx
  0005c	c3		 ret	 0
$LN5@gzfread:

; 396  :         return 0;
; 397  :     }
; 398  : 
; 399  :     /* read len or fewer bytes to buf, return the number of full items read */
; 400  :     return len ? gz_read(state, buf, len) / size : 0;

  0005d	4d 85 c0	 test	 r8, r8
  00060	74 f3		 je	 SHORT $LN4@gzfread
  00062	48 8b d1	 mov	 rdx, rcx
  00065	49 8b c9	 mov	 rcx, r9
  00068	e8 00 00 00 00	 call	 gz_read
  0006d	33 d2		 xor	 edx, edx
  0006f	48 f7 f3	 div	 rbx

; 401  : }

  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	5b		 pop	 rbx
  00077	c3		 ret	 0
gzfread	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gzgetc
_TEXT	SEGMENT
file$ = 48
buf$ = 48
gzgetc	PROC						; COMDAT

; 409  : int ZEXPORT gzgetc(gzFile file) {

$LN11:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c9	 mov	 r9, rcx

; 410  :     unsigned char buf[1];
; 411  :     gz_statep state;
; 412  : 
; 413  :     /* get internal structure */
; 414  :     if (file == NULL)

  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 5d		 je	 SHORT $LN4@gzgetc

; 415  :         return -1;
; 416  :     state = (gz_statep)file;
; 417  : 
; 418  :     /* check that we're reading and that there's no (serious) error */
; 419  :     if (state->mode != GZ_READ ||

  0000c	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00013	75 54		 jne	 SHORT $LN4@gzgetc
  00015	8b 41 74	 mov	 eax, DWORD PTR [rcx+116]
  00018	85 c0		 test	 eax, eax
  0001a	74 05		 je	 SHORT $LN3@gzgetc
  0001c	83 f8 fb	 cmp	 eax, -5
  0001f	75 48		 jne	 SHORT $LN4@gzgetc
$LN3@gzgetc:

; 422  : 
; 423  :     /* try output buffer (no need to check for skip request) */
; 424  :     if (state->x.have) {

  00021	8b 01		 mov	 eax, DWORD PTR [rcx]
  00023	85 c0		 test	 eax, eax
  00025	74 1d		 je	 SHORT $LN5@gzgetc

; 425  :         state->x.have--;
; 426  :         state->x.pos++;

  00027	48 ff 41 10	 inc	 QWORD PTR [rcx+16]
  0002b	ff c8		 dec	 eax
  0002d	89 01		 mov	 DWORD PTR [rcx], eax

; 427  :         return *(state->x.next)++;

  0002f	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00033	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00036	48 ff c0	 inc	 rax
  00039	49 89 41 08	 mov	 QWORD PTR [r9+8], rax
  0003d	8b c1		 mov	 eax, ecx

; 432  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
$LN5@gzgetc:

; 428  :     }
; 429  : 
; 430  :     /* nothing there -- try gz_read() */
; 431  :     return gz_read(state, buf, 1) < 1 ? -1 : buf[0];

  00044	41 b8 01 00 00
	00		 mov	 r8d, 1
  0004a	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  0004f	e8 00 00 00 00	 call	 gz_read
  00054	48 83 f8 01	 cmp	 rax, 1
  00058	b8 ff ff ff ff	 mov	 eax, -1
  0005d	72 0f		 jb	 SHORT $LN1@gzgetc
  0005f	0f b6 44 24 30	 movzx	 eax, BYTE PTR buf$[rsp]

; 432  : }

  00064	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00068	c3		 ret	 0
$LN4@gzgetc:

; 420  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 421  :         return -1;

  00069	b8 ff ff ff ff	 mov	 eax, -1
$LN1@gzgetc:

; 432  : }

  0006e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00072	c3		 ret	 0
gzgetc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gzgetc_
_TEXT	SEGMENT
file$ = 8
gzgetc_	PROC						; COMDAT

; 435  :     return gzgetc(file);

  00000	e9 00 00 00 00	 jmp	 gzgetc
gzgetc_	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gzungetc
_TEXT	SEGMENT
c$ = 48
file$ = 56
gzungetc PROC						; COMDAT

; 439  : int ZEXPORT gzungetc(int c, gzFile file) {

$LN37:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	8b f9		 mov	 edi, ecx

; 440  :     gz_statep state;
; 441  : 
; 442  :     /* get internal structure */
; 443  :     if (file == NULL)

  0000f	48 85 d2	 test	 rdx, rdx
  00012	0f 84 af 00 00
	00		 je	 $LN7@gzungetc

; 444  :         return -1;
; 445  :     state = (gz_statep)file;
; 446  : 
; 447  :     /* in case this was just opened, set up the input buffer */
; 448  :     if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)

  00018	81 7a 18 4f 1c
	00 00		 cmp	 DWORD PTR [rdx+24], 7247 ; 00001c4fH
  0001f	75 13		 jne	 SHORT $LN5@gzungetc
  00021	83 7a 44 00	 cmp	 DWORD PTR [rdx+68], 0
  00025	75 0d		 jne	 SHORT $LN5@gzungetc
  00027	83 3a 00	 cmp	 DWORD PTR [rdx], 0
  0002a	75 08		 jne	 SHORT $LN5@gzungetc

; 449  :         (void)gz_look(state);

  0002c	48 8b ca	 mov	 rcx, rdx
  0002f	e8 00 00 00 00	 call	 gz_look
$LN5@gzungetc:

; 450  : 
; 451  :     /* check that we're reading and that there's no (serious) error */
; 452  :     if (state->mode != GZ_READ ||

  00034	81 7b 18 4f 1c
	00 00		 cmp	 DWORD PTR [rbx+24], 7247 ; 00001c4fH
  0003b	0f 85 86 00 00
	00		 jne	 $LN7@gzungetc
  00041	8b 43 74	 mov	 eax, DWORD PTR [rbx+116]
  00044	85 c0		 test	 eax, eax
  00046	74 05		 je	 SHORT $LN6@gzungetc
  00048	83 f8 fb	 cmp	 eax, -5
  0004b	75 7a		 jne	 SHORT $LN7@gzungetc
$LN6@gzungetc:

; 453  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 454  :         return -1;
; 455  : 
; 456  :     /* process a skip request */
; 457  :     if (state->seek) {

  0004d	83 7b 70 00	 cmp	 DWORD PTR [rbx+112], 0
  00051	74 18		 je	 SHORT $LN9@gzungetc

; 458  :         state->seek = 0;
; 459  :         if (gz_skip(state, state->skip) == -1)

  00053	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  00057	48 8b cb	 mov	 rcx, rbx
  0005a	c7 43 70 00 00
	00 00		 mov	 DWORD PTR [rbx+112], 0
  00061	e8 00 00 00 00	 call	 gz_skip
  00066	83 f8 ff	 cmp	 eax, -1
  00069	74 5c		 je	 SHORT $LN7@gzungetc
$LN9@gzungetc:

; 460  :             return -1;
; 461  :     }
; 462  : 
; 463  :     /* can't push EOF */
; 464  :     if (c < 0)

  0006b	85 ff		 test	 edi, edi
  0006d	78 58		 js	 SHORT $LN7@gzungetc

; 465  :         return -1;
; 466  : 
; 467  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 468  :     if (state->x.have == 0) {

  0006f	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  00073	8b 03		 mov	 eax, DWORD PTR [rbx]
  00075	45 03 c0	 add	 r8d, r8d
  00078	85 c0		 test	 eax, eax
  0007a	75 32		 jne	 SHORT $LN11@gzungetc

; 469  :         state->x.have = 1;
; 470  :         state->x.next = state->out + (state->size << 1) - 1;

  0007c	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00080	48 ff c8	 dec	 rax
  00083	41 8b d0	 mov	 edx, r8d
  00086	48 03 d0	 add	 rdx, rax
  00089	c7 03 01 00 00
	00		 mov	 DWORD PTR [rbx], 1
  0008f	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx

; 471  :         state->x.next[0] = (unsigned char)c;
; 472  :         state->x.pos--;
; 473  :         state->past = 0;
; 474  :         return c;

  00093	8b c7		 mov	 eax, edi
  00095	40 88 3a	 mov	 BYTE PTR [rdx], dil
  00098	48 ff 4b 10	 dec	 QWORD PTR [rbx+16]
  0009c	c7 43 54 00 00
	00 00		 mov	 DWORD PTR [rbx+84], 0

; 497  : }

  000a3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ac	5f		 pop	 rdi
  000ad	c3		 ret	 0
$LN11@gzungetc:

; 475  :     }
; 476  : 
; 477  :     /* if no room, give up (must have already done a gzungetc()) */
; 478  :     if (state->x.have == (state->size << 1)) {

  000ae	41 3b c0	 cmp	 eax, r8d
  000b1	75 24		 jne	 SHORT $LN12@gzungetc

; 479  :         gz_error(state, Z_DATA_ERROR, "out of room to push characters");

  000b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters@
  000ba	ba fd ff ff ff	 mov	 edx, -3
  000bf	48 8b cb	 mov	 rcx, rbx
  000c2	e8 00 00 00 00	 call	 gz_error
$LN7@gzungetc:

; 497  : }

  000c7	b8 ff ff ff ff	 mov	 eax, -1
  000cc	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d5	5f		 pop	 rdi
  000d6	c3		 ret	 0
$LN12@gzungetc:

; 480  :         return -1;
; 481  :     }
; 482  : 
; 483  :     /* slide output data if needed and insert byte before existing data */
; 484  :     if (state->x.next == state->out) {

  000d7	4c 8b 4b 38	 mov	 r9, QWORD PTR [rbx+56]
  000db	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  000df	49 3b d1	 cmp	 rdx, r9
  000e2	75 30		 jne	 SHORT $LN3@gzungetc

; 485  :         unsigned char *src = state->out + state->x.have;
; 486  :         unsigned char *dest = state->out + (state->size << 1);

  000e4	41 8b d0	 mov	 edx, r8d
  000e7	49 8d 0c 01	 lea	 rcx, QWORD PTR [r9+rax]
  000eb	49 03 d1	 add	 rdx, r9

; 487  :         while (src > state->out)

  000ee	49 3b c9	 cmp	 rcx, r9
  000f1	76 21		 jbe	 SHORT $LN3@gzungetc
  000f3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL2@gzungetc:

; 488  :             *--dest = *--src;

  00100	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  00104	48 ff c9	 dec	 rcx
  00107	48 ff ca	 dec	 rdx
  0010a	88 02		 mov	 BYTE PTR [rdx], al
  0010c	48 3b 4b 38	 cmp	 rcx, QWORD PTR [rbx+56]
  00110	77 ee		 ja	 SHORT $LL2@gzungetc
  00112	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN3@gzungetc:

; 489  :         state->x.next = dest;
; 490  :     }
; 491  :     state->x.have++;

  00114	ff c0		 inc	 eax
  00116	89 03		 mov	 DWORD PTR [rbx], eax

; 492  :     state->x.next--;

  00118	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  0011c	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 493  :     state->x.next[0] = (unsigned char)c;

  00120	40 88 38	 mov	 BYTE PTR [rax], dil

; 494  :     state->x.pos--;
; 495  :     state->past = 0;
; 496  :     return c;

  00123	8b c7		 mov	 eax, edi
  00125	48 ff 4b 10	 dec	 QWORD PTR [rbx+16]
  00129	c7 43 54 00 00
	00 00		 mov	 DWORD PTR [rbx+84], 0

; 497  : }

  00130	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00135	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00139	5f		 pop	 rdi
  0013a	c3		 ret	 0
gzungetc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gzgets
_TEXT	SEGMENT
file$ = 80
buf$ = 88
len$ = 96
gzgets	PROC						; COMDAT

; 500  : char * ZEXPORT gzgets(gzFile file, char *buf, int len) {

$LN41:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001c	41 8b e8	 mov	 ebp, r8d
  0001f	4c 8b f2	 mov	 r14, rdx
  00022	48 8b d9	 mov	 rbx, rcx

; 501  :     unsigned left, n;
; 502  :     char *str;
; 503  :     unsigned char *eol;
; 504  :     gz_statep state;
; 505  : 
; 506  :     /* check parameters and get internal structure */
; 507  :     if (file == NULL || buf == NULL || len < 1)

  00025	48 85 c9	 test	 rcx, rcx
  00028	0f 84 e0 00 00
	00		 je	 $LN6@gzgets
  0002e	48 85 d2	 test	 rdx, rdx
  00031	0f 84 d7 00 00
	00		 je	 $LN6@gzgets
  00037	41 83 f8 01	 cmp	 r8d, 1
  0003b	0f 8c cd 00 00
	00		 jl	 $LN6@gzgets

; 509  :     state = (gz_statep)file;
; 510  : 
; 511  :     /* check that we're reading and that there's no (serious) error */
; 512  :     if (state->mode != GZ_READ ||

  00041	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  00048	0f 85 c0 00 00
	00		 jne	 $LN6@gzgets
  0004e	8b 41 74	 mov	 eax, DWORD PTR [rcx+116]
  00051	85 c0		 test	 eax, eax
  00053	74 09		 je	 SHORT $LN7@gzgets
  00055	83 f8 fb	 cmp	 eax, -5
  00058	0f 85 b0 00 00
	00		 jne	 $LN6@gzgets
$LN7@gzgets:

; 513  :         (state->err != Z_OK && state->err != Z_BUF_ERROR))
; 514  :         return NULL;
; 515  : 
; 516  :     /* process a skip request */
; 517  :     if (state->seek) {

  0005e	83 79 70 00	 cmp	 DWORD PTR [rcx+112], 0
  00062	74 19		 je	 SHORT $LN10@gzgets

; 518  :         state->seek = 0;
; 519  :         if (gz_skip(state, state->skip) == -1)

  00064	48 8b 51 68	 mov	 rdx, QWORD PTR [rcx+104]
  00068	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [rcx+112], 0
  0006f	e8 00 00 00 00	 call	 gz_skip
  00074	83 f8 ff	 cmp	 eax, -1
  00077	0f 84 91 00 00
	00		 je	 $LN6@gzgets
$LN10@gzgets:

; 520  :             return NULL;
; 521  :     }
; 522  : 
; 523  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 524  :        append a terminating zero to the string (we don't check for a zero in
; 525  :        the contents, let the user worry about that) */
; 526  :     str = buf;

  0007d	4d 8b ee	 mov	 r13, r14

; 527  :     left = (unsigned)len - 1;

  00080	83 ed 01	 sub	 ebp, 1

; 528  :     if (left) do {

  00083	0f 84 85 00 00
	00		 je	 $LN6@gzgets
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@gzgets:

; 529  :         /* assure that something is in the output buffer */
; 530  :         if (state->x.have == 0 && gz_fetch(state) == -1)

  00090	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  00093	75 0d		 jne	 SHORT $LN12@gzgets
  00095	48 8b cb	 mov	 rcx, rbx
  00098	e8 00 00 00 00	 call	 gz_fetch
  0009d	83 f8 ff	 cmp	 eax, -1
  000a0	74 6c		 je	 SHORT $LN6@gzgets
$LN12@gzgets:

; 531  :             return NULL;                /* error */
; 532  :         if (state->x.have == 0) {       /* end of file */

  000a2	8b 33		 mov	 esi, DWORD PTR [rbx]
  000a4	85 f6		 test	 esi, esi
  000a6	74 51		 je	 SHORT $LN22@gzgets

; 534  :             break;                      /* return what we have */
; 535  :         }
; 536  : 
; 537  :         /* look for end-of-line in current output buffer */
; 538  :         n = state->x.have > left ? left : state->x.have;
; 539  :         eol = (unsigned char *)memchr(state->x.next, '\n', n);

  000a8	4c 8b 63 08	 mov	 r12, QWORD PTR [rbx+8]
  000ac	3b f5		 cmp	 esi, ebp
  000ae	ba 0a 00 00 00	 mov	 edx, 10
  000b3	49 8b cc	 mov	 rcx, r12
  000b6	0f 47 f5	 cmova	 esi, ebp
  000b9	44 8b c6	 mov	 r8d, esi
  000bc	e8 00 00 00 00	 call	 memchr
  000c1	4c 8b f8	 mov	 r15, rax

; 540  :         if (eol != NULL)

  000c4	48 85 c0	 test	 rax, rax
  000c7	74 08		 je	 SHORT $LN14@gzgets

; 541  :             n = (unsigned)(eol - state->x.next) + 1;

  000c9	41 8b f7	 mov	 esi, r15d
  000cc	41 2b f4	 sub	 esi, r12d
  000cf	ff c6		 inc	 esi
$LN14@gzgets:

; 542  : 
; 543  :         /* copy through end-of-line, or remainder if not found */
; 544  :         memcpy(buf, state->x.next, n);

  000d1	44 8b c6	 mov	 r8d, esi
  000d4	49 8b d4	 mov	 rdx, r12
  000d7	49 8b ce	 mov	 rcx, r14
  000da	8b fe		 mov	 edi, esi
  000dc	e8 00 00 00 00	 call	 memcpy

; 545  :         state->x.have -= n;

  000e1	29 33		 sub	 DWORD PTR [rbx], esi

; 546  :         state->x.next += n;
; 547  :         state->x.pos += n;
; 548  :         left -= n;
; 549  :         buf += n;

  000e3	4c 03 f7	 add	 r14, rdi
  000e6	48 01 7b 08	 add	 QWORD PTR [rbx+8], rdi
  000ea	48 01 7b 10	 add	 QWORD PTR [rbx+16], rdi
  000ee	2b ee		 sub	 ebp, esi

; 550  :     } while (left && eol == NULL);

  000f0	74 0e		 je	 SHORT $LN3@gzgets
  000f2	4d 85 ff	 test	 r15, r15
  000f5	74 99		 je	 SHORT $LL4@gzgets
  000f7	eb 07		 jmp	 SHORT $LN3@gzgets
$LN22@gzgets:

; 533  :             state->past = 1;            /* read past end */

  000f9	c7 43 54 01 00
	00 00		 mov	 DWORD PTR [rbx+84], 1
$LN3@gzgets:

; 551  : 
; 552  :     /* return terminated string, or if nothing, end of file */
; 553  :     if (buf == str)

  00100	4d 3b f5	 cmp	 r14, r13
  00103	74 09		 je	 SHORT $LN6@gzgets

; 554  :         return NULL;
; 555  :     buf[0] = 0;

  00105	41 c6 06 00	 mov	 BYTE PTR [r14], 0

; 556  :     return str;

  00109	49 8b c5	 mov	 rax, r13
  0010c	eb 02		 jmp	 SHORT $LN1@gzgets
$LN6@gzgets:

; 508  :         return NULL;

  0010e	33 c0		 xor	 eax, eax
$LN1@gzgets:

; 557  : }

  00110	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00115	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0011a	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0011f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00123	41 5f		 pop	 r15
  00125	41 5e		 pop	 r14
  00127	41 5d		 pop	 r13
  00129	41 5c		 pop	 r12
  0012b	5f		 pop	 rdi
  0012c	c3		 ret	 0
gzgets	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzread.c
;	COMDAT gzdirect
_TEXT	SEGMENT
file$ = 48
gzdirect PROC						; COMDAT

; 560  : int ZEXPORT gzdirect(gzFile file) {

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 561  :     gz_statep state;
; 562  : 
; 563  :     /* get internal structure */
; 564  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 08		 jne	 SHORT $LN2@gzdirect

; 565  :         return 0;

  0000e	33 c0		 xor	 eax, eax

; 575  : }

  00010	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00014	5b		 pop	 rbx
  00015	c3		 ret	 0
$LN2@gzdirect:

; 566  :     state = (gz_statep)file;
; 567  : 
; 568  :     /* if the state is not known, but we can find out, then do so (this is
; 569  :        mainly for right after a gzopen() or gzdopen()) */
; 570  :     if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)

  00016	81 79 18 4f 1c
	00 00		 cmp	 DWORD PTR [rcx+24], 7247 ; 00001c4fH
  0001d	75 10		 jne	 SHORT $LN3@gzdirect
  0001f	83 79 44 00	 cmp	 DWORD PTR [rcx+68], 0
  00023	75 0a		 jne	 SHORT $LN3@gzdirect
  00025	83 39 00	 cmp	 DWORD PTR [rcx], 0
  00028	75 05		 jne	 SHORT $LN3@gzdirect

; 571  :         (void)gz_look(state);

  0002a	e8 00 00 00 00	 call	 gz_look
$LN3@gzdirect:

; 572  : 
; 573  :     /* return 1 if transparent, 0 if processing a gzip stream */
; 574  :     return state->direct;

  0002f	8b 43 40	 mov	 eax, DWORD PTR [rbx+64]

; 575  : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
gzdirect ENDP
_TEXT	ENDS
END
