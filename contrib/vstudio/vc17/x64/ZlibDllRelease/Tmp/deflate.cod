; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35209.0 

include listing.inc

INCLUDELIB OLDNAMES

?my_version@?1??deflateInit2_@@9@9 DB '1.3.1.1-motley', 00H ; `deflateInit2_'::`2'::my_version
	ORG $+1
configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DQ	FLAT:deflate_stored
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DQ	FLAT:deflate_slow
PUBLIC	deflateCopy
PUBLIC	deflateBound
PUBLIC	deflateTune
PUBLIC	deflateParams
PUBLIC	deflatePrime
PUBLIC	deflateUsed
PUBLIC	deflatePending
PUBLIC	deflateSetHeader
PUBLIC	deflateReset
PUBLIC	deflateResetKeep
PUBLIC	deflateGetDictionary
PUBLIC	deflateSetDictionary
PUBLIC	deflateInit2_
PUBLIC	deflateInit_
PUBLIC	deflateEnd
PUBLIC	deflate
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_huff DD imagerel deflate_huff
	DD	imagerel deflate_huff+483
	DD	imagerel $unwind$deflate_huff
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_rle DD imagerel deflate_rle
	DD	imagerel deflate_rle+847
	DD	imagerel $unwind$deflate_rle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_slow DD imagerel deflate_slow
	DD	imagerel deflate_slow+1359
	DD	imagerel $unwind$deflate_slow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_fast DD imagerel deflate_fast
	DD	imagerel deflate_fast+1144
	DD	imagerel $unwind$deflate_fast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_stored DD imagerel deflate_stored
	DD	imagerel deflate_stored+15
	DD	imagerel $unwind$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$deflate_stored DD imagerel deflate_stored+15
	DD	imagerel deflate_stored+23
	DD	imagerel $chain$0$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$deflate_stored DD imagerel deflate_stored+23
	DD	imagerel deflate_stored+450
	DD	imagerel $chain$4$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflate_stored DD imagerel deflate_stored+450
	DD	imagerel deflate_stored+664
	DD	imagerel $chain$5$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflate_stored DD imagerel deflate_stored+664
	DD	imagerel deflate_stored+1104
	DD	imagerel $chain$6$deflate_stored
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$longest_match DD imagerel longest_match
	DD	imagerel longest_match+438
	DD	imagerel $unwind$longest_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateCopy DD imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateCopy DD imagerel $LN19+41
	DD	imagerel $LN19+474
	DD	imagerel $chain$1$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateCopy DD imagerel $LN19+474
	DD	imagerel $LN19+503
	DD	imagerel $chain$3$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$deflateCopy DD imagerel $LN19+503
	DD	imagerel $LN19+514
	DD	imagerel $chain$4$deflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$flush_pending DD imagerel flush_pending
	DD	imagerel flush_pending+52
	DD	imagerel $unwind$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$flush_pending DD imagerel flush_pending+52
	DD	imagerel flush_pending+91
	DD	imagerel $chain$0$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$flush_pending DD imagerel flush_pending+91
	DD	imagerel flush_pending+115
	DD	imagerel $chain$1$flush_pending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateBound DD imagerel $LN51
	DD	imagerel $LN51+320
	DD	imagerel $unwind$deflateBound
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateTune DD imagerel $LN5
	DD	imagerel $LN5+71
	DD	imagerel $unwind$deflateTune
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateParams DD imagerel $LN36
	DD	imagerel $LN36+376
	DD	imagerel $unwind$deflateParams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflatePrime DD imagerel $LN19
	DD	imagerel $LN19+191
	DD	imagerel $unwind$deflatePrime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateUsed DD imagerel $LN6
	DD	imagerel $LN6+54
	DD	imagerel $unwind$deflateUsed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflatePending DD imagerel $LN8
	DD	imagerel $LN8+69
	DD	imagerel $unwind$deflatePending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateSetHeader DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$deflateSetHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateReset DD imagerel $LN7
	DD	imagerel $LN7+46
	DD	imagerel $unwind$deflateReset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lm_init DD imagerel lm_init
	DD	imagerel lm_init+176
	DD	imagerel $unwind$lm_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateResetKeep DD imagerel $LN11
	DD	imagerel $LN11+158
	DD	imagerel $unwind$deflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateGetDictionary DD imagerel $LN12
	DD	imagerel $LN12+122
	DD	imagerel $unwind$deflateGetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateSetDictionary DD imagerel $LN43
	DD	imagerel $LN43+89
	DD	imagerel $unwind$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$deflateSetDictionary DD imagerel $LN43+89
	DD	imagerel $LN43+492
	DD	imagerel $chain$2$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateSetDictionary DD imagerel $LN43+492
	DD	imagerel $LN43+508
	DD	imagerel $chain$3$deflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit2_ DD imagerel $LN48
	DD	imagerel $LN48+73
	DD	imagerel $unwind$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$deflateInit2_ DD imagerel $LN48+73
	DD	imagerel $LN48+276
	DD	imagerel $chain$1$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$deflateInit2_ DD imagerel $LN48+276
	DD	imagerel $LN48+584
	DD	imagerel $chain$2$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$deflateInit2_ DD imagerel $LN48+584
	DD	imagerel $LN48+607
	DD	imagerel $chain$3$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflateInit2_ DD imagerel $LN48+607
	DD	imagerel $LN48+640
	DD	imagerel $chain$5$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflateInit2_ DD imagerel $LN48+640
	DD	imagerel $LN48+647
	DD	imagerel $chain$6$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$deflateInit2_ DD imagerel $LN48+647
	DD	imagerel $LN48+665
	DD	imagerel $chain$7$deflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_window DD imagerel fill_window
	DD	imagerel fill_window+557
	DD	imagerel $unwind$fill_window
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_buf DD imagerel read_buf
	DD	imagerel read_buf+160
	DD	imagerel $unwind$read_buf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$slide_hash DD imagerel slide_hash
	DD	imagerel slide_hash+117
	DD	imagerel $unwind$slide_hash
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit_ DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$deflateInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateEnd DD imagerel $LN15
	DD	imagerel $LN15+64
	DD	imagerel $unwind$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$deflateEnd DD imagerel $LN15+64
	DD	imagerel $LN15+166
	DD	imagerel $chain$4$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$deflateEnd DD imagerel $LN15+166
	DD	imagerel $LN15+228
	DD	imagerel $chain$5$deflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate DD imagerel $LN245
	DD	imagerel $LN245+42
	DD	imagerel $unwind$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$deflate DD imagerel $LN245+42
	DD	imagerel $LN245+190
	DD	imagerel $chain$4$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$deflate DD imagerel $LN245+190
	DD	imagerel $LN245+2434
	DD	imagerel $chain$6$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$deflate DD imagerel $LN245+2434
	DD	imagerel $LN245+2463
	DD	imagerel $chain$7$deflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$deflate DD imagerel $LN245+2463
	DD	imagerel $LN245+2476
	DD	imagerel $chain$8$deflate
;	COMDAT xdata
xdata	SEGMENT
$chain$8$deflate DD 021H
	DD	imagerel $LN245
	DD	imagerel $LN245+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$deflate DD 020021H
	DD	083400H
	DD	imagerel $LN245
	DD	imagerel $LN245+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflate DD 0a0021H
	DD	04f400H
	DD	0be400H
	DD	0a6400H
	DD	095400H
	DD	083400H
	DD	imagerel $LN245
	DD	imagerel $LN245+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$deflate DD 0a4921H
	DD	04f449H
	DD	0be444H
	DD	0a643fH
	DD	09543aH
	DD	083405H
	DD	imagerel $LN245
	DD	imagerel $LN245+42
	DD	imagerel $unwind$deflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate DD 030801H
	DD	0c0044208H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflateEnd DD 020021H
	DD	04f400H
	DD	imagerel $LN15
	DD	imagerel $LN15+64
	DD	imagerel $unwind$deflateEnd
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$deflateEnd DD 040a21H
	DD	04f40aH
	DD	05e405H
	DD	imagerel $LN15
	DD	imagerel $LN15+64
	DD	imagerel $unwind$deflateEnd
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateEnd DD 083801H
	DD	0a7438H
	DD	09642fH
	DD	083426H
	DD	050025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit_ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$slide_hash DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_buf DD 084701H
	DD	065447H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_window DD 0a1401H
	DD	0e3414H
	DD	0f0103214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$deflateInit2_ DD 021H
	DD	imagerel $LN48
	DD	imagerel $LN48+73
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflateInit2_ DD 040021H
	DD	0cd400H
	DD	0a5400H
	DD	imagerel $LN48
	DD	imagerel $LN48+73
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflateInit2_ DD 060021H
	DD	0cd400H
	DD	0b6400H
	DD	0a5400H
	DD	imagerel $LN48
	DD	imagerel $LN48+73
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateInit2_ DD 021H
	DD	imagerel $LN48+73
	DD	imagerel $LN48+276
	DD	imagerel $chain$1$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$deflateInit2_ DD 020521H
	DD	0b6405H
	DD	imagerel $LN48+73
	DD	imagerel $LN48+276
	DD	imagerel $chain$1$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateInit2_ DD 040a21H
	DD	0cd40aH
	DD	0a5405H
	DD	imagerel $LN48
	DD	imagerel $LN48+73
	DD	imagerel $unwind$deflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit2_ DD 060d01H
	DD	0f009320dH
	DD	0c005e007H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateSetDictionary DD 021H
	DD	imagerel $LN43
	DD	imagerel $LN43+89
	DD	imagerel $unwind$deflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$deflateSetDictionary DD 060f21H
	DD	0cf40fH
	DD	0bd40aH
	DD	0ac405H
	DD	imagerel $LN43
	DD	imagerel $LN43+89
	DD	imagerel $unwind$deflateSetDictionary
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetDictionary DD 060b01H
	DD	0e007320bH
	DD	060047005H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateGetDictionary DD 042c01H
	DD	06342cH
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateResetKeep DD 043501H
	DD	063435H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lm_init DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateReset DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetHeader DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflatePending DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateUsed DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflatePrime DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateParams DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateTune DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateBound DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$flush_pending DD 021H
	DD	imagerel flush_pending
	DD	imagerel flush_pending+52
	DD	imagerel $unwind$flush_pending
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$flush_pending DD 020521H
	DD	073405H
	DD	imagerel flush_pending
	DD	imagerel flush_pending+52
	DD	imagerel $unwind$flush_pending
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$flush_pending DD 060f01H
	DD	09640fH
	DD	08540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$deflateCopy DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$deflateCopy DD 040021H
	DD	076400H
	DD	063400H
	DD	imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$deflateCopy DD 040f21H
	DD	07640fH
	DD	063405H
	DD	imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$deflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateCopy DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$longest_match DD 0b1801H
	DD	096418H
	DD	085418H
	DD	073418H
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$deflate_stored DD 040021H
	DD	0c7400H
	DD	0b6400H
	DD	imagerel deflate_stored
	DD	imagerel deflate_stored+15
	DD	imagerel $unwind$deflate_stored
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$deflate_stored DD 040021H
	DD	0c7400H
	DD	0b6400H
	DD	imagerel deflate_stored+15
	DD	imagerel deflate_stored+23
	DD	imagerel $chain$0$deflate_stored
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$deflate_stored DD 082721H
	DD	04e427H
	DD	0c741dH
	DD	0b6414H
	DD	05d405H
	DD	imagerel deflate_stored+15
	DD	imagerel deflate_stored+23
	DD	imagerel $chain$0$deflate_stored
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$deflate_stored DD 020521H
	DD	0dc405H
	DD	imagerel deflate_stored
	DD	imagerel deflate_stored+15
	DD	imagerel $unwind$deflate_stored
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_stored DD 040901H
	DD	0f0055209H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_fast DD 0c1c01H
	DD	0d641cH
	DD	0c541cH
	DD	0b341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_slow DD 0c1c01H
	DD	0d641cH
	DD	0c541cH
	DD	0b341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_rle DD 0a1b01H
	DD	08641bH
	DD	0a5413H
	DD	093413H
	DD	0f00f3213H
	DD	0700be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_huff DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflate
_TEXT	SEGMENT
strm$ = 64
flush$ = 72
deflate	PROC						; COMDAT

; 954  : int ZEXPORT deflate(z_streamp strm, int flush) {

$LN245:
  00000	40 57		 push	 rdi
  00002	41 54		 push	 r12
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	44 8b e2	 mov	 r12d, edx
  0000b	48 8b f9	 mov	 rdi, rcx

; 955  :     int old_flush; /* value of flush param for previous deflate call */
; 956  :     deflate_state *s;
; 957  : 
; 958  :     if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {

  0000e	e8 00 00 00 00	 call	 deflateStateCheck
  00013	85 c0		 test	 eax, eax
  00015	0f 85 84 09 00
	00		 jne	 $LN32@deflate
  0001b	41 83 fc 05	 cmp	 r12d, 5
  0001f	0f 87 7a 09 00
	00		 ja	 $LN32@deflate

; 960  :     }
; 961  :     s = strm->state;
; 962  : 
; 963  :     if (strm->next_out == Z_NULL ||
; 964  :         (strm->avail_in != 0 && strm->next_in == Z_NULL) ||

  00025	48 83 7f 10 00	 cmp	 QWORD PTR [rdi+16], 0
  0002a	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0002f	48 8b 5f 28	 mov	 rbx, QWORD PTR [rdi+40]
  00033	0f 84 49 09 00
	00		 je	 $LN34@deflate
  00039	39 47 08	 cmp	 DWORD PTR [rdi+8], eax
  0003c	74 0a		 je	 SHORT $LN35@deflate
  0003e	48 83 3f 00	 cmp	 QWORD PTR [rdi], 0
  00042	0f 84 3a 09 00
	00		 je	 $LN34@deflate
$LN35@deflate:
  00048	81 7b 08 9a 02
	00 00		 cmp	 DWORD PTR [rbx+8], 666	; 0000029aH
  0004f	75 0a		 jne	 SHORT $LN33@deflate
  00051	41 83 fc 04	 cmp	 r12d, 4
  00055	0f 85 27 09 00
	00		 jne	 $LN34@deflate
$LN33@deflate:

; 967  :     }
; 968  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  0005b	83 7f 18 00	 cmp	 DWORD PTR [rdi+24], 0
  0005f	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00064	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00069	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  0006e	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00073	0f 84 8a 00 00
	00		 je	 $LN160@deflate

; 969  : 
; 970  :     old_flush = s->last_flush;

  00079	8b 53 40	 mov	 edx, DWORD PTR [rbx+64]

; 971  :     s->last_flush = flush;
; 972  : 
; 973  :     /* Flush as much pending output as possible */
; 974  :     if (s->pending != 0) {

  0007c	33 f6		 xor	 esi, esi
  0007e	44 89 63 40	 mov	 DWORD PTR [rbx+64], r12d
  00082	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  00085	74 37		 je	 SHORT $LN37@deflate

; 975  :         flush_pending(strm);

  00087	48 8b cf	 mov	 rcx, rdi
  0008a	e8 00 00 00 00	 call	 flush_pending

; 976  :         if (strm->avail_out == 0) {

  0008f	39 77 18	 cmp	 DWORD PTR [rdi+24], esi
  00092	75 5c		 jne	 SHORT $LN40@deflate
$LN155@deflate:

; 977  :             /* Since avail_out is 0, deflate will be called again with
; 978  :              * more output space, but possibly with both pending and
; 979  :              * avail_in equal to zero. There won't be anything to do,
; 980  :              * but this is not an error situation so make sure we
; 981  :              * return OK instead of BUF_ERROR at next call of deflate:
; 982  :              */
; 983  :             s->last_flush = -1;

  00094	c7 43 40 ff ff
	ff ff		 mov	 DWORD PTR [rbx+64], -1
$LN88@deflate:

; 984  :             return Z_OK;

  0009b	33 c0		 xor	 eax, eax
$LN242@deflate:
  0009d	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  000a2	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000a7	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ac	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  000b1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1263 : }

  000b6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ba	41 5c		 pop	 r12
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
$LN37@deflate:

; 985  :         }
; 986  : 
; 987  :     /* Make sure there is something to do and avoid duplicate consecutive
; 988  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 989  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 990  :      */
; 991  :     } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&

  000be	39 77 08	 cmp	 DWORD PTR [rdi+8], esi
  000c1	75 2d		 jne	 SHORT $LN40@deflate
  000c3	83 fa 04	 cmp	 edx, 4
  000c6	41 b8 09 00 00
	00		 mov	 r8d, 9
  000cc	8b c6		 mov	 eax, esi
  000ce	8b ce		 mov	 ecx, esi
  000d0	41 0f 4f c0	 cmovg	 eax, r8d
  000d4	03 d2		 add	 edx, edx
  000d6	2b d0		 sub	 edx, eax
  000d8	43 8d 04 24	 lea	 eax, DWORD PTR [r12+r12]
  000dc	41 83 fc 04	 cmp	 r12d, 4
  000e0	41 0f 4f c8	 cmovg	 ecx, r8d
  000e4	2b c1		 sub	 eax, ecx
  000e6	3b c2		 cmp	 eax, edx
  000e8	7f 06		 jg	 SHORT $LN40@deflate
  000ea	41 83 fc 04	 cmp	 r12d, 4
  000ee	75 13		 jne	 SHORT $LN160@deflate
$LN40@deflate:

; 992  :                flush != Z_FINISH) {
; 993  :         ERR_RETURN(strm, Z_BUF_ERROR);
; 994  :     }
; 995  : 
; 996  :     /* User must not provide more input after the first FINISH: */
; 997  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  000f0	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  000f3	3d 9a 02 00 00	 cmp	 eax, 666		; 0000029aH
  000f8	75 1b		 jne	 SHORT $LN41@deflate
  000fa	39 77 08	 cmp	 DWORD PTR [rdi+8], esi
  000fd	0f 84 f1 00 00
	00		 je	 $LN135@deflate
$LN160@deflate:

; 998  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00103	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0N@DFPGLBGC@buffer?5error@
  0010a	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  0010e	b8 fb ff ff ff	 mov	 eax, -5
  00113	eb 88		 jmp	 SHORT $LN242@deflate
$LN41@deflate:

; 999  :     }
; 1000 : 
; 1001 :     /* Write the header */
; 1002 :     if (s->status == INIT_STATE && s->wrap == 0)

  00115	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00118	0f 85 d6 00 00
	00		 jne	 $LN135@deflate
  0011e	39 73 2c	 cmp	 DWORD PTR [rbx+44], esi
  00121	75 0c		 jne	 SHORT $LN144@deflate

; 1003 :         s->status = BUSY_STATE;

  00123	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H

; 1004 :     if (s->status == INIT_STATE) {

  0012a	e9 c5 00 00 00	 jmp	 $LN135@deflate
$LN144@deflate:

; 1005 :         /* zlib header */
; 1006 :         uInt header = (Z_DEFLATED + ((s->w_bits - 8) << 4)) << 8;

  0012f	44 8b 43 48	 mov	 r8d, DWORD PTR [rbx+72]
  00133	41 c1 e0 0c	 shl	 r8d, 12
  00137	41 81 c0 00 88
	ff ff		 add	 r8d, -30720		; ffff8800H

; 1007 :         uInt level_flags;
; 1008 : 
; 1009 :         if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)

  0013e	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  00145	41 8b c8	 mov	 ecx, r8d
  00148	7d 36		 jge	 SHORT $LN46@deflate
  0014a	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  00150	83 f8 02	 cmp	 eax, 2
  00153	7c 2b		 jl	 SHORT $LN46@deflate

; 1011 :         else if (s->level < 6)

  00155	83 f8 06	 cmp	 eax, 6
  00158	7d 0c		 jge	 SHORT $LN47@deflate

; 1012 :             level_flags = 1;

  0015a	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  0015f	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  00164	eb 21		 jmp	 SHORT $LN50@deflate
$LN47@deflate:

; 1013 :         else if (s->level == 6)

  00166	75 0c		 jne	 SHORT $LN49@deflate

; 1014 :             level_flags = 2;

  00168	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  0016d	ba a0 00 00 00	 mov	 edx, 160		; 000000a0H
  00172	eb 13		 jmp	 SHORT $LN50@deflate
$LN49@deflate:

; 1015 :         else
; 1016 :             level_flags = 3;

  00174	b8 c0 00 00 00	 mov	 eax, 192		; 000000c0H
  00179	ba e0 00 00 00	 mov	 edx, 224		; 000000e0H
  0017e	eb 07		 jmp	 SHORT $LN50@deflate
$LN46@deflate:

; 1010 :             level_flags = 0;

  00180	8b c6		 mov	 eax, esi
  00182	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
$LN50@deflate:

; 1017 :         header |= (level_flags << 6);

  00187	0b c8		 or	 ecx, eax

; 1018 :         if (s->strstart != 0) header |= PRESET_DICT;

  00189	39 b3 94 00 00
	00		 cmp	 DWORD PTR [rbx+148], esi
  0018f	74 05		 je	 SHORT $LN51@deflate
  00191	8b ca		 mov	 ecx, edx
  00193	41 0b c8	 or	 ecx, r8d
$LN51@deflate:

; 1019 :         header += 31 - (header % 31);

  00196	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  0019b	f7 e1		 mul	 ecx
  0019d	2b ca		 sub	 ecx, edx
  0019f	d1 e9		 shr	 ecx, 1
  001a1	03 ca		 add	 ecx, edx
  001a3	c1 e9 04	 shr	 ecx, 4
  001a6	ff c1		 inc	 ecx
  001a8	6b d1 1f	 imul	 edx, ecx, 31

; 1020 : 
; 1021 :         putShortMSB(s, header);

  001ab	48 8b cb	 mov	 rcx, rbx
  001ae	e8 00 00 00 00	 call	 putShortMSB

; 1022 : 
; 1023 :         /* Save the adler32 of the preset dictionary: */
; 1024 :         if (s->strstart != 0) {

  001b3	39 b3 94 00 00
	00		 cmp	 DWORD PTR [rbx+148], esi
  001b9	74 12		 je	 SHORT $LN146@deflate

; 1025 :             putShortMSB(s, (uInt)(strm->adler >> 16));

  001bb	0f b7 57 4e	 movzx	 edx, WORD PTR [rdi+78]
  001bf	e8 00 00 00 00	 call	 putShortMSB

; 1026 :             putShortMSB(s, (uInt)(strm->adler & 0xffff));

  001c4	0f b7 57 4c	 movzx	 edx, WORD PTR [rdi+76]
  001c8	e8 00 00 00 00	 call	 putShortMSB
$LN146@deflate:

; 1027 :         }
; 1028 :         strm->adler = adler32(0L, Z_NULL, 0);

  001cd	45 33 c0	 xor	 r8d, r8d
  001d0	33 d2		 xor	 edx, edx
  001d2	33 c9		 xor	 ecx, ecx
  001d4	e8 00 00 00 00	 call	 adler32
  001d9	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 1029 :         s->status = BUSY_STATE;
; 1030 : 
; 1031 :         /* Compression must start with an empty pending buffer */
; 1032 :         flush_pending(strm);

  001dc	48 8b cf	 mov	 rcx, rdi
  001df	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
  001e6	e8 00 00 00 00	 call	 flush_pending

; 1033 :         if (s->pending != 0) {

  001eb	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  001ee	0f 85 a0 fe ff
	ff		 jne	 $LN155@deflate
$LN135@deflate:

; 1034 :             s->last_flush = -1;
; 1035 :             return Z_OK;
; 1036 :         }
; 1037 :     }
; 1038 : #ifdef GZIP
; 1039 :     if (s->status == GZIP_STATE) {

  001f4	83 7b 08 39	 cmp	 DWORD PTR [rbx+8], 57	; 00000039H
  001f8	0f 85 79 02 00
	00		 jne	 $LN56@deflate

; 1040 :         /* gzip header */
; 1041 :         strm->adler = crc32(0L, Z_NULL, 0);

  001fe	45 33 c0	 xor	 r8d, r8d
  00201	4c 8d 77 4c	 lea	 r14, QWORD PTR [rdi+76]
  00205	33 d2		 xor	 edx, edx
  00207	33 c9		 xor	 ecx, ecx
  00209	e8 00 00 00 00	 call	 crc32
  0020e	41 89 06	 mov	 DWORD PTR [r14], eax

; 1042 :         put_byte(s, 31);

  00211	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00214	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00218	c6 04 01 1f	 mov	 BYTE PTR [rcx+rax], 31
  0021c	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  0021f	ff c0		 inc	 eax
  00221	89 43 28	 mov	 DWORD PTR [rbx+40], eax

; 1043 :         put_byte(s, 139);

  00224	8b c8		 mov	 ecx, eax
  00226	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0022a	c6 04 01 8b	 mov	 BYTE PTR [rcx+rax], 139	; 0000008bH
  0022e	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00231	ff c0		 inc	 eax
  00233	89 43 28	 mov	 DWORD PTR [rbx+40], eax

; 1044 :         put_byte(s, 8);

  00236	8b c8		 mov	 ecx, eax
  00238	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0023c	c6 04 01 08	 mov	 BYTE PTR [rcx+rax], 8
  00240	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1045 :         if (s->gzhead == Z_NULL) {

  00243	4c 8b 43 30	 mov	 r8, QWORD PTR [rbx+48]
  00247	ff c0		 inc	 eax
  00249	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  0024c	44 8b c8	 mov	 r9d, eax
  0024f	4d 85 c0	 test	 r8, r8
  00252	0f 85 b4 00 00
	00		 jne	 $LN55@deflate

; 1046 :             put_byte(s, 0);

  00258	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0025c	41 88 34 01	 mov	 BYTE PTR [r9+rax], sil
  00260	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00263	ff c0		 inc	 eax
  00265	89 43 28	 mov	 DWORD PTR [rbx+40], eax

; 1047 :             put_byte(s, 0);

  00268	8b c8		 mov	 ecx, eax
  0026a	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0026e	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  00272	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00275	ff c0		 inc	 eax
  00277	89 43 28	 mov	 DWORD PTR [rbx+40], eax

; 1048 :             put_byte(s, 0);

  0027a	8b c8		 mov	 ecx, eax
  0027c	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00280	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  00284	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00287	ff c0		 inc	 eax
  00289	89 43 28	 mov	 DWORD PTR [rbx+40], eax

; 1049 :             put_byte(s, 0);

  0028c	8b c8		 mov	 ecx, eax
  0028e	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00292	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  00296	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00299	ff c0		 inc	 eax
  0029b	89 43 28	 mov	 DWORD PTR [rbx+40], eax

; 1050 :             put_byte(s, 0);

  0029e	8b c8		 mov	 ecx, eax
  002a0	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  002a4	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  002a8	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 1051 :             put_byte(s, s->level == 9 ? 2 :

  002ab	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  002b1	ff c1		 inc	 ecx
  002b3	89 4b 28	 mov	 DWORD PTR [rbx+40], ecx
  002b6	83 f8 09	 cmp	 eax, 9
  002b9	75 04		 jne	 SHORT $LN104@deflate
  002bb	b2 02		 mov	 dl, 2
  002bd	eb 14		 jmp	 SHORT $LN103@deflate
$LN104@deflate:
  002bf	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  002c6	7d 09		 jge	 SHORT $LN102@deflate
  002c8	83 f8 02	 cmp	 eax, 2
  002cb	7c 04		 jl	 SHORT $LN102@deflate
  002cd	32 d2		 xor	 dl, dl
  002cf	eb 02		 jmp	 SHORT $LN103@deflate
$LN102@deflate:
  002d1	b2 04		 mov	 dl, 4
$LN103@deflate:
  002d3	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  002d7	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  002da	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  002dd	ff c0		 inc	 eax
  002df	89 43 28	 mov	 DWORD PTR [rbx+40], eax

; 1052 :                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 1053 :                       4 : 0));
; 1054 :             put_byte(s, OS_CODE);

  002e2	8b c8		 mov	 ecx, eax
  002e4	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  002e8	c6 04 01 0a	 mov	 BYTE PTR [rcx+rax], 10

; 1055 :             s->status = BUSY_STATE;
; 1056 : 
; 1057 :             /* Compression must start with an empty pending buffer */
; 1058 :             flush_pending(strm);

  002ec	48 8b cf	 mov	 rcx, rdi
  002ef	ff 43 28	 inc	 DWORD PTR [rbx+40]
  002f2	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
  002f9	e8 00 00 00 00	 call	 flush_pending

; 1059 :             if (s->pending != 0) {

  002fe	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  00301	0f 85 8d fd ff
	ff		 jne	 $LN155@deflate
  00307	e9 6b 01 00 00	 jmp	 $LN56@deflate
$LN55@deflate:

; 1060 :                 s->last_flush = -1;
; 1061 :                 return Z_OK;
; 1062 :             }
; 1063 :         }
; 1064 :         else {
; 1065 :             put_byte(s, (s->gzhead->text ? 1 : 0) +

  0030c	49 8b 40 30	 mov	 rax, QWORD PTR [r8+48]
  00310	48 f7 d8	 neg	 rax
  00313	41 8b 40 3c	 mov	 eax, DWORD PTR [r8+60]
  00317	1a d2		 sbb	 dl, dl
  00319	80 e2 10	 and	 dl, 16
  0031c	f7 d8		 neg	 eax
  0031e	49 8b 40 20	 mov	 rax, QWORD PTR [r8+32]
  00322	1a c9		 sbb	 cl, cl
  00324	80 e1 02	 and	 cl, 2
  00327	02 d1		 add	 dl, cl
  00329	48 f7 d8	 neg	 rax
  0032c	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]
  00330	1a c9		 sbb	 cl, cl
  00332	80 e1 08	 and	 cl, 8
  00335	02 d1		 add	 dl, cl
  00337	48 f7 d8	 neg	 rax
  0033a	1a c9		 sbb	 cl, cl
  0033c	80 e1 04	 and	 cl, 4
  0033f	02 d1		 add	 dl, cl
  00341	41 39 30	 cmp	 DWORD PTR [r8], esi
  00344	0f 95 c0	 setne	 al
  00347	02 d0		 add	 dl, al
  00349	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0034d	41 88 14 01	 mov	 BYTE PTR [r9+rax], dl
  00351	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1066 :                      (s->gzhead->hcrc ? 2 : 0) +
; 1067 :                      (s->gzhead->extra == Z_NULL ? 0 : 4) +
; 1068 :                      (s->gzhead->name == Z_NULL ? 0 : 8) +
; 1069 :                      (s->gzhead->comment == Z_NULL ? 0 : 16)
; 1070 :                      );
; 1071 :             put_byte(s, (Byte)(s->gzhead->time & 0xff));

  00354	48 8b 53 30	 mov	 rdx, QWORD PTR [rbx+48]
  00358	ff c0		 inc	 eax
  0035a	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0035e	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  00361	44 8b c0	 mov	 r8d, eax
  00364	0f b6 42 04	 movzx	 eax, BYTE PTR [rdx+4]
  00368	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  0036c	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1072 :             put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));

  0036f	48 8b 53 30	 mov	 rdx, QWORD PTR [rbx+48]
  00373	ff c0		 inc	 eax
  00375	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00379	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  0037c	44 8b c0	 mov	 r8d, eax
  0037f	0f b6 42 05	 movzx	 eax, BYTE PTR [rdx+5]
  00383	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  00387	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1073 :             put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));

  0038a	48 8b 53 30	 mov	 rdx, QWORD PTR [rbx+48]
  0038e	ff c0		 inc	 eax
  00390	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00394	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  00397	44 8b c0	 mov	 r8d, eax
  0039a	0f b6 42 06	 movzx	 eax, BYTE PTR [rdx+6]
  0039e	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  003a2	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1074 :             put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));

  003a5	48 8b 53 30	 mov	 rdx, QWORD PTR [rbx+48]
  003a9	ff c0		 inc	 eax
  003ab	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  003af	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  003b2	44 8b c0	 mov	 r8d, eax
  003b5	0f b6 42 07	 movzx	 eax, BYTE PTR [rdx+7]
  003b9	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  003bd	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 1075 :             put_byte(s, s->level == 9 ? 2 :

  003c0	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  003c6	ff c1		 inc	 ecx
  003c8	89 4b 28	 mov	 DWORD PTR [rbx+40], ecx
  003cb	83 f8 09	 cmp	 eax, 9
  003ce	75 04		 jne	 SHORT $LN108@deflate
  003d0	b2 02		 mov	 dl, 2
  003d2	eb 18		 jmp	 SHORT $LN107@deflate
$LN108@deflate:
  003d4	83 bb b0 00 00
	00 02		 cmp	 DWORD PTR [rbx+176], 2
  003db	7d 0d		 jge	 SHORT $LN106@deflate
  003dd	4c 8d 77 4c	 lea	 r14, QWORD PTR [rdi+76]
  003e1	83 f8 02	 cmp	 eax, 2
  003e4	7c 04		 jl	 SHORT $LN106@deflate
  003e6	32 d2		 xor	 dl, dl
  003e8	eb 02		 jmp	 SHORT $LN107@deflate
$LN106@deflate:
  003ea	b2 04		 mov	 dl, 4
$LN107@deflate:
  003ec	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  003f0	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  003f3	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1076 :                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 1077 :                       4 : 0));
; 1078 :             put_byte(s, s->gzhead->os & 0xff);

  003f6	48 8b 53 30	 mov	 rdx, QWORD PTR [rbx+48]
  003fa	ff c0		 inc	 eax
  003fc	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00400	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  00403	44 8b c0	 mov	 r8d, eax
  00406	0f b6 42 0c	 movzx	 eax, BYTE PTR [rdx+12]
  0040a	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  0040e	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]

; 1079 :             if (s->gzhead->extra != Z_NULL) {

  00412	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00416	41 ff c0	 inc	 r8d
  00419	44 89 43 28	 mov	 DWORD PTR [rbx+40], r8d
  0041d	48 39 70 10	 cmp	 QWORD PTR [rax+16], rsi
  00421	74 32		 je	 SHORT $LN58@deflate

; 1080 :                 put_byte(s, s->gzhead->extra_len & 0xff);

  00423	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  00427	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0042b	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  0042f	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1081 :                 put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);

  00432	48 8b 53 30	 mov	 rdx, QWORD PTR [rbx+48]
  00436	ff c0		 inc	 eax
  00438	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0043c	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  0043f	44 8b c0	 mov	 r8d, eax
  00442	0f b6 42 19	 movzx	 eax, BYTE PTR [rdx+25]
  00446	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  0044a	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  0044e	41 ff c0	 inc	 r8d
  00451	44 89 43 28	 mov	 DWORD PTR [rbx+40], r8d
$LN58@deflate:

; 1082 :             }
; 1083 :             if (s->gzhead->hcrc)

  00455	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00459	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  0045c	74 0f		 je	 SHORT $LN59@deflate

; 1084 :                 strm->adler = crc32(strm->adler, s->pending_buf,

  0045e	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  00462	41 8b 0e	 mov	 ecx, DWORD PTR [r14]
  00465	e8 00 00 00 00	 call	 crc32
  0046a	41 89 06	 mov	 DWORD PTR [r14], eax
$LN59@deflate:

; 1085 :                                     s->pending);
; 1086 :             s->gzindex = 0;

  0046d	89 73 38	 mov	 DWORD PTR [rbx+56], esi

; 1087 :             s->status = EXTRA_STATE;

  00470	c7 43 08 45 00
	00 00		 mov	 DWORD PTR [rbx+8], 69	; 00000045H
$LN56@deflate:

; 1088 :         }
; 1089 :     }
; 1090 :     if (s->status == EXTRA_STATE) {

  00477	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  0047a	83 f8 45	 cmp	 eax, 69			; 00000045H
  0047d	0f 85 f5 00 00
	00		 jne	 $LN60@deflate

; 1091 :         if (s->gzhead->extra != Z_NULL) {

  00483	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00487	48 39 70 10	 cmp	 QWORD PTR [rax+16], rsi
  0048b	0f 84 de 00 00
	00		 je	 $LN148@deflate

; 1092 :             ulg beg = s->pending;   /* start of bytes to update crc */
; 1093 :             uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;

  00491	0f b7 68 18	 movzx	 ebp, WORD PTR [rax+24]
  00495	2b 6b 38	 sub	 ebp, DWORD PTR [rbx+56]
  00498	44 8b 73 28	 mov	 r14d, DWORD PTR [rbx+40]

; 1094 :             while (s->pending + left > s->pending_buf_size) {

  0049c	45 8b d6	 mov	 r10d, r14d
  0049f	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  004a2	41 8d 04 2e	 lea	 eax, DWORD PTR [r14+rbp]
  004a6	3b c1		 cmp	 eax, ecx
  004a8	76 7a		 jbe	 SHORT $LN3@deflate
  004aa	45 8b ce	 mov	 r9d, r14d
  004ad	0f 1f 00	 npad	 3
$LL2@deflate:

; 1095 :                 uInt copy = s->pending_buf_size - s->pending;
; 1096 :                 zmemcpy(s->pending_buf + s->pending,

  004b0	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  004b4	41 2b c9	 sub	 ecx, r9d
  004b7	8b 53 38	 mov	 edx, DWORD PTR [rbx+56]
  004ba	44 8b f9	 mov	 r15d, ecx
  004bd	44 8b c1	 mov	 r8d, ecx
  004c0	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  004c4	41 8b c9	 mov	 ecx, r9d
  004c7	48 03 4b 10	 add	 rcx, QWORD PTR [rbx+16]
  004cb	e8 00 00 00 00	 call	 memcpy

; 1097 :                         s->gzhead->extra + s->gzindex, copy);
; 1098 :                 s->pending = s->pending_buf_size;
; 1099 :                 HCRC_UPDATE(beg);

  004d0	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  004d4	44 8b 43 18	 mov	 r8d, DWORD PTR [rbx+24]
  004d8	44 89 43 28	 mov	 DWORD PTR [rbx+40], r8d
  004dc	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  004df	74 1a		 je	 SHORT $LN4@deflate
  004e1	45 3b c6	 cmp	 r8d, r14d
  004e4	76 15		 jbe	 SHORT $LN4@deflate
  004e6	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  004e9	45 2b c6	 sub	 r8d, r14d
  004ec	41 8b d6	 mov	 edx, r14d
  004ef	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  004f3	e8 00 00 00 00	 call	 crc32
  004f8	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN4@deflate:

; 1100 :                 s->gzindex += copy;

  004fb	44 01 7b 38	 add	 DWORD PTR [rbx+56], r15d

; 1101 :                 flush_pending(strm);

  004ff	48 8b cf	 mov	 rcx, rdi
  00502	e8 00 00 00 00	 call	 flush_pending

; 1102 :                 if (s->pending != 0) {

  00507	44 8b 53 28	 mov	 r10d, DWORD PTR [rbx+40]
  0050b	45 85 d2	 test	 r10d, r10d
  0050e	0f 85 80 fb ff
	ff		 jne	 $LN155@deflate

; 1103 :                     s->last_flush = -1;
; 1104 :                     return Z_OK;
; 1105 :                 }
; 1106 :                 beg = 0;
; 1107 :                 left -= copy;

  00514	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  00517	41 2b ef	 sub	 ebp, r15d
  0051a	44 8b f6	 mov	 r14d, esi
  0051d	44 8b ce	 mov	 r9d, esi
  00520	3b e9		 cmp	 ebp, ecx
  00522	77 8c		 ja	 SHORT $LL2@deflate
$LN3@deflate:

; 1108 :             }
; 1109 :             zmemcpy(s->pending_buf + s->pending,

  00524	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00528	8b 53 38	 mov	 edx, DWORD PTR [rbx+56]
  0052b	41 8b ca	 mov	 ecx, r10d
  0052e	48 03 4b 10	 add	 rcx, QWORD PTR [rbx+16]
  00532	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00536	44 8b c5	 mov	 r8d, ebp
  00539	e8 00 00 00 00	 call	 memcpy

; 1110 :                     s->gzhead->extra + s->gzindex, left);
; 1111 :             s->pending += left;

  0053e	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]

; 1112 :             HCRC_UPDATE(beg);

  00542	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00546	44 03 c5	 add	 r8d, ebp
  00549	44 89 43 28	 mov	 DWORD PTR [rbx+40], r8d
  0054d	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  00550	74 1a		 je	 SHORT $LN7@deflate
  00552	45 3b c6	 cmp	 r8d, r14d
  00555	76 15		 jbe	 SHORT $LN7@deflate
  00557	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  0055a	45 2b c6	 sub	 r8d, r14d
  0055d	41 8b d6	 mov	 edx, r14d
  00560	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00564	e8 00 00 00 00	 call	 crc32
  00569	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN7@deflate:

; 1113 :             s->gzindex = 0;

  0056c	89 73 38	 mov	 DWORD PTR [rbx+56], esi
$LN148@deflate:

; 1114 :         }
; 1115 :         s->status = NAME_STATE;

  0056f	c7 43 08 49 00
	00 00		 mov	 DWORD PTR [rbx+8], 73	; 00000049H

; 1135 :             s->gzindex = 0;

  00576	eb 09		 jmp	 SHORT $LN154@deflate
$LN60@deflate:

; 1116 :     }
; 1117 :     if (s->status == NAME_STATE) {

  00578	83 f8 49	 cmp	 eax, 73			; 00000049H
  0057b	0f 85 b2 00 00
	00		 jne	 $LN65@deflate
$LN154@deflate:

; 1118 :         if (s->gzhead->name != Z_NULL) {

  00581	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00585	48 39 70 20	 cmp	 QWORD PTR [rax+32], rsi
  00589	0f 84 9b 00 00
	00		 je	 $LN149@deflate

; 1119 :             ulg beg = s->pending;   /* start of bytes to update crc */

  0058f	44 8b 4b 28	 mov	 r9d, DWORD PTR [rbx+40]
  00593	45 8b c1	 mov	 r8d, r9d
$LL12@deflate:

; 1120 :             int val;
; 1121 :             do {
; 1122 :                 if (s->pending == s->pending_buf_size) {

  00596	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  0059a	75 3a		 jne	 SHORT $LN67@deflate

; 1123 :                     HCRC_UPDATE(beg);

  0059c	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  005a0	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  005a3	74 1a		 je	 SHORT $LN13@deflate
  005a5	45 3b c1	 cmp	 r8d, r9d
  005a8	76 15		 jbe	 SHORT $LN13@deflate
  005aa	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  005ad	45 2b c1	 sub	 r8d, r9d
  005b0	41 8b d1	 mov	 edx, r9d
  005b3	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  005b7	e8 00 00 00 00	 call	 crc32
  005bc	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN13@deflate:

; 1124 :                     flush_pending(strm);

  005bf	48 8b cf	 mov	 rcx, rdi
  005c2	e8 00 00 00 00	 call	 flush_pending

; 1125 :                     if (s->pending != 0) {

  005c7	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  005ca	0f 85 c4 fa ff
	ff		 jne	 $LN155@deflate

; 1126 :                         s->last_flush = -1;
; 1127 :                         return Z_OK;
; 1128 :                     }
; 1129 :                     beg = 0;

  005d0	44 8b ce	 mov	 r9d, esi
  005d3	44 8b c6	 mov	 r8d, esi
$LN67@deflate:

; 1130 :                 }
; 1131 :                 val = s->gzhead->name[s->gzindex++];

  005d6	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  005d9	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  005dd	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  005e1	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  005e5	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]

; 1132 :                 put_byte(s, val);

  005e8	41 8b c8	 mov	 ecx, r8d
  005eb	89 43 38	 mov	 DWORD PTR [rbx+56], eax
  005ee	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  005f2	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  005f5	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  005f9	41 ff c0	 inc	 r8d
  005fc	44 89 43 28	 mov	 DWORD PTR [rbx+40], r8d

; 1133 :             } while (val != 0);

  00600	84 d2		 test	 dl, dl
  00602	75 92		 jne	 SHORT $LL12@deflate

; 1134 :             HCRC_UPDATE(beg);

  00604	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00608	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  0060b	74 1a		 je	 SHORT $LN16@deflate
  0060d	45 3b c1	 cmp	 r8d, r9d
  00610	76 15		 jbe	 SHORT $LN16@deflate
  00612	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  00615	45 2b c1	 sub	 r8d, r9d
  00618	41 8b d1	 mov	 edx, r9d
  0061b	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  0061f	e8 00 00 00 00	 call	 crc32
  00624	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN16@deflate:

; 1135 :             s->gzindex = 0;

  00627	89 73 38	 mov	 DWORD PTR [rbx+56], esi
$LN149@deflate:

; 1136 :         }
; 1137 :         s->status = COMMENT_STATE;

  0062a	c7 43 08 5b 00
	00 00		 mov	 DWORD PTR [rbx+8], 91	; 0000005bH
  00631	eb 09		 jmp	 SHORT $LN153@deflate
$LN65@deflate:

; 1138 :     }
; 1139 :     if (s->status == COMMENT_STATE) {

  00633	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  00636	0f 85 af 00 00
	00		 jne	 $LN71@deflate
$LN153@deflate:

; 1140 :         if (s->gzhead->comment != Z_NULL) {

  0063c	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00640	48 39 70 30	 cmp	 QWORD PTR [rax+48], rsi
  00644	0f 84 98 00 00
	00		 je	 $LN26@deflate

; 1141 :             ulg beg = s->pending;   /* start of bytes to update crc */

  0064a	44 8b 4b 28	 mov	 r9d, DWORD PTR [rbx+40]
  0064e	45 8b c1	 mov	 r8d, r9d
$LL21@deflate:

; 1142 :             int val;
; 1143 :             do {
; 1144 :                 if (s->pending == s->pending_buf_size) {

  00651	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  00655	75 3a		 jne	 SHORT $LN73@deflate

; 1145 :                     HCRC_UPDATE(beg);

  00657	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0065b	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  0065e	74 1a		 je	 SHORT $LN22@deflate
  00660	45 3b c1	 cmp	 r8d, r9d
  00663	76 15		 jbe	 SHORT $LN22@deflate
  00665	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  00668	45 2b c1	 sub	 r8d, r9d
  0066b	41 8b d1	 mov	 edx, r9d
  0066e	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  00672	e8 00 00 00 00	 call	 crc32
  00677	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN22@deflate:

; 1146 :                     flush_pending(strm);

  0067a	48 8b cf	 mov	 rcx, rdi
  0067d	e8 00 00 00 00	 call	 flush_pending

; 1147 :                     if (s->pending != 0) {

  00682	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  00685	0f 85 09 fa ff
	ff		 jne	 $LN155@deflate

; 1148 :                         s->last_flush = -1;
; 1149 :                         return Z_OK;
; 1150 :                     }
; 1151 :                     beg = 0;

  0068b	44 8b ce	 mov	 r9d, esi
  0068e	44 8b c6	 mov	 r8d, esi
$LN73@deflate:

; 1152 :                 }
; 1153 :                 val = s->gzhead->comment[s->gzindex++];

  00691	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00694	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00698	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0069c	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  006a0	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]

; 1154 :                 put_byte(s, val);

  006a3	41 8b c8	 mov	 ecx, r8d
  006a6	89 43 38	 mov	 DWORD PTR [rbx+56], eax
  006a9	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  006ad	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  006b0	44 8b 43 28	 mov	 r8d, DWORD PTR [rbx+40]
  006b4	41 ff c0	 inc	 r8d
  006b7	44 89 43 28	 mov	 DWORD PTR [rbx+40], r8d

; 1155 :             } while (val != 0);

  006bb	84 d2		 test	 dl, dl
  006bd	75 92		 jne	 SHORT $LL21@deflate

; 1156 :             HCRC_UPDATE(beg);

  006bf	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  006c3	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  006c6	74 1a		 je	 SHORT $LN26@deflate
  006c8	45 3b c1	 cmp	 r8d, r9d
  006cb	76 15		 jbe	 SHORT $LN26@deflate
  006cd	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  006d0	45 2b c1	 sub	 r8d, r9d
  006d3	41 8b d1	 mov	 edx, r9d
  006d6	48 03 53 10	 add	 rdx, QWORD PTR [rbx+16]
  006da	e8 00 00 00 00	 call	 crc32
  006df	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN26@deflate:

; 1157 :         }
; 1158 :         s->status = HCRC_STATE;

  006e2	c7 43 08 67 00
	00 00		 mov	 DWORD PTR [rbx+8], 103	; 00000067H

; 1159 :     }
; 1160 :     if (s->status == HCRC_STATE) {

  006e9	eb 05		 jmp	 SHORT $LN145@deflate
$LN71@deflate:
  006eb	83 f8 67	 cmp	 eax, 103		; 00000067H
  006ee	75 73		 jne	 SHORT $LN151@deflate
$LN145@deflate:

; 1161 :         if (s->gzhead->hcrc) {

  006f0	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  006f4	39 70 3c	 cmp	 DWORD PTR [rax+60], esi
  006f7	74 52		 je	 SHORT $LN78@deflate

; 1162 :             if (s->pending + 2 > s->pending_buf_size) {

  006f9	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  006fc	8d 41 02	 lea	 eax, DWORD PTR [rcx+2]
  006ff	3b 43 18	 cmp	 eax, DWORD PTR [rbx+24]
  00702	76 13		 jbe	 SHORT $LN150@deflate

; 1163 :                 flush_pending(strm);

  00704	48 8b cf	 mov	 rcx, rdi
  00707	e8 00 00 00 00	 call	 flush_pending

; 1164 :                 if (s->pending != 0) {

  0070c	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0070f	85 c9		 test	 ecx, ecx
  00711	0f 85 7d f9 ff
	ff		 jne	 $LN155@deflate
$LN150@deflate:

; 1165 :                     s->last_flush = -1;
; 1166 :                     return Z_OK;
; 1167 :                 }
; 1168 :             }
; 1169 :             put_byte(s, (Byte)(strm->adler & 0xff));

  00717	0f b6 47 4c	 movzx	 eax, BYTE PTR [rdi+76]

; 1170 :             put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
; 1171 :             strm->adler = crc32(0L, Z_NULL, 0);

  0071b	45 33 c0	 xor	 r8d, r8d
  0071e	8b d1		 mov	 edx, ecx
  00720	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00724	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00727	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  0072a	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0072e	ff c0		 inc	 eax
  00730	8b d0		 mov	 edx, eax
  00732	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  00735	0f b6 47 4d	 movzx	 eax, BYTE PTR [rdi+77]
  00739	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0073c	33 d2		 xor	 edx, edx
  0073e	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00741	33 c9		 xor	 ecx, ecx
  00743	e8 00 00 00 00	 call	 crc32
  00748	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN78@deflate:

; 1172 :         }
; 1173 :         s->status = BUSY_STATE;
; 1174 : 
; 1175 :         /* Compression must start with an empty pending buffer */
; 1176 :         flush_pending(strm);

  0074b	48 8b cf	 mov	 rcx, rdi
  0074e	c7 43 08 71 00
	00 00		 mov	 DWORD PTR [rbx+8], 113	; 00000071H
  00755	e8 00 00 00 00	 call	 flush_pending

; 1177 :         if (s->pending != 0) {

  0075a	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  0075d	0f 85 31 f9 ff
	ff		 jne	 $LN155@deflate
$LN151@deflate:

; 1178 :             s->last_flush = -1;
; 1179 :             return Z_OK;
; 1180 :         }
; 1181 :     }
; 1182 : #endif
; 1183 : 
; 1184 :     /* Start a new block or continue the current one.
; 1185 :      */
; 1186 :     if (strm->avail_in != 0 || s->lookahead != 0 ||

  00763	39 77 08	 cmp	 DWORD PTR [rdi+8], esi
  00766	75 1e		 jne	 SHORT $LN83@deflate
  00768	39 b3 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], esi
  0076e	75 16		 jne	 SHORT $LN83@deflate
  00770	45 85 e4	 test	 r12d, r12d
  00773	0f 84 22 f9 ff
	ff		 je	 $LN88@deflate
  00779	81 7b 08 9a 02
	00 00		 cmp	 DWORD PTR [rbx+8], 666	; 0000029aH
  00780	0f 84 ed 00 00
	00		 je	 $LN95@deflate
$LN83@deflate:

; 1187 :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
; 1188 :         block_state bstate;
; 1189 : 
; 1190 :         bstate = s->level == 0 ? deflate_stored(s, flush) :

  00786	48 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rbx+172]
  0078d	41 8b d4	 mov	 edx, r12d
  00790	85 c9		 test	 ecx, ecx
  00792	75 0a		 jne	 SHORT $LN114@deflate
  00794	48 8b cb	 mov	 rcx, rbx
  00797	e8 00 00 00 00	 call	 deflate_stored
  0079c	eb 3b		 jmp	 SHORT $LN243@deflate
$LN114@deflate:
  0079e	8b 83 b0 00 00
	00		 mov	 eax, DWORD PTR [rbx+176]
  007a4	83 f8 02	 cmp	 eax, 2
  007a7	75 0a		 jne	 SHORT $LN112@deflate
  007a9	48 8b cb	 mov	 rcx, rbx
  007ac	e8 00 00 00 00	 call	 deflate_huff
  007b1	eb 26		 jmp	 SHORT $LN243@deflate
$LN112@deflate:
  007b3	83 f8 03	 cmp	 eax, 3
  007b6	75 0a		 jne	 SHORT $LN110@deflate
  007b8	48 8b cb	 mov	 rcx, rbx
  007bb	e8 00 00 00 00	 call	 deflate_rle
  007c0	eb 17		 jmp	 SHORT $LN243@deflate
$LN110@deflate:
  007c2	48 8b c1	 mov	 rax, rcx
  007c5	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:configuration_table+8
  007cc	48 03 c0	 add	 rax, rax
  007cf	48 8b cb	 mov	 rcx, rbx
  007d2	4d 8b 04 c0	 mov	 r8, QWORD PTR [r8+rax*8]
  007d6	41 ff d0	 call	 r8
$LN243@deflate:

; 1191 :                  s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
; 1192 :                  s->strategy == Z_RLE ? deflate_rle(s, flush) :
; 1193 :                  (*(configuration_table[s->level].func))(s, flush);
; 1194 : 
; 1195 :         if (bstate == finish_started || bstate == finish_done) {

  007d9	8b c8		 mov	 ecx, eax
  007db	8d 40 fe	 lea	 eax, DWORD PTR [rax-2]
  007de	83 f8 01	 cmp	 eax, 1
  007e1	77 07		 ja	 SHORT $LN84@deflate

; 1196 :             s->status = FINISH_STATE;

  007e3	c7 43 08 9a 02
	00 00		 mov	 DWORD PTR [rbx+8], 666	; 0000029aH
$LN84@deflate:

; 1197 :         }
; 1198 :         if (bstate == need_more || bstate == finish_started) {

  007ea	f7 c1 fd ff ff
	ff		 test	 ecx, -3			; fffffffdH
  007f0	0f 84 7e 01 00
	00		 je	 $LN87@deflate

; 1203 :             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 1204 :              * of deflate should use the same flush parameter to make sure
; 1205 :              * that the flush is complete. So we don't have to output an
; 1206 :              * empty block here, this will be done at next call. This also
; 1207 :              * ensures that for a very small output buffer, we emit at most
; 1208 :              * one empty block.
; 1209 :              */
; 1210 :         }
; 1211 :         if (bstate == block_done) {

  007f6	83 f9 01	 cmp	 ecx, 1
  007f9	75 78		 jne	 SHORT $LN95@deflate

; 1212 :             if (flush == Z_PARTIAL_FLUSH) {

  007fb	44 3b e1	 cmp	 r12d, ecx
  007fe	75 0a		 jne	 SHORT $LN90@deflate

; 1213 :                 _tr_align(s);

  00800	48 8b cb	 mov	 rcx, rbx
  00803	e8 00 00 00 00	 call	 _tr_align
  00808	eb 58		 jmp	 SHORT $LN94@deflate
$LN90@deflate:

; 1214 :             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

  0080a	41 83 fc 05	 cmp	 r12d, 5
  0080e	74 52		 je	 SHORT $LN94@deflate

; 1215 :                 _tr_stored_block(s, (char*)0, 0L, 0);

  00810	45 33 c9	 xor	 r9d, r9d
  00813	45 33 c0	 xor	 r8d, r8d
  00816	33 d2		 xor	 edx, edx
  00818	48 8b cb	 mov	 rcx, rbx
  0081b	e8 00 00 00 00	 call	 _tr_stored_block

; 1216 :                 /* For a full flush, this empty block will be recognized
; 1217 :                  * as a special marker by inflate_sync().
; 1218 :                  */
; 1219 :                 if (flush == Z_FULL_FLUSH) {

  00820	41 83 fc 03	 cmp	 r12d, 3
  00824	75 3c		 jne	 SHORT $LN94@deflate

; 1220 :                     CLEAR_HASH(s);             /* forget history */

  00826	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  00829	33 d2		 xor	 edx, edx
  0082b	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  0082f	ff c9		 dec	 ecx
  00831	66 89 34 48	 mov	 WORD PTR [rax+rcx*2], si
  00835	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  00839	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0083d	41 ff c8	 dec	 r8d
  00840	4d 03 c0	 add	 r8, r8
  00843	e8 00 00 00 00	 call	 memset

; 1221 :                     if (s->lookahead == 0) {

  00848	39 b3 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], esi
  0084e	75 12		 jne	 SHORT $LN94@deflate

; 1222 :                         s->strstart = 0;

  00850	89 b3 94 00 00
	00		 mov	 DWORD PTR [rbx+148], esi

; 1223 :                         s->block_start = 0L;

  00856	89 b3 84 00 00
	00		 mov	 DWORD PTR [rbx+132], esi

; 1224 :                         s->insert = 0;

  0085c	89 b3 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], esi
$LN94@deflate:

; 1225 :                     }
; 1226 :                 }
; 1227 :             }
; 1228 :             flush_pending(strm);

  00862	48 8b cf	 mov	 rcx, rdi
  00865	e8 00 00 00 00	 call	 flush_pending

; 1229 :             if (strm->avail_out == 0) {

  0086a	39 77 18	 cmp	 DWORD PTR [rdi+24], esi
  0086d	0f 84 21 f8 ff
	ff		 je	 $LN155@deflate
$LN95@deflate:

; 1230 :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
; 1231 :               return Z_OK;
; 1232 :             }
; 1233 :         }
; 1234 :     }
; 1235 : 
; 1236 :     if (flush != Z_FINISH) return Z_OK;

  00873	41 83 fc 04	 cmp	 r12d, 4
  00877	0f 85 1e f8 ff
	ff		 jne	 $LN88@deflate

; 1237 :     if (s->wrap <= 0) return Z_STREAM_END;

  0087d	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  00880	85 c0		 test	 eax, eax
  00882	7f 0a		 jg	 SHORT $LN97@deflate
  00884	b8 01 00 00 00	 mov	 eax, 1
  00889	e9 0f f8 ff ff	 jmp	 $LN242@deflate
$LN97@deflate:

; 1238 : 
; 1239 :     /* Write the trailer */
; 1240 : #ifdef GZIP
; 1241 :     if (s->wrap == 2) {

  0088e	83 f8 02	 cmp	 eax, 2
  00891	0f 85 a6 00 00
	00		 jne	 $LN98@deflate

; 1242 :         put_byte(s, (Byte)(strm->adler & 0xff));

  00897	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0089a	0f b6 47 4c	 movzx	 eax, BYTE PTR [rdi+76]
  0089e	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  008a2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008a5	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1243 :         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  008a8	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  008ac	ff c0		 inc	 eax
  008ae	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  008b1	8b d0		 mov	 edx, eax
  008b3	0f b6 47 4d	 movzx	 eax, BYTE PTR [rdi+77]
  008b7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008ba	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1244 :         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));

  008bd	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  008c1	ff c0		 inc	 eax
  008c3	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  008c6	8b d0		 mov	 edx, eax
  008c8	0f b6 47 4e	 movzx	 eax, BYTE PTR [rdi+78]
  008cc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008cf	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1245 :         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));

  008d2	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  008d6	ff c0		 inc	 eax
  008d8	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  008db	8b d0		 mov	 edx, eax
  008dd	0f b6 47 4f	 movzx	 eax, BYTE PTR [rdi+79]
  008e1	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008e4	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1246 :         put_byte(s, (Byte)(strm->total_in & 0xff));

  008e7	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  008eb	ff c0		 inc	 eax
  008ed	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  008f0	8b d0		 mov	 edx, eax
  008f2	0f b6 47 0c	 movzx	 eax, BYTE PTR [rdi+12]
  008f6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008f9	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1247 :         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));

  008fc	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00900	ff c0		 inc	 eax
  00902	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  00905	8b d0		 mov	 edx, eax
  00907	0f b6 47 0d	 movzx	 eax, BYTE PTR [rdi+13]
  0090b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0090e	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1248 :         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));

  00911	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00915	ff c0		 inc	 eax
  00917	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  0091a	8b d0		 mov	 edx, eax
  0091c	0f b6 47 0e	 movzx	 eax, BYTE PTR [rdi+14]
  00920	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00923	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 1249 :         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));

  00926	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0092a	ff c0		 inc	 eax
  0092c	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  0092f	8b d0		 mov	 edx, eax
  00931	0f b6 47 0f	 movzx	 eax, BYTE PTR [rdi+15]
  00935	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00938	ff 43 28	 inc	 DWORD PTR [rbx+40]

; 1250 :     }

  0093b	eb 15		 jmp	 SHORT $LN99@deflate
$LN98@deflate:

; 1251 :     else
; 1252 : #endif
; 1253 :     {
; 1254 :         putShortMSB(s, (uInt)(strm->adler >> 16));

  0093d	0f b7 57 4e	 movzx	 edx, WORD PTR [rdi+78]
  00941	48 8b cb	 mov	 rcx, rbx
  00944	e8 00 00 00 00	 call	 putShortMSB

; 1255 :         putShortMSB(s, (uInt)(strm->adler & 0xffff));

  00949	0f b7 57 4c	 movzx	 edx, WORD PTR [rdi+76]
  0094d	e8 00 00 00 00	 call	 putShortMSB
$LN99@deflate:

; 1256 :     }
; 1257 :     flush_pending(strm);

  00952	48 8b cf	 mov	 rcx, rdi
  00955	e8 00 00 00 00	 call	 flush_pending

; 1258 :     /* If avail_out is zero, the application will call deflate again
; 1259 :      * to flush the rest.
; 1260 :      */
; 1261 :     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */

  0095a	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  0095d	85 c0		 test	 eax, eax
  0095f	7e 05		 jle	 SHORT $LN100@deflate
  00961	f7 d8		 neg	 eax
  00963	89 43 2c	 mov	 DWORD PTR [rbx+44], eax
$LN100@deflate:

; 1262 :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  00966	39 73 28	 cmp	 DWORD PTR [rbx+40], esi
  00969	40 0f 94 c6	 sete	 sil
  0096d	8b c6		 mov	 eax, esi
  0096f	e9 29 f7 ff ff	 jmp	 $LN242@deflate
$LN87@deflate:

; 1199 :             if (strm->avail_out == 0) {

  00974	39 77 18	 cmp	 DWORD PTR [rdi+24], esi
  00977	0f 85 1e f7 ff
	ff		 jne	 $LN88@deflate

; 1200 :                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
; 1201 :             }
; 1202 :             return Z_OK;

  0097d	e9 12 f7 ff ff	 jmp	 $LN155@deflate
$LN34@deflate:
  00982	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 965  :         (s->status == FINISH_STATE && flush != Z_FINISH)) {
; 966  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  00987	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0N@MKKNPMJD@stream?5error@
  0098e	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00992	b8 fe ff ff ff	 mov	 eax, -2

; 1263 : }

  00997	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0099b	41 5c		 pop	 r12
  0099d	5f		 pop	 rdi
  0099e	c3		 ret	 0
$LN32@deflate:

; 959  :         return Z_STREAM_ERROR;

  0099f	b8 fe ff ff ff	 mov	 eax, -2

; 1263 : }

  009a4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  009a8	41 5c		 pop	 r12
  009aa	5f		 pop	 rdi
  009ab	c3		 ret	 0
deflate	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateEnd
_TEXT	SEGMENT
strm$ = 64
deflateEnd PROC						; COMDAT

; 1266 : int ZEXPORT deflateEnd(z_streamp strm) {

$LN15:
  00000	40 55		 push	 rbp
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b e9	 mov	 rbp, rcx

; 1267 :     int status;
; 1268 : 
; 1269 :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00009	e8 00 00 00 00	 call	 deflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN2@deflateEnd
  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1283 : }

  00017	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001b	5d		 pop	 rbp
  0001c	c3		 ret	 0
$LN2@deflateEnd:

; 1270 : 
; 1271 :     status = strm->state->status;

  0001d	48 8b 45 28	 mov	 rax, QWORD PTR [rbp+40]
  00021	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00026	48 8d 5d 28	 lea	 rbx, QWORD PTR [rbp+40]
  0002a	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 1272 : 
; 1273 :     /* Deallocate in reverse order of allocations: */
; 1274 :     TRY_FREE(strm, strm->state->pending_buf);

  0002f	48 8d 75 40	 lea	 rsi, QWORD PTR [rbp+64]
  00033	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00038	48 8d 7d 38	 lea	 rdi, QWORD PTR [rbp+56]
  0003c	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00040	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00045	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0004a	44 8b 78 08	 mov	 r15d, DWORD PTR [rax+8]
  0004e	48 85 d2	 test	 rdx, rdx
  00051	74 0e		 je	 SHORT $LN8@deflateEnd
  00053	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00056	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00059	ff d0		 call	 rax
  0005b	48 83 c5 28	 add	 rbp, 40			; 00000028H
  0005f	eb 03		 jmp	 SHORT $LN3@deflateEnd
$LN8@deflateEnd:
  00061	48 8b eb	 mov	 rbp, rbx
$LN3@deflateEnd:

; 1275 :     TRY_FREE(strm, strm->state->head);

  00064	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00067	4c 8b f3	 mov	 r14, rbx
  0006a	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  0006e	48 85 d2	 test	 rdx, rdx
  00071	74 0b		 je	 SHORT $LN4@deflateEnd
  00073	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00076	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00079	ff d0		 call	 rax
  0007b	4c 8b f5	 mov	 r14, rbp
$LN4@deflateEnd:

; 1276 :     TRY_FREE(strm, strm->state->prev);

  0007e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00081	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00085	48 85 d2	 test	 rdx, rdx
  00088	74 0b		 je	 SHORT $LN5@deflateEnd
  0008a	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0008d	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00090	ff d0		 call	 rax
  00092	49 8b de	 mov	 rbx, r14
$LN5@deflateEnd:

; 1277 :     TRY_FREE(strm, strm->state->window);

  00095	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00098	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  0009d	48 8b 50 50	 mov	 rdx, QWORD PTR [rax+80]
  000a1	48 85 d2	 test	 rdx, rdx
  000a4	74 08		 je	 SHORT $LN6@deflateEnd
  000a6	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000a9	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000ac	ff d0		 call	 rax
$LN6@deflateEnd:

; 1278 : 
; 1279 :     ZFREE(strm, strm->state);

  000ae	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000b1	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  000b4	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000b7	ff d0		 call	 rax

; 1280 :     strm->state = Z_NULL;
; 1281 : 
; 1282 :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  000b9	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000be	33 c0		 xor	 eax, eax
  000c0	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000c5	41 83 ff 71	 cmp	 r15d, 113		; 00000071H
  000c9	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  000ce	b9 fd ff ff ff	 mov	 ecx, -3
  000d3	48 89 03	 mov	 QWORD PTR [rbx], rax
  000d6	0f 44 c1	 cmove	 eax, ecx
  000d9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1283 : }

  000de	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e2	5d		 pop	 rbp
  000e3	c3		 ret	 0
deflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateInit_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
version$ = 96
stream_size$ = 104
deflateInit_ PROC					; COMDAT

; 372  :                          int stream_size) {

$LN4:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 373  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,

  00004	44 89 4c 24 38	 mov	 DWORD PTR [rsp+56], r9d
  00009	41 b9 0f 00 00
	00		 mov	 r9d, 15
  0000f	4c 89 44 24 30	 mov	 QWORD PTR [rsp+48], r8
  00014	41 b8 08 00 00
	00		 mov	 r8d, 8
  0001a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00022	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  0002a	e8 00 00 00 00	 call	 deflateInit2_

; 374  :                          Z_DEFAULT_STRATEGY, version, stream_size);
; 375  :     /* To do: ignore strm->next_in if we use it as window */
; 376  : }

  0002f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00033	c3		 ret	 0
deflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT slide_hash
_TEXT	SEGMENT
s$ = 8
slide_hash PROC						; COMDAT

; 187  : local void slide_hash(deflate_state *s) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 188  :     unsigned n, m;
; 189  :     Posf *p;
; 190  :     uInt wsize = s->w_size;
; 191  : 
; 192  :     n = s->hash_size;

  00005	44 8b 51 74	 mov	 r10d, DWORD PTR [rcx+116]

; 193  :     p = &s->head[n];

  00009	33 db		 xor	 ebx, ebx
  0000b	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  0000f	44 8b 41 44	 mov	 r8d, DWORD PTR [rcx+68]
  00013	4e 8d 0c 50	 lea	 r9, QWORD PTR [rax+r10*2]
  00017	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@slide_hash:

; 194  :     do {
; 195  :         m = *--p;

  00020	41 0f b7 51 fe	 movzx	 edx, WORD PTR [r9-2]
  00025	4d 8d 49 fe	 lea	 r9, QWORD PTR [r9-2]

; 196  :         *p = (Pos)(m >= wsize ? m - wsize : NIL);

  00029	0f b7 c2	 movzx	 eax, dx
  0002c	66 41 2b c0	 sub	 ax, r8w
  00030	41 3b d0	 cmp	 edx, r8d
  00033	66 0f 42 c3	 cmovb	 ax, bx
  00037	66 41 89 01	 mov	 WORD PTR [r9], ax

; 197  :     } while (--n);

  0003b	41 83 c2 ff	 add	 r10d, -1		; ffffffffH
  0003f	75 df		 jne	 SHORT $LL4@slide_hash

; 198  :     n = wsize;
; 199  : #ifndef FASTEST
; 200  :     p = &s->prev[n];

  00041	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00045	45 8b c8	 mov	 r9d, r8d
  00048	4a 8d 14 40	 lea	 rdx, QWORD PTR [rax+r8*2]
  0004c	0f 1f 40 00	 npad	 4
$LL7@slide_hash:

; 201  :     do {
; 202  :         m = *--p;

  00050	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  00054	48 8d 52 fe	 lea	 rdx, QWORD PTR [rdx-2]

; 203  :         *p = (Pos)(m >= wsize ? m - wsize : NIL);

  00058	0f b7 c1	 movzx	 eax, cx
  0005b	66 41 2b c0	 sub	 ax, r8w
  0005f	41 3b c8	 cmp	 ecx, r8d
  00062	66 0f 42 c3	 cmovb	 ax, bx
  00066	66 89 02	 mov	 WORD PTR [rdx], ax

; 204  :         /* If n is not on any hash chain, prev[n] is garbage but
; 205  :          * its value will never be used.
; 206  :          */
; 207  :     } while (--n);

  00069	41 83 c1 ff	 add	 r9d, -1			; ffffffffH
  0006d	75 e1		 jne	 SHORT $LL7@slide_hash

; 208  : #endif
; 209  : }

  0006f	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00074	c3		 ret	 0
slide_hash ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT read_buf
_TEXT	SEGMENT
strm$ = 48
buf$ = 56
size$ = 64
read_buf PROC						; COMDAT

; 218  : local unsigned read_buf(z_streamp strm, Bytef *buf, unsigned size) {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 219  :     unsigned len = strm->avail_in;

  0000f	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00012	48 8b f2	 mov	 rsi, rdx

; 220  : 
; 221  :     if (len > size) len = size;

  00015	41 3b c0	 cmp	 eax, r8d
  00018	8b f8		 mov	 edi, eax
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	41 0f 47 f8	 cmova	 edi, r8d

; 222  :     if (len == 0) return 0;

  00021	85 ff		 test	 edi, edi
  00023	75 12		 jne	 SHORT $LN3@read_buf
  00025	33 c0		 xor	 eax, eax

; 239  : }

  00027	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
$LN3@read_buf:

; 223  : 
; 224  :     strm->avail_in  -= len;
; 225  : 
; 226  :     zmemcpy(buf, strm->next_in, len);

  00037	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0003a	2b c7		 sub	 eax, edi
  0003c	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  0003f	48 8b ce	 mov	 rcx, rsi
  00042	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00047	44 8b c7	 mov	 r8d, edi
  0004a	8b ef		 mov	 ebp, edi
  0004c	e8 00 00 00 00	 call	 memcpy

; 227  :     if (strm->state->wrap == 1) {

  00051	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00055	8b 48 2c	 mov	 ecx, DWORD PTR [rax+44]
  00058	83 f9 01	 cmp	 ecx, 1
  0005b	75 10		 jne	 SHORT $LN4@read_buf

; 228  :         strm->adler = adler32(strm->adler, buf, len);

  0005d	8b 4b 4c	 mov	 ecx, DWORD PTR [rbx+76]
  00060	44 8b c7	 mov	 r8d, edi
  00063	48 8b d6	 mov	 rdx, rsi
  00066	e8 00 00 00 00	 call	 adler32

; 229  :     }

  0006b	eb 13		 jmp	 SHORT $LN11@read_buf
$LN4@read_buf:

; 230  : #ifdef GZIP
; 231  :     else if (strm->state->wrap == 2) {

  0006d	83 f9 02	 cmp	 ecx, 2
  00070	75 11		 jne	 SHORT $LN6@read_buf

; 232  :         strm->adler = crc32(strm->adler, buf, len);

  00072	8b 4b 4c	 mov	 ecx, DWORD PTR [rbx+76]
  00075	44 8b c7	 mov	 r8d, edi
  00078	48 8b d6	 mov	 rdx, rsi
  0007b	e8 00 00 00 00	 call	 crc32
$LN11@read_buf:

; 233  :     }
; 234  : #endif
; 235  :     strm->next_in  += len;

  00080	89 43 4c	 mov	 DWORD PTR [rbx+76], eax
$LN6@read_buf:
  00083	48 01 2b	 add	 QWORD PTR [rbx], rbp

; 236  :     strm->total_in += len;
; 237  : 
; 238  :     return len;

  00086	8b c7		 mov	 eax, edi
  00088	01 7b 0c	 add	 DWORD PTR [rbx+12], edi

; 239  : }

  0008b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00090	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00095	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
read_buf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT fill_window
_TEXT	SEGMENT
s$ = 96
wsize$1$ = 96
tv677 = 104
fill_window PROC					; COMDAT

; 251  : local void fill_window(deflate_state *s) {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 252  :     unsigned n;
; 253  :     unsigned more;    /* Amount of free space at the end of the window. */
; 254  :     uInt wsize = s->w_size;

  00014	8b 71 44	 mov	 esi, DWORD PTR [rcx+68]
  00017	4c 8d 61 50	 lea	 r12, QWORD PTR [rcx+80]
  0001b	89 74 24 60	 mov	 DWORD PTR wsize$1$[rsp], esi
  0001f	4c 8d b1 08 17
	00 00		 lea	 r14, QWORD PTR [rcx+5896]
  00026	48 8b d9	 mov	 rbx, rcx
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@fill_windo:

; 255  : 
; 256  :     Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
; 257  : 
; 258  :     do {
; 259  :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

  00030	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]
  00036	8b 7b 58	 mov	 edi, DWORD PTR [rbx+88]
  00039	2b bb 9c 00 00
	00		 sub	 edi, DWORD PTR [rbx+156]

; 260  : 
; 261  :         /* Deal with !@#$% 64K limit: */
; 262  :         if (sizeof(int) <= 2) {
; 263  :             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
; 264  :                 more = wsize;
; 265  : 
; 266  :             } else if (more == (unsigned)(-1)) {
; 267  :                 /* Very unlikely, but possible on 16 bit machine if
; 268  :                  * strstart == 0 && lookahead == 1 (input done a byte at time)
; 269  :                  */
; 270  :                 more--;
; 271  :             }
; 272  :         }
; 273  : 
; 274  :         /* If the window is almost full and there is insufficient lookahead,
; 275  :          * move the upper half to the lower one to make room in the upper half.
; 276  :          */
; 277  :         if (s->strstart >= wsize + MAX_DIST(s)) {

  0003f	8b 4b 44	 mov	 ecx, DWORD PTR [rbx+68]
  00042	2b fa		 sub	 edi, edx
  00044	81 c1 fa fe ff
	ff		 add	 ecx, -262		; fffffefaH
  0004a	03 ce		 add	 ecx, esi
  0004c	3b d1		 cmp	 edx, ecx
  0004e	72 40		 jb	 SHORT $LN11@fill_windo

; 278  : 
; 279  :             zmemcpy(s->window, s->window + wsize, (unsigned)wsize - more);

  00050	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  00054	44 8b c6	 mov	 r8d, esi
  00057	8b d6		 mov	 edx, esi
  00059	44 2b c7	 sub	 r8d, edi
  0005c	48 03 d1	 add	 rdx, rcx
  0005f	e8 00 00 00 00	 call	 memcpy

; 280  :             s->match_start -= wsize;
; 281  :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */

  00064	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0006a	29 b3 98 00 00
	00		 sub	 DWORD PTR [rbx+152], esi
  00070	2b c6		 sub	 eax, esi

; 282  :             s->block_start -= (long) wsize;

  00072	29 b3 84 00 00
	00		 sub	 DWORD PTR [rbx+132], esi
  00078	89 83 94 00 00
	00		 mov	 DWORD PTR [rbx+148], eax

; 283  :             if (s->insert > s->strstart)

  0007e	41 39 06	 cmp	 DWORD PTR [r14], eax
  00081	76 03		 jbe	 SHORT $LN12@fill_windo

; 284  :                 s->insert = s->strstart;

  00083	41 89 06	 mov	 DWORD PTR [r14], eax
$LN12@fill_windo:

; 285  :             slide_hash(s);

  00086	48 8b cb	 mov	 rcx, rbx
  00089	e8 00 00 00 00	 call	 slide_hash

; 286  :             more += wsize;

  0008e	03 fe		 add	 edi, esi
$LN11@fill_windo:

; 287  :         }
; 288  :         if (s->strm->avail_in == 0) break;

  00090	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00093	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00097	0f 84 07 01 00
	00		 je	 $LN3@fill_windo

; 289  : 
; 290  :         /* If there was no sliding:
; 291  :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 292  :          *    more == window_size - lookahead - strstart
; 293  :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 294  :          * => more >= window_size - 2*WSIZE + 2
; 295  :          * In the BIG_MEM or MMAP case (not yet supported),
; 296  :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 297  :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 298  :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 299  :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 300  :          */
; 301  :         Assert(more >= 2, "more < 2");
; 302  : 
; 303  :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  0009d	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]
  000a3	44 8b c7	 mov	 r8d, edi
  000a6	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  000ac	48 03 d0	 add	 rdx, rax
  000af	49 03 14 24	 add	 rdx, QWORD PTR [r12]
  000b3	e8 00 00 00 00	 call	 read_buf

; 304  :         s->lookahead += n;

  000b8	44 8b 8b 9c 00
	00 00		 mov	 r9d, DWORD PTR [rbx+156]

; 305  : 
; 306  :         /* Initialize the hash value now that we have some input: */
; 307  :         if (s->lookahead + s->insert >= MIN_MATCH) {

  000bf	45 8b 1e	 mov	 r11d, DWORD PTR [r14]
  000c2	44 03 c8	 add	 r9d, eax
  000c5	44 89 8b 9c 00
	00 00		 mov	 DWORD PTR [rbx+156], r9d
  000cc	43 8d 04 19	 lea	 eax, DWORD PTR [r9+r11]
  000d0	83 f8 03	 cmp	 eax, 3
  000d3	0f 82 b5 00 00
	00		 jb	 $LN2@fill_windo

; 308  :             uInt str = s->strstart - s->insert;

  000d9	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]

; 309  :             s->ins_h = s->window[str];

  000e0	49 8b 14 24	 mov	 rdx, QWORD PTR [r12]
  000e4	45 2b d3	 sub	 r10d, r11d

; 310  :             UPDATE_HASH(s, s->ins_h, s->window[str + 1]);

  000e7	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  000ed	45 0f b6 04 12	 movzx	 r8d, BYTE PTR [r10+rdx]
  000f2	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]
  000f6	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  000fa	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  000fe	41 d3 e0	 shl	 r8d, cl
  00101	41 33 c0	 xor	 eax, r8d
  00104	23 43 7c	 and	 eax, DWORD PTR [rbx+124]
  00107	89 43 70	 mov	 DWORD PTR [rbx+112], eax

; 311  : #if MIN_MATCH != 3
; 312  :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 313  : #endif
; 314  :             while (s->insert) {

  0010a	45 85 db	 test	 r11d, r11d
  0010d	74 7f		 je	 SHORT $LN2@fill_windo

; 308  :             uInt str = s->strstart - s->insert;

  0010f	45 8d 5a 02	 lea	 r11d, DWORD PTR [r10+2]
  00113	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL5@fill_windo:

; 315  :                 UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);

  00120	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  00124	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]

; 316  : #ifndef FASTEST
; 317  :                 s->prev[str & s->w_mask] = s->head[s->ins_h];

  0012a	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0012e	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  00132	45 0f b6 0c 03	 movzx	 r9d, BYTE PTR [r11+rax]

; 318  : #endif
; 319  :                 s->head[s->ins_h] = (Pos)str;
; 320  :                 str++;

  00137	45 8d 5b 01	 lea	 r11d, DWORD PTR [r11+1]
  0013b	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0013e	d3 e0		 shl	 eax, cl
  00140	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00144	44 33 c8	 xor	 r9d, eax
  00147	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  0014b	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  0014f	41 8b c2	 mov	 eax, r10d
  00152	4c 23 c0	 and	 r8, rax
  00155	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  0015a	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  0015f	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00162	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00166	66 44 89 14 48	 mov	 WORD PTR [rax+rcx*2], r10w
  0016b	41 ff c2	 inc	 r10d

; 321  :                 s->insert--;

  0016e	41 8b 0e	 mov	 ecx, DWORD PTR [r14]

; 322  :                 if (s->lookahead + s->insert < MIN_MATCH)

  00171	44 8b 8b 9c 00
	00 00		 mov	 r9d, DWORD PTR [rbx+156]
  00178	ff c9		 dec	 ecx
  0017a	41 89 0e	 mov	 DWORD PTR [r14], ecx
  0017d	42 8d 04 09	 lea	 eax, DWORD PTR [rcx+r9]
  00181	83 f8 03	 cmp	 eax, 3
  00184	72 04		 jb	 SHORT $LN36@fill_windo

; 311  : #if MIN_MATCH != 3
; 312  :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 313  : #endif
; 314  :             while (s->insert) {

  00186	85 c9		 test	 ecx, ecx
  00188	75 96		 jne	 SHORT $LL5@fill_windo
$LN36@fill_windo:
  0018a	8b 74 24 60	 mov	 esi, DWORD PTR wsize$1$[rsp]
$LN2@fill_windo:

; 323  :                     break;
; 324  :             }
; 325  :         }
; 326  :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 327  :          * but this is not important since only literal bytes will be emitted.
; 328  :          */
; 329  : 
; 330  :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  0018e	41 81 f9 06 01
	00 00		 cmp	 r9d, 262		; 00000106H
  00195	73 0d		 jae	 SHORT $LN3@fill_windo
  00197	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0019a	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0019e	0f 85 8c fe ff
	ff		 jne	 $LL4@fill_windo
$LN3@fill_windo:

; 331  : 
; 332  :     /* If the WIN_INIT bytes after the end of the current data have never been
; 333  :      * written, then zero those bytes in order to avoid memory check reports of
; 334  :      * the use of uninitialized (or uninitialised as Julian writes) bytes by
; 335  :      * the longest match routines.  Update the high water mark for the next
; 336  :      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
; 337  :      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
; 338  :      */
; 339  :     if (s->high_water < s->window_size) {

  001a4	8b 93 18 17 00
	00		 mov	 edx, DWORD PTR [rbx+5912]
  001aa	8b 7b 58	 mov	 edi, DWORD PTR [rbx+88]
  001ad	3b d7		 cmp	 edx, edi
  001af	73 67		 jae	 SHORT $LN21@fill_windo

; 340  :         ulg curr = s->strstart + (ulg)(s->lookahead);

  001b1	8b b3 94 00 00
	00		 mov	 esi, DWORD PTR [rbx+148]
  001b7	03 b3 9c 00 00
	00		 add	 esi, DWORD PTR [rbx+156]

; 341  :         ulg init;
; 342  : 
; 343  :         if (s->high_water < curr) {

  001bd	3b d6		 cmp	 edx, esi
  001bf	73 27		 jae	 SHORT $LN18@fill_windo

; 344  :             /* Previous high water mark below current data -- zero WIN_INIT
; 345  :              * bytes or up to end of window, whichever is less.
; 346  :              */
; 347  :             init = s->window_size - curr;

  001c1	2b fe		 sub	 edi, esi

; 348  :             if (init > WIN_INIT)
; 349  :                 init = WIN_INIT;
; 350  :             zmemzero(s->window + curr, (unsigned)init);

  001c3	8b ce		 mov	 ecx, esi
  001c5	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  001ca	3b f8		 cmp	 edi, eax
  001cc	0f 47 f8	 cmova	 edi, eax
  001cf	48 03 4b 50	 add	 rcx, QWORD PTR [rbx+80]
  001d3	44 8b c7	 mov	 r8d, edi
  001d6	33 d2		 xor	 edx, edx
  001d8	e8 00 00 00 00	 call	 memset

; 351  :             s->high_water = curr + init;

  001dd	8d 04 37	 lea	 eax, DWORD PTR [rdi+rsi]
  001e0	89 83 18 17 00
	00		 mov	 DWORD PTR [rbx+5912], eax

; 352  :         }

  001e6	eb 30		 jmp	 SHORT $LN21@fill_windo
$LN18@fill_windo:

; 353  :         else if (s->high_water < (ulg)curr + WIN_INIT) {

  001e8	8d 86 02 01 00
	00		 lea	 eax, DWORD PTR [rsi+258]
  001ee	3b d0		 cmp	 edx, eax
  001f0	73 26		 jae	 SHORT $LN21@fill_windo

; 354  :             /* High water mark at or above current data, but below current data
; 355  :              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
; 356  :              * to end of window, whichever is less.
; 357  :              */
; 358  :             init = (ulg)curr + WIN_INIT - s->high_water;

  001f2	2b fa		 sub	 edi, edx
  001f4	2b f2		 sub	 esi, edx

; 359  :             if (init > s->window_size - s->high_water)
; 360  :                 init = s->window_size - s->high_water;
; 361  :             zmemzero(s->window + s->high_water, (unsigned)init);

  001f6	48 8b ca	 mov	 rcx, rdx
  001f9	8d 86 02 01 00
	00		 lea	 eax, DWORD PTR [rsi+258]
  001ff	3b c7		 cmp	 eax, edi
  00201	0f 46 f8	 cmovbe	 edi, eax
  00204	48 03 4b 50	 add	 rcx, QWORD PTR [rbx+80]
  00208	44 8b c7	 mov	 r8d, edi
  0020b	33 d2		 xor	 edx, edx
  0020d	e8 00 00 00 00	 call	 memset

; 362  :             s->high_water += init;

  00212	01 bb 18 17 00
	00		 add	 DWORD PTR [rbx+5912], edi
$LN21@fill_windo:

; 363  :         }
; 364  :     }
; 365  : 
; 366  :     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
; 367  :            "not enough room for search");
; 368  : }

  00218	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0021d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00221	41 5f		 pop	 r15
  00223	41 5e		 pop	 r14
  00225	41 5d		 pop	 r13
  00227	41 5c		 pop	 r12
  00229	5f		 pop	 rdi
  0022a	5e		 pop	 rsi
  0022b	5d		 pop	 rbp
  0022c	c3		 ret	 0
fill_window ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateInit2_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
method$ = 96
windowBits$ = 104
memLevel$ = 112
strategy$ = 120
version$ = 128
stream_size$ = 136
deflateInit2_ PROC					; COMDAT

; 381  :                           const char *version, int stream_size) {

$LN48:
  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 382  :     deflate_state *s;
; 383  :     int wrap = 1;
; 384  :     static const char my_version[] = ZLIB_VERSION;
; 385  : 
; 386  :     if (version == Z_NULL || version[0] != my_version[0] ||

  0000d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR version$[rsp]
  00015	41 bf 01 00 00
	00		 mov	 r15d, 1
  0001b	44 8b 64 24 78	 mov	 r12d, DWORD PTR strategy$[rsp]
  00020	41 8b f9	 mov	 edi, r9d
  00023	48 8b d9	 mov	 rbx, rcx
  00026	45 8b f7	 mov	 r14d, r15d
  00029	48 85 c0	 test	 rax, rax
  0002c	0f 84 55 02 00
	00		 je	 $LN3@deflateIni
  00032	80 38 31	 cmp	 BYTE PTR [rax], 49	; 00000031H
  00035	0f 85 4c 02 00
	00		 jne	 $LN3@deflateIni
  0003b	83 bc 24 88 00
	00 00 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  00043	0f 85 3e 02 00
	00		 jne	 $LN3@deflateIni

; 389  :     }
; 390  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00049	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0004e	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  00053	48 85 c9	 test	 rcx, rcx
  00056	0f 84 24 02 00
	00		 je	 $LN13@deflateIni

; 391  : 
; 392  :     strm->msg = Z_NULL;

  0005c	33 c9		 xor	 ecx, ecx
  0005e	48 89 4b 20	 mov	 QWORD PTR [rbx+32], rcx

; 393  :     if (strm->zalloc == (alloc_func)0) {

  00062	48 39 4b 30	 cmp	 QWORD PTR [rbx+48], rcx
  00066	75 0f		 jne	 SHORT $LN5@deflateIni

; 394  : #ifdef Z_SOLO
; 395  :         return Z_STREAM_ERROR;
; 396  : #else
; 397  :         strm->zalloc = zcalloc;

  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 398  :         strm->opaque = (voidpf)0;

  0006f	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx
  00073	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
$LN5@deflateIni:

; 399  : #endif
; 400  :     }
; 401  :     if (strm->zfree == (free_func)0)

  00077	48 39 4b 38	 cmp	 QWORD PTR [rbx+56], rcx
  0007b	75 0b		 jne	 SHORT $LN6@deflateIni

; 402  : #ifdef Z_SOLO
; 403  :         return Z_STREAM_ERROR;
; 404  : #else
; 405  :         strm->zfree = zcfree;

  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  00084	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
$LN6@deflateIni:

; 406  : #endif
; 407  : 
; 408  : #ifdef FASTEST
; 409  :     if (level != 0) level = 1;
; 410  : #else
; 411  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;
; 412  : #endif
; 413  : 
; 414  :     if (windowBits < 0) { /* suppress zlib wrapper */

  00088	83 fa ff	 cmp	 edx, -1
  0008b	bd 06 00 00 00	 mov	 ebp, 6
  00090	0f 45 ea	 cmovne	 ebp, edx
  00093	85 ff		 test	 edi, edi
  00095	79 10		 jns	 SHORT $LN8@deflateIni

; 415  :         wrap = 0;

  00097	44 8b f1	 mov	 r14d, ecx

; 416  :         if (windowBits < -15)

  0009a	83 ff f1	 cmp	 edi, -15
  0009d	0f 8c dd 01 00
	00		 jl	 $LN13@deflateIni

; 417  :             return Z_STREAM_ERROR;
; 418  :         windowBits = -windowBits;

  000a3	f7 df		 neg	 edi

; 419  :     }

  000a5	eb 0e		 jmp	 SHORT $LN11@deflateIni
$LN8@deflateIni:

; 420  : #ifdef GZIP
; 421  :     else if (windowBits > 15) {

  000a7	83 ff 0f	 cmp	 edi, 15
  000aa	7e 09		 jle	 SHORT $LN11@deflateIni

; 422  :         wrap = 2;       /* write gzip wrapper instead */

  000ac	41 be 02 00 00
	00		 mov	 r14d, 2

; 423  :         windowBits -= 16;

  000b2	83 ef 10	 sub	 edi, 16
$LN11@deflateIni:

; 424  :     }
; 425  : #endif
; 426  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 427  :         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
; 428  :         strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {

  000b5	44 8b 6c 24 70	 mov	 r13d, DWORD PTR memLevel$[rsp]
  000ba	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  000be	83 f8 08	 cmp	 eax, 8
  000c1	0f 87 b9 01 00
	00		 ja	 $LN13@deflateIni
  000c7	41 83 f8 08	 cmp	 r8d, 8
  000cb	0f 85 af 01 00
	00		 jne	 $LN13@deflateIni
  000d1	8d 47 f8	 lea	 eax, DWORD PTR [rdi-8]
  000d4	83 f8 07	 cmp	 eax, 7
  000d7	0f 87 a3 01 00
	00		 ja	 $LN13@deflateIni
  000dd	83 fd 09	 cmp	 ebp, 9
  000e0	0f 87 9a 01 00
	00		 ja	 $LN13@deflateIni
  000e6	41 83 fc 04	 cmp	 r12d, 4
  000ea	0f 87 90 01 00
	00		 ja	 $LN13@deflateIni
  000f0	41 3b f8	 cmp	 edi, r8d
  000f3	75 0e		 jne	 SHORT $LN14@deflateIni
  000f5	45 3b f7	 cmp	 r14d, r15d
  000f8	0f 85 82 01 00
	00		 jne	 $LN13@deflateIni

; 430  :     }
; 431  :     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */

  000fe	bf 09 00 00 00	 mov	 edi, 9
$LN14@deflateIni:

; 432  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  00103	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00107	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0010d	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00111	41 8b d7	 mov	 edx, r15d
  00114	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00119	ff d0		 call	 rax
  0011b	48 8b f0	 mov	 rsi, rax

; 433  :     if (s == Z_NULL) return Z_MEM_ERROR;

  0011e	48 85 c0	 test	 rax, rax
  00121	0f 84 52 01 00
	00		 je	 $LN46@deflateIni

; 434  :     strm->state = (struct internal_state FAR *)s;

  00127	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 435  :     s->strm = strm;
; 436  :     s->status = INIT_STATE;     /* to pass state test in deflateReset() */
; 437  : 
; 438  :     s->wrap = wrap;
; 439  :     s->gzhead = Z_NULL;
; 440  :     s->w_bits = (uInt)windowBits;
; 441  :     s->w_size = 1 << s->w_bits;

  0012b	8b cf		 mov	 ecx, edi
  0012d	44 89 70 2c	 mov	 DWORD PTR [rax+44], r14d
  00131	45 8b cf	 mov	 r9d, r15d
  00134	48 89 18	 mov	 QWORD PTR [rax], rbx
  00137	45 33 f6	 xor	 r14d, r14d
  0013a	c7 40 08 2a 00
	00 00		 mov	 DWORD PTR [rax+8], 42	; 0000002aH

; 442  :     s->w_mask = s->w_size - 1;
; 443  : 
; 444  :     s->hash_bits = (uInt)memLevel + 7;
; 445  :     s->hash_size = 1 << s->hash_bits;
; 446  :     s->hash_mask = s->hash_size - 1;
; 447  :     s->hash_shift =  ((s->hash_bits + MIN_MATCH-1) / MIN_MATCH);
; 448  : 
; 449  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  00141	41 b8 02 00 00
	00		 mov	 r8d, 2
  00147	4c 89 70 30	 mov	 QWORD PTR [rax+48], r14
  0014b	89 78 48	 mov	 DWORD PTR [rax+72], edi
  0014e	41 d3 e1	 shl	 r9d, cl
  00151	41 8d 4d 07	 lea	 ecx, DWORD PTR [r13+7]
  00155	44 89 48 44	 mov	 DWORD PTR [rax+68], r9d
  00159	89 4e 78	 mov	 DWORD PTR [rsi+120], ecx
  0015c	41 8d 41 ff	 lea	 eax, DWORD PTR [r9-1]
  00160	89 46 4c	 mov	 DWORD PTR [rsi+76], eax
  00163	41 8b c7	 mov	 eax, r15d
  00166	d3 e0		 shl	 eax, cl
  00168	41 8d 4d 09	 lea	 ecx, DWORD PTR [r13+9]
  0016c	89 46 74	 mov	 DWORD PTR [rsi+116], eax
  0016f	ff c8		 dec	 eax
  00171	89 46 7c	 mov	 DWORD PTR [rsi+124], eax
  00174	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00179	f7 e1		 mul	 ecx
  0017b	d1 ea		 shr	 edx, 1
  0017d	89 96 80 00 00
	00		 mov	 DWORD PTR [rsi+128], edx
  00183	41 8b d1	 mov	 edx, r9d
  00186	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0018a	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0018e	ff d0		 call	 rax

; 450  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  00190	8b 56 44	 mov	 edx, DWORD PTR [rsi+68]
  00193	41 b8 02 00 00
	00		 mov	 r8d, 2
  00199	48 89 46 50	 mov	 QWORD PTR [rsi+80], rax
  0019d	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  001a1	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  001a5	ff d0		 call	 rax

; 451  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  001a7	8b 56 74	 mov	 edx, DWORD PTR [rsi+116]
  001aa	41 b8 02 00 00
	00		 mov	 r8d, 2
  001b0	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax
  001b4	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  001b8	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  001bc	ff d0		 call	 rax
  001be	48 89 46 68	 mov	 QWORD PTR [rsi+104], rax

; 452  : 
; 453  :     s->high_water = 0;      /* nothing written to s->window yet */
; 454  : 
; 455  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  001c2	41 8d 4d 06	 lea	 ecx, DWORD PTR [r13+6]
  001c6	41 d3 e7	 shl	 r15d, cl

; 456  : 
; 457  :     /* We overlay pending_buf and sym_buf. This works since the average size
; 458  :      * for length/distance pairs over any compressed block is assured to be 31
; 459  :      * bits or less.
; 460  :      *
; 461  :      * Analysis: The longest fixed codes are a length code of 8 bits plus 5
; 462  :      * extra bits, for lengths 131 to 257. The longest fixed distance codes are
; 463  :      * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
; 464  :      * possible fixed-codes length/distance pair is then 31 bits total.
; 465  :      *
; 466  :      * sym_buf starts one-fourth of the way into pending_buf. So there are
; 467  :      * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
; 468  :      * in sym_buf is three bytes -- two for the distance and one for the
; 469  :      * literal/length. As each symbol is consumed, the pointer to the next
; 470  :      * sym_buf value to read moves forward three bytes. From that symbol, up to
; 471  :      * 31 bits are written to pending_buf. The closest the written pending_buf
; 472  :      * bits gets to the next sym_buf symbol to read is just before the last
; 473  :      * code is written. At that time, 31*(n - 2) bits have been written, just
; 474  :      * after 24*(n - 2) bits have been consumed from sym_buf. sym_buf starts at
; 475  :      * 8*n bits into pending_buf. (Note that the symbol buffer fills when n - 1
; 476  :      * symbols are written.) The closest the writing gets to what is unread is
; 477  :      * then n + 14 bits. Here n is lit_bufsize, which is 16384 by default, and
; 478  :      * can range from 128 to 32768.
; 479  :      *
; 480  :      * Therefore, at a minimum, there are 142 bits of space between what is
; 481  :      * written and what is read in the overlain buffers, so the symbols cannot
; 482  :      * be overwritten by the compressed data. That space is actually 139 bits,
; 483  :      * due to the three-bit fixed-code block header.
; 484  :      *
; 485  :      * That covers the case where either Z_FIXED is specified, forcing fixed
; 486  :      * codes, or when the use of fixed codes is chosen, because that choice
; 487  :      * results in a smaller compressed block than dynamic codes. That latter
; 488  :      * condition then assures that the above analysis also covers all dynamic
; 489  :      * blocks. A dynamic-code block will only be chosen to be emitted if it has
; 490  :      * fewer bits than a fixed-code block would for the same set of symbols.
; 491  :      * Therefore its average symbol length is assured to be less than 31. So
; 492  :      * the compressed data for a dynamic block also cannot overwrite the
; 493  :      * symbols from which it is being constructed.
; 494  :      */
; 495  : 
; 496  :     s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, LIT_BUFS);

  001c9	41 b8 04 00 00
	00		 mov	 r8d, 4
  001cf	44 89 be f0 16
	00 00		 mov	 DWORD PTR [rsi+5872], r15d
  001d6	41 8b d7	 mov	 edx, r15d
  001d9	44 89 b6 18 17
	00 00		 mov	 DWORD PTR [rsi+5912], r14d
  001e0	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  001e4	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  001e8	ff d0		 call	 rax

; 497  :     s->pending_buf_size = (ulg)s->lit_bufsize * 4;

  001ea	8b 96 f0 16 00
	00		 mov	 edx, DWORD PTR [rsi+5872]
  001f0	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
  001f4	8d 0c 95 00 00
	00 00		 lea	 ecx, DWORD PTR [rdx*4]
  001fb	89 4e 18	 mov	 DWORD PTR [rsi+24], ecx

; 498  : 
; 499  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||

  001fe	4c 39 76 50	 cmp	 QWORD PTR [rsi+80], r14
  00202	74 5b		 je	 SHORT $LN17@deflateIni
  00204	4c 39 76 60	 cmp	 QWORD PTR [rsi+96], r14
  00208	74 55		 je	 SHORT $LN17@deflateIni
  0020a	4c 39 76 68	 cmp	 QWORD PTR [rsi+104], r14
  0020e	74 4f		 je	 SHORT $LN17@deflateIni
  00210	48 85 c0	 test	 rax, rax
  00213	74 4a		 je	 SHORT $LN17@deflateIni

; 505  :     }
; 506  : #ifdef LIT_MEM
; 507  :     s->d_buf = (ushf *)(s->pending_buf + (s->lit_bufsize << 1));
; 508  :     s->l_buf = s->pending_buf + (s->lit_bufsize << 2);
; 509  :     s->sym_end = s->lit_bufsize - 1;
; 510  : #else
; 511  :     s->sym_buf = s->pending_buf + s->lit_bufsize;

  00215	48 03 c2	 add	 rax, rdx

; 512  :     s->sym_end = (s->lit_bufsize - 1) * 3;
; 513  : #endif
; 514  :     /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
; 515  :      * on 16 bit machines and because stored blocks are restricted to
; 516  :      * 64K-1 bytes.
; 517  :      */
; 518  : 
; 519  :     s->level = level;

  00218	89 ae ac 00 00
	00		 mov	 DWORD PTR [rsi+172], ebp
  0021e	ff ca		 dec	 edx
  00220	48 89 86 e8 16
	00 00		 mov	 QWORD PTR [rsi+5864], rax

; 520  :     s->strategy = strategy;
; 521  :     s->method = (Byte)method;
; 522  : 
; 523  :     return deflateReset(strm);

  00227	48 8b cb	 mov	 rcx, rbx
  0022a	44 89 a6 b0 00
	00 00		 mov	 DWORD PTR [rsi+176], r12d
  00231	c6 46 3c 08	 mov	 BYTE PTR [rsi+60], 8
  00235	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00238	89 86 f8 16 00
	00		 mov	 DWORD PTR [rsi+5880], eax
  0023e	e8 00 00 00 00	 call	 deflateReset
$LN45@deflateIni:
  00243	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
$LN44@deflateIni:
  00248	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0024d	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]

; 524  : }

  00252	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00256	41 5f		 pop	 r15
  00258	41 5e		 pop	 r14
  0025a	41 5c		 pop	 r12
  0025c	5f		 pop	 rdi
  0025d	5b		 pop	 rbx
  0025e	c3		 ret	 0
$LN17@deflateIni:

; 500  :         s->pending_buf == Z_NULL) {
; 501  :         s->status = FINISH_STATE;
; 502  :         strm->msg = ERR_MSG(Z_MEM_ERROR);

  0025f	48 8b 05 30 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+48

; 503  :         deflateEnd (strm);

  00266	48 8b cb	 mov	 rcx, rbx
  00269	c7 46 08 9a 02
	00 00		 mov	 DWORD PTR [rsi+8], 666	; 0000029aH
  00270	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00274	e8 00 00 00 00	 call	 deflateEnd
$LN46@deflateIni:

; 504  :         return Z_MEM_ERROR;

  00279	b8 fc ff ff ff	 mov	 eax, -4
  0027e	eb c3		 jmp	 SHORT $LN45@deflateIni
$LN13@deflateIni:

; 429  :         return Z_STREAM_ERROR;

  00280	b8 fe ff ff ff	 mov	 eax, -2
  00285	eb c1		 jmp	 SHORT $LN44@deflateIni
$LN3@deflateIni:

; 387  :         stream_size != sizeof(z_stream)) {
; 388  :         return Z_VERSION_ERROR;

  00287	b8 fa ff ff ff	 mov	 eax, -6

; 524  : }

  0028c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00290	41 5f		 pop	 r15
  00292	41 5e		 pop	 r14
  00294	41 5c		 pop	 r12
  00296	5f		 pop	 rdi
  00297	5b		 pop	 rbx
  00298	c3		 ret	 0
deflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateStateCheck
_TEXT	SEGMENT
strm$ = 8
deflateStateCheck PROC					; COMDAT

; 530  :     deflate_state *s;
; 531  :     if (strm == Z_NULL ||
; 532  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 47		 je	 SHORT $LN3@deflateSta
  00005	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  0000a	74 40		 je	 SHORT $LN3@deflateSta
  0000c	48 83 79 38 00	 cmp	 QWORD PTR [rcx+56], 0
  00011	74 39		 je	 SHORT $LN3@deflateSta

; 534  :     s = strm->state;

  00013	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 535  :     if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&

  00017	48 85 c0	 test	 rax, rax
  0001a	74 30		 je	 SHORT $LN3@deflateSta
  0001c	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001f	75 2b		 jne	 SHORT $LN3@deflateSta
  00021	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00024	83 f9 2a	 cmp	 ecx, 42			; 0000002aH
  00027	74 20		 je	 SHORT $LN4@deflateSta
  00029	8d 41 c7	 lea	 eax, DWORD PTR [rcx-57]
  0002c	83 f8 38	 cmp	 eax, 56			; 00000038H
  0002f	77 10		 ja	 SHORT $LN7@deflateSta
  00031	48 ba 01 10 01
	00 04 40 00 01	 mov	 rdx, 72127979962044417	; 0100400400011001H
  0003b	48 0f a3 c2	 bt	 rdx, rax
  0003f	72 08		 jb	 SHORT $LN4@deflateSta
$LN7@deflateSta:
  00041	81 f9 9a 02 00
	00		 cmp	 ecx, 666		; 0000029aH
  00047	75 03		 jne	 SHORT $LN3@deflateSta
$LN4@deflateSta:

; 536  : #ifdef GZIP
; 537  :                                            s->status != GZIP_STATE &&
; 538  : #endif
; 539  :                                            s->status != EXTRA_STATE &&
; 540  :                                            s->status != NAME_STATE &&
; 541  :                                            s->status != COMMENT_STATE &&
; 542  :                                            s->status != HCRC_STATE &&
; 543  :                                            s->status != BUSY_STATE &&
; 544  :                                            s->status != FINISH_STATE))
; 545  :         return 1;
; 546  :     return 0;

  00049	33 c0		 xor	 eax, eax

; 547  : }

  0004b	c3		 ret	 0
$LN3@deflateSta:

; 533  :         return 1;

  0004c	b8 01 00 00 00	 mov	 eax, 1

; 547  : }

  00051	c3		 ret	 0
deflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateSetDictionary
_TEXT	SEGMENT
strm$ = 80
dictionary$ = 88
dictLength$ = 96
deflateSetDictionary PROC				; COMDAT

; 551  :                                  uInt  dictLength) {

$LN43:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 56		 push	 r14
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	41 8b f8	 mov	 edi, r8d
  0000e	48 8b ea	 mov	 rbp, rdx
  00011	48 8b f1	 mov	 rsi, rcx

; 552  :     deflate_state *s;
; 553  :     uInt str, n;
; 554  :     int wrap;
; 555  :     unsigned avail;
; 556  :     z_const unsigned char *next;
; 557  : 
; 558  :     if (deflateStateCheck(strm) || dictionary == Z_NULL)

  00014	e8 00 00 00 00	 call	 deflateStateCheck
  00019	85 c0		 test	 eax, eax
  0001b	0f 85 cb 01 00
	00		 jne	 $LN11@deflateSet
  00021	48 85 ed	 test	 rbp, rbp
  00024	0f 84 c2 01 00
	00		 je	 $LN11@deflateSet

; 560  :     s = strm->state;

  0002a	48 8b 5e 28	 mov	 rbx, QWORD PTR [rsi+40]

; 561  :     wrap = s->wrap;

  0002e	44 8b 73 2c	 mov	 r14d, DWORD PTR [rbx+44]

; 562  :     if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)

  00032	41 83 fe 02	 cmp	 r14d, 2
  00036	0f 84 b0 01 00
	00		 je	 $LN11@deflateSet
  0003c	41 83 fe 01	 cmp	 r14d, 1
  00040	75 0a		 jne	 SHORT $LN14@deflateSet
  00042	83 7b 08 2a	 cmp	 DWORD PTR [rbx+8], 42	; 0000002aH
  00046	0f 85 a0 01 00
	00		 jne	 $LN11@deflateSet
$LN14@deflateSet:
  0004c	83 bb 9c 00 00
	00 00		 cmp	 DWORD PTR [rbx+156], 0
  00053	0f 85 93 01 00
	00		 jne	 $LN11@deflateSet
  00059	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  0005e	4c 89 6c 24 58	 mov	 QWORD PTR [rsp+88], r13
  00063	4c 89 7c 24 60	 mov	 QWORD PTR [rsp+96], r15

; 563  :         return Z_STREAM_ERROR;
; 564  : 
; 565  :     /* when using zlib wrappers, compute Adler-32 for provided dictionary */
; 566  :     if (wrap == 1)

  00068	41 83 fe 01	 cmp	 r14d, 1
  0006c	75 0e		 jne	 SHORT $LN15@deflateSet

; 567  :         strm->adler = adler32(strm->adler, dictionary, dictLength);

  0006e	8b 4e 4c	 mov	 ecx, DWORD PTR [rsi+76]
  00071	48 8b d5	 mov	 rdx, rbp
  00074	e8 00 00 00 00	 call	 adler32
  00079	89 46 4c	 mov	 DWORD PTR [rsi+76], eax
$LN15@deflateSet:

; 568  :     s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */

  0007c	45 33 ed	 xor	 r13d, r13d
  0007f	44 89 6b 2c	 mov	 DWORD PTR [rbx+44], r13d

; 569  : 
; 570  :     /* if dictionary would fill window, just replace the history */
; 571  :     if (dictLength >= s->w_size) {

  00083	3b 7b 44	 cmp	 edi, DWORD PTR [rbx+68]
  00086	72 48		 jb	 SHORT $LN16@deflateSet

; 572  :         if (wrap == 0) {            /* already empty otherwise */

  00088	45 85 f6	 test	 r14d, r14d
  0008b	75 38		 jne	 SHORT $LN31@deflateSet

; 573  :             CLEAR_HASH(s);

  0008d	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  00090	33 d2		 xor	 edx, edx
  00092	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00096	ff c9		 dec	 ecx
  00098	66 44 89 2c 48	 mov	 WORD PTR [rax+rcx*2], r13w
  0009d	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  000a1	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  000a5	41 ff c8	 dec	 r8d
  000a8	4d 03 c0	 add	 r8, r8
  000ab	e8 00 00 00 00	 call	 memset

; 574  :             s->strstart = 0;

  000b0	44 89 ab 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r13d

; 575  :             s->block_start = 0L;

  000b7	44 89 ab 84 00
	00 00		 mov	 DWORD PTR [rbx+132], r13d

; 576  :             s->insert = 0;

  000be	44 89 ab 08 17
	00 00		 mov	 DWORD PTR [rbx+5896], r13d
$LN31@deflateSet:

; 577  :         }
; 578  :         dictionary += dictLength - s->w_size;  /* use the tail */

  000c5	2b 7b 44	 sub	 edi, DWORD PTR [rbx+68]
  000c8	8b c7		 mov	 eax, edi

; 579  :         dictLength = s->w_size;

  000ca	8b 7b 44	 mov	 edi, DWORD PTR [rbx+68]
  000cd	48 03 e8	 add	 rbp, rax
$LN16@deflateSet:

; 580  :     }
; 581  : 
; 582  :     /* insert dictionary into window and hash */
; 583  :     avail = strm->avail_in;

  000d0	44 8b 7e 08	 mov	 r15d, DWORD PTR [rsi+8]

; 584  :     next = strm->next_in;
; 585  :     strm->avail_in = dictLength;
; 586  :     strm->next_in = (z_const Bytef *)dictionary;
; 587  :     fill_window(s);

  000d4	48 8b cb	 mov	 rcx, rbx
  000d7	4c 8b 26	 mov	 r12, QWORD PTR [rsi]
  000da	89 7e 08	 mov	 DWORD PTR [rsi+8], edi
  000dd	48 89 2e	 mov	 QWORD PTR [rsi], rbp
  000e0	e8 00 00 00 00	 call	 fill_window

; 588  :     while (s->lookahead >= MIN_MATCH) {

  000e5	8b 8b 9c 00 00
	00		 mov	 ecx, DWORD PTR [rbx+156]
  000eb	83 f9 03	 cmp	 ecx, 3
  000ee	0f 82 97 00 00
	00		 jb	 $LN6@deflateSet
  000f4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL5@deflateSet:

; 589  :         str = s->strstart;

  00100	44 8b 93 94 00
	00 00		 mov	 r10d, DWORD PTR [rbx+148]

; 590  :         n = s->lookahead - (MIN_MATCH-1);

  00107	8d 79 fe	 lea	 edi, DWORD PTR [rcx-2]
  0010a	45 8d 5a 02	 lea	 r11d, DWORD PTR [r10+2]
  0010e	66 90		 npad	 2
$LL9@deflateSet:

; 591  :         do {
; 592  :             UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);

  00110	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00114	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]

; 593  : #ifndef FASTEST
; 594  :             s->prev[str & s->w_mask] = s->head[s->ins_h];

  0011a	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0011e	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  00122	45 0f b6 0c 03	 movzx	 r9d, BYTE PTR [r11+rax]

; 595  : #endif
; 596  :             s->head[s->ins_h] = (Pos)str;
; 597  :             str++;

  00127	45 8d 5b 01	 lea	 r11d, DWORD PTR [r11+1]
  0012b	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0012e	d3 e0		 shl	 eax, cl
  00130	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00134	44 33 c8	 xor	 r9d, eax
  00137	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  0013b	41 8b c2	 mov	 eax, r10d
  0013e	4c 23 c0	 and	 r8, rax
  00141	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  00145	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  0014a	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  0014f	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00152	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00156	66 44 89 14 48	 mov	 WORD PTR [rax+rcx*2], r10w
  0015b	41 ff c2	 inc	 r10d

; 598  :         } while (--n);

  0015e	83 c7 ff	 add	 edi, -1			; ffffffffH
  00161	75 ad		 jne	 SHORT $LL9@deflateSet

; 599  :         s->strstart = str;
; 600  :         s->lookahead = MIN_MATCH-1;
; 601  :         fill_window(s);

  00163	48 8b cb	 mov	 rcx, rbx
  00166	44 89 93 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r10d
  0016d	c7 83 9c 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+156], 2
  00177	e8 00 00 00 00	 call	 fill_window
  0017c	8b 8b 9c 00 00
	00		 mov	 ecx, DWORD PTR [rbx+156]
  00182	83 f9 03	 cmp	 ecx, 3
  00185	0f 83 75 ff ff
	ff		 jae	 $LL5@deflateSet
$LN6@deflateSet:

; 602  :     }
; 603  :     s->strstart += s->lookahead;

  0018b	01 8b 94 00 00
	00		 add	 DWORD PTR [rbx+148], ecx
  00191	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]

; 604  :     s->block_start = (long)s->strstart;

  00197	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax

; 605  :     s->insert = s->lookahead;
; 606  :     s->lookahead = 0;
; 607  :     s->match_length = s->prev_length = MIN_MATCH-1;
; 608  :     s->match_available = 0;
; 609  :     strm->next_in = next;
; 610  :     strm->avail_in = avail;
; 611  :     s->wrap = wrap;
; 612  :     return Z_OK;

  0019d	33 c0		 xor	 eax, eax
  0019f	44 89 ab 9c 00
	00 00		 mov	 DWORD PTR [rbx+156], r13d
  001a6	44 89 ab 90 00
	00 00		 mov	 DWORD PTR [rbx+144], r13d
  001ad	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]
  001b2	89 8b 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], ecx
  001b8	c7 83 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+160], 2
  001c2	c7 83 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+136], 2
  001cc	4c 89 26	 mov	 QWORD PTR [rsi], r12
  001cf	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  001d4	44 89 7e 08	 mov	 DWORD PTR [rsi+8], r15d
  001d8	4c 8b 7c 24 60	 mov	 r15, QWORD PTR [rsp+96]
  001dd	44 89 73 2c	 mov	 DWORD PTR [rbx+44], r14d

; 613  : }

  001e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001e5	41 5e		 pop	 r14
  001e7	5f		 pop	 rdi
  001e8	5e		 pop	 rsi
  001e9	5d		 pop	 rbp
  001ea	5b		 pop	 rbx
  001eb	c3		 ret	 0
$LN11@deflateSet:

; 559  :         return Z_STREAM_ERROR;

  001ec	b8 fe ff ff ff	 mov	 eax, -2

; 613  : }

  001f1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001f5	41 5e		 pop	 r14
  001f7	5f		 pop	 rdi
  001f8	5e		 pop	 rsi
  001f9	5d		 pop	 rbp
  001fa	5b		 pop	 rbx
  001fb	c3		 ret	 0
deflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateGetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
deflateGetDictionary PROC				; COMDAT

; 617  :                                  uInt *dictLength) {

$LN12:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b f8	 mov	 rdi, r8
  00009	4c 8b ca	 mov	 r9, rdx
  0000c	4c 8b c1	 mov	 r8, rcx

; 618  :     deflate_state *s;
; 619  :     uInt len;
; 620  : 
; 621  :     if (deflateStateCheck(strm))

  0000f	e8 00 00 00 00	 call	 deflateStateCheck
  00014	85 c0		 test	 eax, eax
  00016	74 0b		 je	 SHORT $LN2@deflateGet

; 622  :         return Z_STREAM_ERROR;

  00018	b8 fe ff ff ff	 mov	 eax, -2

; 632  : }

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5f		 pop	 rdi
  00022	c3		 ret	 0
$LN2@deflateGet:

; 623  :     s = strm->state;

  00023	49 8b 50 28	 mov	 rdx, QWORD PTR [r8+40]
  00027	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 624  :     len = s->strstart + s->lookahead;
; 625  :     if (len > s->w_size)

  0002c	8b 5a 44	 mov	 ebx, DWORD PTR [rdx+68]
  0002f	8b 8a 94 00 00
	00		 mov	 ecx, DWORD PTR [rdx+148]
  00035	44 8b 92 9c 00
	00 00		 mov	 r10d, DWORD PTR [rdx+156]
  0003c	41 8d 04 0a	 lea	 eax, DWORD PTR [r10+rcx]

; 626  :         len = s->w_size;
; 627  :     if (dictionary != Z_NULL && len)

  00040	3b c3		 cmp	 eax, ebx
  00042	0f 46 d8	 cmovbe	 ebx, eax
  00045	4d 85 c9	 test	 r9, r9
  00048	74 1c		 je	 SHORT $LN4@deflateGet
  0004a	85 db		 test	 ebx, ebx
  0004c	74 18		 je	 SHORT $LN4@deflateGet

; 628  :         zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);

  0004e	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  00052	44 8b c3	 mov	 r8d, ebx
  00055	49 2b d0	 sub	 rdx, r8
  00058	49 03 d2	 add	 rdx, r10
  0005b	48 03 d1	 add	 rdx, rcx
  0005e	49 8b c9	 mov	 rcx, r9
  00061	e8 00 00 00 00	 call	 memcpy
$LN4@deflateGet:

; 629  :     if (dictLength != Z_NULL)

  00066	48 85 ff	 test	 rdi, rdi
  00069	74 02		 je	 SHORT $LN5@deflateGet

; 630  :         *dictLength = len;

  0006b	89 1f		 mov	 DWORD PTR [rdi], ebx
$LN5@deflateGet:

; 631  :     return Z_OK;

  0006d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00072	33 c0		 xor	 eax, eax

; 632  : }

  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
deflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateResetKeep
_TEXT	SEGMENT
strm$ = 48
deflateResetKeep PROC					; COMDAT

; 635  : int ZEXPORT deflateResetKeep(z_streamp strm) {

$LN11:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f9	 mov	 rdi, rcx

; 636  :     deflate_state *s;
; 637  : 
; 638  :     if (deflateStateCheck(strm)) {

  00009	e8 00 00 00 00	 call	 deflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN2@deflateRes

; 639  :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2

; 668  : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
$LN2@deflateRes:

; 640  :     }
; 641  : 
; 642  :     strm->total_in = strm->total_out = 0;

  0001d	33 c0		 xor	 eax, eax

; 643  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
; 644  :     strm->data_type = Z_UNKNOWN;

  0001f	c7 47 48 02 00
	00 00		 mov	 DWORD PTR [rdi+72], 2
  00026	89 47 1c	 mov	 DWORD PTR [rdi+28], eax
  00029	89 47 0c	 mov	 DWORD PTR [rdi+12], eax
  0002c	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
  00030	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 645  : 
; 646  :     s = (deflate_state *)strm->state;

  00035	48 8b 5f 28	 mov	 rbx, QWORD PTR [rdi+40]

; 647  :     s->pending = 0;
; 648  :     s->pending_out = s->pending_buf;
; 649  : 
; 650  :     if (s->wrap < 0) {

  00039	8b 4b 2c	 mov	 ecx, DWORD PTR [rbx+44]
  0003c	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  0003f	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00043	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00047	85 c9		 test	 ecx, ecx
  00049	79 05		 jns	 SHORT $LN3@deflateRes

; 651  :         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */

  0004b	f7 d9		 neg	 ecx
  0004d	89 4b 2c	 mov	 DWORD PTR [rbx+44], ecx
$LN3@deflateRes:

; 652  :     }
; 653  :     s->status =

  00050	83 f9 02	 cmp	 ecx, 2
  00053	b8 2a 00 00 00	 mov	 eax, 42			; 0000002aH
  00058	ba 39 00 00 00	 mov	 edx, 57			; 00000039H
  0005d	0f 44 c2	 cmove	 eax, edx
  00060	89 43 08	 mov	 DWORD PTR [rbx+8], eax

; 654  : #ifdef GZIP
; 655  :         s->wrap == 2 ? GZIP_STATE :
; 656  : #endif
; 657  :         INIT_STATE;
; 658  :     strm->adler =

  00063	75 0e		 jne	 SHORT $LN5@deflateRes
  00065	45 33 c0	 xor	 r8d, r8d
  00068	33 d2		 xor	 edx, edx
  0006a	33 c9		 xor	 ecx, ecx
  0006c	e8 00 00 00 00	 call	 crc32
  00071	eb 0c		 jmp	 SHORT $LN6@deflateRes
$LN5@deflateRes:
  00073	45 33 c0	 xor	 r8d, r8d
  00076	33 d2		 xor	 edx, edx
  00078	33 c9		 xor	 ecx, ecx
  0007a	e8 00 00 00 00	 call	 adler32
$LN6@deflateRes:
  0007f	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 659  : #ifdef GZIP
; 660  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 661  : #endif
; 662  :         adler32(0L, Z_NULL, 0);
; 663  :     s->last_flush = -2;
; 664  : 
; 665  :     _tr_init(s);

  00082	48 8b cb	 mov	 rcx, rbx
  00085	c7 43 40 fe ff
	ff ff		 mov	 DWORD PTR [rbx+64], -2
  0008c	e8 00 00 00 00	 call	 _tr_init

; 666  : 
; 667  :     return Z_OK;

  00091	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00096	33 c0		 xor	 eax, eax

; 668  : }

  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
deflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT lm_init
_TEXT	SEGMENT
s$ = 48
lm_init	PROC						; COMDAT

; 673  : local void lm_init(deflate_state *s) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 674  :     s->window_size = (ulg)2L*s->w_size;

  0000a	8b 41 44	 mov	 eax, DWORD PTR [rcx+68]
  0000d	48 8b d9	 mov	 rbx, rcx

; 675  : 
; 676  :     CLEAR_HASH(s);

  00010	8b 51 74	 mov	 edx, DWORD PTR [rcx+116]
  00013	03 c0		 add	 eax, eax
  00015	89 41 58	 mov	 DWORD PTR [rcx+88], eax
  00018	ff ca		 dec	 edx
  0001a	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  0001e	33 ff		 xor	 edi, edi
  00020	66 89 3c 50	 mov	 WORD PTR [rax+rdx*2], di
  00024	33 d2		 xor	 edx, edx
  00026	44 8b 41 74	 mov	 r8d, DWORD PTR [rcx+116]
  0002a	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0002e	41 ff c8	 dec	 r8d
  00031	4d 03 c0	 add	 r8, r8
  00034	e8 00 00 00 00	 call	 memset

; 677  : 
; 678  :     /* Set the default configuration parameters:
; 679  :      */
; 680  :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  00039	48 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rbx+172]
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:configuration_table
  00047	48 03 c9	 add	 rcx, rcx
  0004a	0f b7 44 ca 02	 movzx	 eax, WORD PTR [rdx+rcx*8+2]
  0004f	89 83 a8 00 00
	00		 mov	 DWORD PTR [rbx+168], eax

; 681  :     s->good_match       = configuration_table[s->level].good_length;

  00055	0f b7 04 ca	 movzx	 eax, WORD PTR [rdx+rcx*8]
  00059	89 83 b4 00 00
	00		 mov	 DWORD PTR [rbx+180], eax

; 682  :     s->nice_match       = configuration_table[s->level].nice_length;

  0005f	0f b7 44 ca 04	 movzx	 eax, WORD PTR [rdx+rcx*8+4]
  00064	89 83 b8 00 00
	00		 mov	 DWORD PTR [rbx+184], eax

; 683  :     s->max_chain_length = configuration_table[s->level].max_chain;

  0006a	0f b7 44 ca 06	 movzx	 eax, WORD PTR [rdx+rcx*8+6]
  0006f	89 83 a4 00 00
	00		 mov	 DWORD PTR [rbx+164], eax

; 684  : 
; 685  :     s->strstart = 0;
; 686  :     s->block_start = 0L;
; 687  :     s->lookahead = 0;
; 688  :     s->insert = 0;
; 689  :     s->match_length = s->prev_length = MIN_MATCH-1;
; 690  :     s->match_available = 0;

  00075	48 89 bb 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rdi
  0007c	89 bb 84 00 00
	00		 mov	 DWORD PTR [rbx+132], edi
  00082	89 bb 9c 00 00
	00		 mov	 DWORD PTR [rbx+156], edi
  00088	89 bb 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], edi
  0008e	c7 83 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+160], 2
  00098	c7 83 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+136], 2

; 691  :     s->ins_h = 0;

  000a2	89 7b 70	 mov	 DWORD PTR [rbx+112], edi

; 692  : }

  000a5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
lm_init	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateReset
_TEXT	SEGMENT
strm$ = 48
deflateReset PROC					; COMDAT

; 695  : int ZEXPORT deflateReset(z_streamp strm) {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 696  :     int ret;
; 697  : 
; 698  :     ret = deflateResetKeep(strm);

  0000d	e8 00 00 00 00	 call	 deflateResetKeep
  00012	8b d8		 mov	 ebx, eax

; 699  :     if (ret == Z_OK)

  00014	85 c0		 test	 eax, eax
  00016	75 0b		 jne	 SHORT $LN2@deflateRes

; 700  :         lm_init(strm->state);

  00018	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  0001c	e8 00 00 00 00	 call	 lm_init

; 701  :     return ret;

  00021	8b c3		 mov	 eax, ebx
$LN2@deflateRes:

; 702  : }

  00023	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
deflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateSetHeader
_TEXT	SEGMENT
strm$ = 48
head$ = 56
deflateSetHeader PROC					; COMDAT

; 705  : int ZEXPORT deflateSetHeader(z_streamp strm, gz_headerp head) {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b ca	 mov	 r9, rdx
  00007	4c 8b c1	 mov	 r8, rcx

; 706  :     if (deflateStateCheck(strm) || strm->state->wrap != 2)

  0000a	e8 00 00 00 00	 call	 deflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	75 15		 jne	 SHORT $LN3@deflateSet
  00013	49 8b 40 28	 mov	 rax, QWORD PTR [r8+40]
  00017	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  0001b	75 0b		 jne	 SHORT $LN3@deflateSet

; 708  :     strm->state->gzhead = head;

  0001d	4c 89 48 30	 mov	 QWORD PTR [rax+48], r9

; 709  :     return Z_OK;

  00021	33 c0		 xor	 eax, eax

; 710  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
$LN3@deflateSet:

; 707  :         return Z_STREAM_ERROR;

  00028	b8 fe ff ff ff	 mov	 eax, -2

; 710  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
deflateSetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflatePending
_TEXT	SEGMENT
strm$ = 48
pending$ = 56
bits$ = 64
deflatePending PROC					; COMDAT

; 713  : int ZEXPORT deflatePending(z_streamp strm, unsigned *pending, int *bits) {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b ca	 mov	 r9, rdx
  00007	4c 8b d1	 mov	 r10, rcx

; 714  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  0000a	e8 00 00 00 00	 call	 deflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	74 0a		 je	 SHORT $LN2@deflatePen
  00013	b8 fe ff ff ff	 mov	 eax, -2

; 720  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
$LN2@deflatePen:

; 715  :     if (pending != Z_NULL)

  0001d	4d 85 c9	 test	 r9, r9
  00020	74 0a		 je	 SHORT $LN6@deflatePen

; 716  :         *pending = strm->state->pending;

  00022	49 8b 42 28	 mov	 rax, QWORD PTR [r10+40]
  00026	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00029	41 89 09	 mov	 DWORD PTR [r9], ecx
$LN6@deflatePen:

; 717  :     if (bits != Z_NULL)

  0002c	4d 85 c0	 test	 r8, r8
  0002f	74 0d		 je	 SHORT $LN4@deflatePen

; 718  :         *bits = strm->state->bi_valid;

  00031	49 8b 42 28	 mov	 rax, QWORD PTR [r10+40]
  00035	8b 88 10 17 00
	00		 mov	 ecx, DWORD PTR [rax+5904]
  0003b	41 89 08	 mov	 DWORD PTR [r8], ecx
$LN4@deflatePen:

; 719  :     return Z_OK;

  0003e	33 c0		 xor	 eax, eax

; 720  : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
deflatePending ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateUsed
_TEXT	SEGMENT
strm$ = 48
bits$ = 56
deflateUsed PROC					; COMDAT

; 723  : int ZEXPORT deflateUsed(z_streamp strm, int *bits) {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c2	 mov	 r8, rdx
  00007	4c 8b c9	 mov	 r9, rcx

; 724  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  0000a	e8 00 00 00 00	 call	 deflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	74 0a		 je	 SHORT $LN2@deflateUse
  00013	b8 fe ff ff ff	 mov	 eax, -2

; 728  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
$LN2@deflateUse:

; 725  :     if (bits != Z_NULL)

  0001d	4d 85 c0	 test	 r8, r8
  00020	74 0d		 je	 SHORT $LN3@deflateUse

; 726  :         *bits = strm->state->bi_used;

  00022	49 8b 41 28	 mov	 rax, QWORD PTR [r9+40]
  00026	8b 88 14 17 00
	00		 mov	 ecx, DWORD PTR [rax+5908]
  0002c	41 89 08	 mov	 DWORD PTR [r8], ecx
$LN3@deflateUse:

; 727  :     return Z_OK;

  0002f	33 c0		 xor	 eax, eax

; 728  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
deflateUsed ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflatePrime
_TEXT	SEGMENT
strm$ = 48
bits$ = 56
value$ = 64
deflatePrime PROC					; COMDAT

; 731  : int ZEXPORT deflatePrime(z_streamp strm, int bits, int value) {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	41 8b f8	 mov	 edi, r8d
  0000d	8b da		 mov	 ebx, edx
  0000f	4c 8b d9	 mov	 r11, rcx

; 732  :     deflate_state *s;
; 733  :     int put;
; 734  : 
; 735  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00012	e8 00 00 00 00	 call	 deflateStateCheck
  00017	85 c0		 test	 eax, eax
  00019	74 10		 je	 SHORT $LN5@deflatePri
  0001b	b8 fe ff ff ff	 mov	 eax, -2

; 757  : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN5@deflatePri:

; 736  :     s = strm->state;
; 737  : #ifdef LIT_MEM
; 738  :     if (bits < 0 || bits > 16 ||
; 739  :         (uchf *)s->d_buf < s->pending_out + ((Buf_size + 7) >> 3))
; 740  :         return Z_BUF_ERROR;
; 741  : #else
; 742  :     if (bits < 0 || bits > 16 ||

  0002b	83 fb 10	 cmp	 ebx, 16
  0002e	77 7f		 ja	 SHORT $LN7@deflatePri
  00030	4d 8b 5b 28	 mov	 r11, QWORD PTR [r11+40]
  00034	49 8b 43 20	 mov	 rax, QWORD PTR [r11+32]
  00038	48 83 c0 02	 add	 rax, 2
  0003c	49 39 83 e8 16
	00 00		 cmp	 QWORD PTR [r11+5864], rax
  00043	72 6a		 jb	 SHORT $LN7@deflatePri
  00045	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@deflatePri:

; 743  :         s->sym_buf < s->pending_out + ((Buf_size + 7) >> 3))
; 744  :         return Z_BUF_ERROR;
; 745  : #endif
; 746  :     do {
; 747  :         put = Buf_size - s->bi_valid;

  00050	41 8b 93 10 17
	00 00		 mov	 edx, DWORD PTR [r11+5904]
  00057	b8 10 00 00 00	 mov	 eax, 16
  0005c	2b c2		 sub	 eax, edx

; 748  :         if (put > bits)
; 749  :             put = bits;
; 750  :         s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);

  0005e	44 8b d3	 mov	 r10d, ebx
  00061	3b c3		 cmp	 eax, ebx
  00063	44 0f 4e d0	 cmovle	 r10d, eax
  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	41 8b ca	 mov	 ecx, r10d
  0006f	66 d3 e0	 shl	 ax, cl
  00072	8b ca		 mov	 ecx, edx
  00074	66 ff c8	 dec	 ax
  00077	66 23 c7	 and	 ax, di
  0007a	66 d3 e0	 shl	 ax, cl

; 751  :         s->bi_valid += put;
; 752  :         _tr_flush_bits(s);

  0007d	49 8b cb	 mov	 rcx, r11
  00080	66 41 09 83 0c
	17 00 00	 or	 WORD PTR [r11+5900], ax
  00088	41 8d 04 12	 lea	 eax, DWORD PTR [r10+rdx]
  0008c	41 89 83 10 17
	00 00		 mov	 DWORD PTR [r11+5904], eax
  00093	e8 00 00 00 00	 call	 _tr_flush_bits

; 753  :         value >>= put;

  00098	41 8b ca	 mov	 ecx, r10d
  0009b	d3 ff		 sar	 edi, cl

; 754  :         bits -= put;

  0009d	41 2b da	 sub	 ebx, r10d

; 755  :     } while (bits);

  000a0	75 ae		 jne	 SHORT $LL4@deflatePri

; 756  :     return Z_OK;

  000a2	33 c0		 xor	 eax, eax

; 757  : }

  000a4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ad	5f		 pop	 rdi
  000ae	c3		 ret	 0
$LN7@deflatePri:
  000af	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b4	b8 fb ff ff ff	 mov	 eax, -5
  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
deflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateParams
_TEXT	SEGMENT
strm$ = 48
level$ = 56
strategy$ = 64
deflateParams PROC					; COMDAT

; 760  : int ZEXPORT deflateParams(z_streamp strm, int level, int strategy) {

$LN36:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	41 8b e8	 mov	 ebp, r8d
  0001d	48 8b f1	 mov	 rsi, rcx
  00020	44 8b c2	 mov	 r8d, edx

; 761  :     deflate_state *s;
; 762  :     compress_func func;
; 763  : 
; 764  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  00023	e8 00 00 00 00	 call	 deflateStateCheck
  00028	85 c0		 test	 eax, eax
  0002a	0f 85 28 01 00
	00		 jne	 $LN8@deflatePar

; 765  :     s = strm->state;

  00030	48 8b 5e 28	 mov	 rbx, QWORD PTR [rsi+40]

; 766  : 
; 767  : #ifdef FASTEST
; 768  :     if (level != 0) level = 1;
; 769  : #else
; 770  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;
; 771  : #endif
; 772  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {

  00034	41 83 f8 ff	 cmp	 r8d, -1
  00038	bf 06 00 00 00	 mov	 edi, 6
  0003d	41 0f 45 f8	 cmovne	 edi, r8d
  00041	83 ff 09	 cmp	 edi, 9
  00044	0f 87 0e 01 00
	00		 ja	 $LN8@deflatePar
  0004a	83 fd 04	 cmp	 ebp, 4
  0004d	0f 87 05 01 00
	00		 ja	 $LN8@deflatePar

; 774  :     }
; 775  :     func = configuration_table[s->level].func;
; 776  : 
; 777  :     if ((strategy != s->strategy || func != configuration_table[level].func) &&

  00053	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:configuration_table
  0005a	3b ab b0 00 00
	00		 cmp	 ebp, DWORD PTR [rbx+176]
  00060	75 1c		 jne	 SHORT $LN20@deflatePar
  00062	48 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rbx+172]
  00069	48 63 c7	 movsxd	 rax, edi
  0006c	48 03 c9	 add	 rcx, rcx
  0006f	48 03 c0	 add	 rax, rax
  00072	49 8b 44 c6 08	 mov	 rax, QWORD PTR [r14+rax*8+8]
  00077	49 39 44 ce 08	 cmp	 QWORD PTR [r14+rcx*8+8], rax
  0007c	74 40		 je	 SHORT $LN12@deflatePar
$LN20@deflatePar:
  0007e	83 7b 40 fe	 cmp	 DWORD PTR [rbx+64], -2
  00082	74 3a		 je	 SHORT $LN12@deflatePar

; 778  :         s->last_flush != -2) {
; 779  :         /* Flush the last buffer: */
; 780  :         int err = deflate(strm, Z_BLOCK);

  00084	ba 05 00 00 00	 mov	 edx, 5
  00089	48 8b ce	 mov	 rcx, rsi
  0008c	e8 00 00 00 00	 call	 deflate

; 781  :         if (err == Z_STREAM_ERROR)

  00091	83 f8 fe	 cmp	 eax, -2
  00094	0f 84 be 00 00
	00		 je	 $LN8@deflatePar

; 782  :             return err;
; 783  :         if (strm->avail_in || (s->strstart - s->block_start) + s->lookahead)

  0009a	83 7e 08 00	 cmp	 DWORD PTR [rsi+8], 0
  0009e	75 14		 jne	 SHORT $LN13@deflatePar
  000a0	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  000a6	2b 83 84 00 00
	00		 sub	 eax, DWORD PTR [rbx+132]
  000ac	03 83 94 00 00
	00		 add	 eax, DWORD PTR [rbx+148]
  000b2	74 0a		 je	 SHORT $LN12@deflatePar
$LN13@deflatePar:

; 784  :             return Z_BUF_ERROR;

  000b4	b8 fb ff ff ff	 mov	 eax, -5
  000b9	e9 9f 00 00 00	 jmp	 $LN1@deflatePar
$LN12@deflatePar:

; 785  :     }
; 786  :     if (s->level != level) {

  000be	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [rbx+172]
  000c4	3b c7		 cmp	 eax, edi
  000c6	0f 84 82 00 00
	00		 je	 $LN14@deflatePar

; 787  :         if (s->level == 0 && s->matches != 0) {

  000cc	85 c0		 test	 eax, eax
  000ce	75 43		 jne	 SHORT $LN15@deflatePar
  000d0	8b 83 04 17 00
	00		 mov	 eax, DWORD PTR [rbx+5892]
  000d6	85 c0		 test	 eax, eax
  000d8	74 39		 je	 SHORT $LN15@deflatePar

; 788  :             if (s->matches == 1)

  000da	33 f6		 xor	 esi, esi
  000dc	83 f8 01	 cmp	 eax, 1
  000df	75 0a		 jne	 SHORT $LN4@deflatePar

; 789  :                 slide_hash(s);

  000e1	48 8b cb	 mov	 rcx, rbx
  000e4	e8 00 00 00 00	 call	 slide_hash
  000e9	eb 22		 jmp	 SHORT $LN3@deflatePar
$LN4@deflatePar:

; 790  :             else
; 791  :                 CLEAR_HASH(s);

  000eb	8b 4b 74	 mov	 ecx, DWORD PTR [rbx+116]
  000ee	33 d2		 xor	 edx, edx
  000f0	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  000f4	ff c9		 dec	 ecx
  000f6	66 89 34 48	 mov	 WORD PTR [rax+rcx*2], si
  000fa	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  000fe	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00102	41 ff c8	 dec	 r8d
  00105	4d 03 c0	 add	 r8, r8
  00108	e8 00 00 00 00	 call	 memset
$LN3@deflatePar:

; 792  :             s->matches = 0;

  0010d	89 b3 04 17 00
	00		 mov	 DWORD PTR [rbx+5892], esi
$LN15@deflatePar:

; 793  :         }
; 794  :         s->level = level;

  00113	89 bb ac 00 00
	00		 mov	 DWORD PTR [rbx+172], edi

; 795  :         s->max_lazy_match   = configuration_table[level].max_lazy;

  00119	48 63 cf	 movsxd	 rcx, edi
  0011c	48 03 c9	 add	 rcx, rcx
  0011f	41 0f b7 44 ce
	02		 movzx	 eax, WORD PTR [r14+rcx*8+2]
  00125	89 83 a8 00 00
	00		 mov	 DWORD PTR [rbx+168], eax

; 796  :         s->good_match       = configuration_table[level].good_length;

  0012b	41 0f b7 04 ce	 movzx	 eax, WORD PTR [r14+rcx*8]
  00130	89 83 b4 00 00
	00		 mov	 DWORD PTR [rbx+180], eax

; 797  :         s->nice_match       = configuration_table[level].nice_length;

  00136	41 0f b7 44 ce
	04		 movzx	 eax, WORD PTR [r14+rcx*8+4]
  0013c	89 83 b8 00 00
	00		 mov	 DWORD PTR [rbx+184], eax

; 798  :         s->max_chain_length = configuration_table[level].max_chain;

  00142	41 0f b7 44 ce
	06		 movzx	 eax, WORD PTR [r14+rcx*8+6]
  00148	89 83 a4 00 00
	00		 mov	 DWORD PTR [rbx+164], eax
$LN14@deflatePar:

; 799  :     }
; 800  :     s->strategy = strategy;

  0014e	89 ab b0 00 00
	00		 mov	 DWORD PTR [rbx+176], ebp

; 801  :     return Z_OK;

  00154	33 c0		 xor	 eax, eax
  00156	eb 05		 jmp	 SHORT $LN1@deflatePar
$LN8@deflatePar:

; 773  :         return Z_STREAM_ERROR;

  00158	b8 fe ff ff ff	 mov	 eax, -2
$LN1@deflatePar:

; 802  : }

  0015d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00162	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00167	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0016c	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00171	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00175	41 5e		 pop	 r14
  00177	c3		 ret	 0
deflateParams ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateTune
_TEXT	SEGMENT
strm$ = 48
good_length$ = 56
max_lazy$ = 64
nice_length$ = 72
max_chain$ = 80
deflateTune PROC					; COMDAT

; 806  :                         int nice_length, int max_chain) {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	44 8b da	 mov	 r11d, edx
  00007	4c 8b d1	 mov	 r10, rcx

; 807  :     deflate_state *s;
; 808  : 
; 809  :     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;

  0000a	e8 00 00 00 00	 call	 deflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	74 0a		 je	 SHORT $LN2@deflateTun
  00013	b8 fe ff ff ff	 mov	 eax, -2

; 816  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
$LN2@deflateTun:

; 810  :     s = strm->state;

  0001d	49 8b 4a 28	 mov	 rcx, QWORD PTR [r10+40]

; 811  :     s->good_match = (uInt)good_length;
; 812  :     s->max_lazy_match = (uInt)max_lazy;
; 813  :     s->nice_match = nice_length;
; 814  :     s->max_chain_length = (uInt)max_chain;

  00021	8b 44 24 50	 mov	 eax, DWORD PTR max_chain$[rsp]
  00025	89 81 a4 00 00
	00		 mov	 DWORD PTR [rcx+164], eax

; 815  :     return Z_OK;

  0002b	33 c0		 xor	 eax, eax
  0002d	44 89 99 b4 00
	00 00		 mov	 DWORD PTR [rcx+180], r11d
  00034	44 89 81 a8 00
	00 00		 mov	 DWORD PTR [rcx+168], r8d
  0003b	44 89 89 b8 00
	00 00		 mov	 DWORD PTR [rcx+184], r9d

; 816  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
deflateTune ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateBound
_TEXT	SEGMENT
strm$ = 48
sourceLen$ = 56
deflateBound PROC					; COMDAT

; 842  : uLong ZEXPORT deflateBound(z_streamp strm, uLong sourceLen) {

$LN51:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b d1	 mov	 r10, rcx

; 843  :     deflate_state *s;
; 844  :     uLong fixedlen, storelen, wraplen;
; 845  : 
; 846  :     /* upper bound for fixed blocks with 9-bit literals and length 255
; 847  :        (memLevel == 2, which is the lowest that may not use stored blocks) --
; 848  :        ~13% overhead plus a small constant */
; 849  :     fixedlen = sourceLen + (sourceLen >> 3) + (sourceLen >> 8) +

  00009	8b da		 mov	 ebx, edx
  0000b	c1 eb 08	 shr	 ebx, 8

; 850  :                (sourceLen >> 9) + 4;
; 851  : 
; 852  :     /* upper bound for stored blocks with length 127 (memLevel == 1) --
; 853  :        ~4% overhead plus a small constant */
; 854  :     storelen = sourceLen + (sourceLen >> 5) + (sourceLen >> 7) +

  0000e	8b ca		 mov	 ecx, edx
  00010	03 da		 add	 ebx, edx
  00012	c1 e9 07	 shr	 ecx, 7
  00015	03 ca		 add	 ecx, edx
  00017	44 8b ca	 mov	 r9d, edx
  0001a	8b c2		 mov	 eax, edx
  0001c	41 c1 e9 09	 shr	 r9d, 9
  00020	c1 e8 03	 shr	 eax, 3
  00023	44 8b c2	 mov	 r8d, edx
  00026	83 c0 04	 add	 eax, 4
  00029	41 c1 e8 0b	 shr	 r8d, 11
  0002d	44 03 c1	 add	 r8d, ecx
  00030	41 03 d9	 add	 ebx, r9d
  00033	03 d8		 add	 ebx, eax

; 855  :                (sourceLen >> 11) + 7;
; 856  : 
; 857  :     /* if can't get parameters, return larger bound plus a wrapper */
; 858  :     if (deflateStateCheck(strm))

  00035	49 8b ca	 mov	 rcx, r10
  00038	8b c2		 mov	 eax, edx
  0003a	44 8b da	 mov	 r11d, edx
  0003d	c1 e8 05	 shr	 eax, 5
  00040	83 c0 07	 add	 eax, 7
  00043	44 03 c0	 add	 r8d, eax
  00046	e8 00 00 00 00	 call	 deflateStateCheck
  0004b	85 c0		 test	 eax, eax
  0004d	74 11		 je	 SHORT $LN10@deflateBou

; 859  :         return (fixedlen > storelen ? fixedlen : storelen) + 18;

  0004f	41 3b d8	 cmp	 ebx, r8d
  00052	44 0f 47 c3	 cmova	 r8d, ebx
  00056	41 8d 40 12	 lea	 eax, DWORD PTR [r8+18]

; 904  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 905  : }

  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5b		 pop	 rbx
  0005f	c3		 ret	 0
$LN10@deflateBou:

; 860  : 
; 861  :     /* compute wrapper length */
; 862  :     s = strm->state;

  00060	4d 8b 4a 28	 mov	 r9, QWORD PTR [r10+40]

; 863  :     switch (s->wrap < 0 ? -s->wrap : s->wrap) {

  00064	41 8b 49 2c	 mov	 ecx, DWORD PTR [r9+44]
  00068	f7 d9		 neg	 ecx
  0006a	41 0f 48 49 2c	 cmovs	 ecx, DWORD PTR [r9+44]
  0006f	85 c9		 test	 ecx, ecx
  00071	74 7d		 je	 SHORT $LN11@deflateBou
  00073	83 e9 01	 sub	 ecx, 1
  00076	74 61		 je	 SHORT $LN12@deflateBou
  00078	b8 12 00 00 00	 mov	 eax, 18
  0007d	83 f9 01	 cmp	 ecx, 1
  00080	75 70		 jne	 SHORT $LN2@deflateBou

; 870  : #ifdef GZIP
; 871  :     case 2:                                 /* gzip wrapper */
; 872  :         wraplen = 18;
; 873  :         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */

  00082	4d 8b 51 30	 mov	 r10, QWORD PTR [r9+48]
  00086	4d 85 d2	 test	 r10, r10
  00089	74 67		 je	 SHORT $LN2@deflateBou

; 874  :             Bytef *str;
; 875  :             if (s->gzhead->extra != Z_NULL)

  0008b	49 83 7a 10 00	 cmp	 QWORD PTR [r10+16], 0
  00090	74 07		 je	 SHORT $LN15@deflateBou

; 876  :                 wraplen += 2 + s->gzhead->extra_len;

  00092	41 8b 42 18	 mov	 eax, DWORD PTR [r10+24]
  00096	83 c0 14	 add	 eax, 20
$LN15@deflateBou:

; 877  :             str = s->gzhead->name;

  00099	49 8b 52 20	 mov	 rdx, QWORD PTR [r10+32]

; 878  :             if (str != Z_NULL)

  0009d	48 85 d2	 test	 rdx, rdx
  000a0	74 0d		 je	 SHORT $LN5@deflateBou
$LL6@deflateBou:

; 879  :                 do {
; 880  :                     wraplen++;
; 881  :                 } while (*str++);

  000a2	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  000a5	48 8d 52 01	 lea	 rdx, QWORD PTR [rdx+1]
  000a9	ff c0		 inc	 eax
  000ab	84 c9		 test	 cl, cl
  000ad	75 f3		 jne	 SHORT $LL6@deflateBou
$LN5@deflateBou:

; 882  :             str = s->gzhead->comment;

  000af	49 8b 52 30	 mov	 rdx, QWORD PTR [r10+48]

; 883  :             if (str != Z_NULL)

  000b3	48 85 d2	 test	 rdx, rdx
  000b6	74 15		 je	 SHORT $LN8@deflateBou
  000b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL9@deflateBou:

; 884  :                 do {
; 885  :                     wraplen++;
; 886  :                 } while (*str++);

  000c0	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  000c3	48 8d 52 01	 lea	 rdx, QWORD PTR [rdx+1]
  000c7	ff c0		 inc	 eax
  000c9	84 c9		 test	 cl, cl
  000cb	75 f3		 jne	 SHORT $LL9@deflateBou
$LN8@deflateBou:

; 887  :             if (s->gzhead->hcrc)

  000cd	41 83 7a 3c 00	 cmp	 DWORD PTR [r10+60], 0
  000d2	74 1e		 je	 SHORT $LN2@deflateBou

; 888  :                 wraplen += 2;

  000d4	83 c0 02	 add	 eax, 2

; 889  :         }
; 890  :         break;

  000d7	eb 19		 jmp	 SHORT $LN2@deflateBou
$LN12@deflateBou:

; 866  :         break;
; 867  :     case 1:                                 /* zlib wrapper */
; 868  :         wraplen = 6 + (s->strstart ? 4 : 0);

  000d9	41 83 b9 94 00
	00 00 00	 cmp	 DWORD PTR [r9+148], 0
  000e1	b8 06 00 00 00	 mov	 eax, 6
  000e6	b9 0a 00 00 00	 mov	 ecx, 10
  000eb	0f 45 c1	 cmovne	 eax, ecx

; 869  :         break;

  000ee	eb 02		 jmp	 SHORT $LN2@deflateBou
$LN11@deflateBou:

; 864  :     case 0:                                 /* raw deflate */
; 865  :         wraplen = 0;

  000f0	33 c0		 xor	 eax, eax
$LN2@deflateBou:

; 891  : #endif
; 892  :     default:                                /* for compiler happiness */
; 893  :         wraplen = 18;
; 894  :     }
; 895  : 
; 896  :     /* if not default parameters, return one of the conservative bounds */
; 897  :     if (s->w_bits != 15 || s->hash_bits != 8 + 7)

  000f2	41 8b 49 48	 mov	 ecx, DWORD PTR [r9+72]
  000f6	83 f9 0f	 cmp	 ecx, 15
  000f9	75 2a		 jne	 SHORT $LN37@deflateBou
  000fb	41 39 49 78	 cmp	 DWORD PTR [r9+120], ecx
  000ff	75 24		 jne	 SHORT $LN37@deflateBou

; 899  :                wraplen;
; 900  : 
; 901  :     /* default settings: return tight bound for that case -- ~0.03% overhead
; 902  :        plus a small constant */
; 903  :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +

  00101	41 8b d3	 mov	 edx, r11d
  00104	41 8b cb	 mov	 ecx, r11d
  00107	c1 ea 0e	 shr	 edx, 14
  0010a	03 d0		 add	 edx, eax
  0010c	c1 e9 19	 shr	 ecx, 25
  0010f	03 d1		 add	 edx, ecx
  00111	41 8b c3	 mov	 eax, r11d
  00114	c1 e8 0c	 shr	 eax, 12
  00117	83 c0 07	 add	 eax, 7
  0011a	03 c2		 add	 eax, edx
  0011c	41 03 c3	 add	 eax, r11d

; 904  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 905  : }

  0011f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00123	5b		 pop	 rbx
  00124	c3		 ret	 0
$LN37@deflateBou:

; 898  :         return (s->w_bits <= s->hash_bits && s->level ? fixedlen : storelen) +

  00125	41 3b 49 78	 cmp	 ecx, DWORD PTR [r9+120]
  00129	77 0a		 ja	 SHORT $LN25@deflateBou
  0012b	41 83 b9 ac 00
	00 00 00	 cmp	 DWORD PTR [r9+172], 0
  00133	75 03		 jne	 SHORT $LN26@deflateBou
$LN25@deflateBou:
  00135	41 8b d8	 mov	 ebx, r8d
$LN26@deflateBou:
  00138	03 c3		 add	 eax, ebx

; 904  :            (sourceLen >> 25) + 13 - 6 + wraplen;
; 905  : }

  0013a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013e	5b		 pop	 rbx
  0013f	c3		 ret	 0
deflateBound ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT putShortMSB
_TEXT	SEGMENT
s$ = 8
b$ = 16
putShortMSB PROC					; COMDAT

; 913  :     put_byte(s, (Byte)(b >> 8));

  00000	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00004	44 8b ca	 mov	 r9d, edx
  00007	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0000b	41 c1 e9 08	 shr	 r9d, 8
  0000f	45 88 0c 00	 mov	 BYTE PTR [r8+rax], r9b
  00013	ff 41 28	 inc	 DWORD PTR [rcx+40]
  00016	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]

; 914  :     put_byte(s, (Byte)(b & 0xff));

  0001a	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0001e	41 88 14 00	 mov	 BYTE PTR [r8+rax], dl
  00022	ff 41 28	 inc	 DWORD PTR [rcx+40]

; 915  : }

  00025	c3		 ret	 0
putShortMSB ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT flush_pending
_TEXT	SEGMENT
strm$ = 48
tv217 = 48
flush_pending PROC					; COMDAT

; 923  : local void flush_pending(z_streamp strm) {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 924  :     unsigned len;
; 925  :     deflate_state *s = strm->state;

  0000f	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  00013	48 8b f1	 mov	 rsi, rcx

; 926  : 
; 927  :     _tr_flush_bits(s);

  00016	48 8b cf	 mov	 rcx, rdi
  00019	e8 00 00 00 00	 call	 _tr_flush_bits

; 928  :     len = s->pending;
; 929  :     if (len > strm->avail_out) len = strm->avail_out;

  0001e	8b 6e 18	 mov	 ebp, DWORD PTR [rsi+24]

; 930  :     if (len == 0) return;

  00021	39 6f 28	 cmp	 DWORD PTR [rdi+40], ebp
  00024	0f 46 6f 28	 cmovbe	 ebp, DWORD PTR [rdi+40]
  00028	85 ed		 test	 ebp, ebp
  0002a	74 37		 je	 SHORT $LN4@flush_pend

; 931  : 
; 932  :     zmemcpy(strm->next_out, s->pending_out, len);

  0002c	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  00030	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  00034	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00039	44 8b c5	 mov	 r8d, ebp
  0003c	8b dd		 mov	 ebx, ebp
  0003e	e8 00 00 00 00	 call	 memcpy

; 933  :     strm->next_out  += len;

  00043	48 01 5e 10	 add	 QWORD PTR [rsi+16], rbx

; 934  :     s->pending_out  += len;

  00047	48 01 5f 20	 add	 QWORD PTR [rdi+32], rbx

; 935  :     strm->total_out += len;

  0004b	01 6e 1c	 add	 DWORD PTR [rsi+28], ebp

; 936  :     strm->avail_out -= len;

  0004e	29 6e 18	 sub	 DWORD PTR [rsi+24], ebp

; 937  :     s->pending      -= len;

  00051	29 6f 28	 sub	 DWORD PTR [rdi+40], ebp
  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]

; 938  :     if (s->pending == 0) {

  00059	75 08		 jne	 SHORT $LN4@flush_pend

; 939  :         s->pending_out = s->pending_buf;

  0005b	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0005f	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax
$LN4@flush_pend:

; 940  :     }
; 941  : }

  00063	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00068	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0006d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00071	5f		 pop	 rdi
  00072	c3		 ret	 0
flush_pending ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflateCopy
_TEXT	SEGMENT
dest$ = 48
source$ = 56
deflateCopy PROC					; COMDAT

; 1290 : int ZEXPORT deflateCopy(z_streamp dest, z_streamp source) {

$LN19:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f9	 mov	 rdi, rcx
  00009	4c 8b c2	 mov	 r8, rdx

; 1291 : #ifdef MAXSEG_64K
; 1292 :     (void)dest;
; 1293 :     (void)source;
; 1294 :     return Z_STREAM_ERROR;
; 1295 : #else
; 1296 :     deflate_state *ds;
; 1297 :     deflate_state *ss;
; 1298 : 
; 1299 : 
; 1300 :     if (deflateStateCheck(source) || dest == Z_NULL) {

  0000c	48 8b ca	 mov	 rcx, rdx
  0000f	e8 00 00 00 00	 call	 deflateStateCheck
  00014	85 c0		 test	 eax, eax
  00016	0f 85 db 01 00
	00		 jne	 $LN3@deflateCop
  0001c	48 85 ff	 test	 rdi, rdi
  0001f	0f 84 d2 01 00
	00		 je	 $LN3@deflateCop

; 1302 :     }
; 1303 : 
; 1304 :     ss = source->state;
; 1305 : 
; 1306 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00025	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  00029	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1307 : 
; 1308 :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  0002e	ba 01 00 00 00	 mov	 edx, 1
  00033	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00038	49 8b 70 28	 mov	 rsi, QWORD PTR [r8+40]
  0003c	0f 11 07	 movups	 XMMWORD PTR [rdi], xmm0
  0003f	41 0f 10 48 10	 movups	 xmm1, XMMWORD PTR [r8+16]
  00044	0f 11 4f 10	 movups	 XMMWORD PTR [rdi+16], xmm1
  00048	41 0f 10 40 20	 movups	 xmm0, XMMWORD PTR [r8+32]
  0004d	0f 11 47 20	 movups	 XMMWORD PTR [rdi+32], xmm0
  00051	41 0f 10 48 30	 movups	 xmm1, XMMWORD PTR [r8+48]
  00056	0f 11 4f 30	 movups	 XMMWORD PTR [rdi+48], xmm1
  0005a	41 0f 10 40 40	 movups	 xmm0, XMMWORD PTR [r8+64]
  0005f	0f 11 47 40	 movups	 XMMWORD PTR [rdi+64], xmm0
  00063	f2 41 0f 10 48
	50		 movsd	 xmm1, QWORD PTR [r8+80]
  00069	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0006f	f2 0f 11 4f 50	 movsd	 QWORD PTR [rdi+80], xmm1
  00074	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00078	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  0007c	ff d0		 call	 rax
  0007e	48 8b d8	 mov	 rbx, rax

; 1309 :     if (ds == Z_NULL) return Z_MEM_ERROR;

  00081	48 85 c0	 test	 rax, rax
  00084	0f 84 58 01 00
	00		 je	 $LN17@deflateCop

; 1310 :     dest->state = (struct internal_state FAR *) ds;
; 1311 :     zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));

  0008a	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  00090	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  00094	48 8b d6	 mov	 rdx, rsi
  00097	48 8b c8	 mov	 rcx, rax
  0009a	e8 00 00 00 00	 call	 memcpy

; 1312 :     ds->strm = dest;
; 1313 : 
; 1314 :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  0009f	8b 53 44	 mov	 edx, DWORD PTR [rbx+68]
  000a2	41 b8 02 00 00
	00		 mov	 r8d, 2
  000a8	48 89 3b	 mov	 QWORD PTR [rbx], rdi
  000ab	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  000af	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  000b3	ff d0		 call	 rax

; 1315 :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  000b5	8b 53 44	 mov	 edx, DWORD PTR [rbx+68]
  000b8	41 b8 02 00 00
	00		 mov	 r8d, 2
  000be	48 89 43 50	 mov	 QWORD PTR [rbx+80], rax
  000c2	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  000c6	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  000ca	ff d0		 call	 rax

; 1316 :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  000cc	8b 53 74	 mov	 edx, DWORD PTR [rbx+116]
  000cf	41 b8 02 00 00
	00		 mov	 r8d, 2
  000d5	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax
  000d9	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  000dd	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  000e1	ff d0		 call	 rax

; 1317 :     ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, LIT_BUFS);

  000e3	8b 93 f0 16 00
	00		 mov	 edx, DWORD PTR [rbx+5872]
  000e9	41 b8 04 00 00
	00		 mov	 r8d, 4
  000ef	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax
  000f3	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  000f7	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  000fb	ff d0		 call	 rax

; 1318 : 
; 1319 :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||

  000fd	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  00101	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  00105	48 85 c9	 test	 rcx, rcx
  00108	0f 84 cc 00 00
	00		 je	 $LN6@deflateCop
  0010e	48 83 7b 60 00	 cmp	 QWORD PTR [rbx+96], 0
  00113	0f 84 c1 00 00
	00		 je	 $LN6@deflateCop
  00119	48 83 7b 68 00	 cmp	 QWORD PTR [rbx+104], 0
  0011e	0f 84 b6 00 00
	00		 je	 $LN6@deflateCop
  00124	48 85 c0	 test	 rax, rax
  00127	0f 84 ad 00 00
	00		 je	 $LN6@deflateCop

; 1323 :     }
; 1324 :     /* following zmemcpy do not work for 16-bit MSDOS */
; 1325 :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  0012d	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  00130	48 8b 56 50	 mov	 rdx, QWORD PTR [rsi+80]
  00134	44 8d 04 00	 lea	 r8d, DWORD PTR [rax+rax]
  00138	e8 00 00 00 00	 call	 memcpy

; 1326 :     zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));

  0013d	44 8b 43 44	 mov	 r8d, DWORD PTR [rbx+68]
  00141	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  00145	4d 03 c0	 add	 r8, r8
  00148	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0014c	e8 00 00 00 00	 call	 memcpy

; 1327 :     zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));

  00151	44 8b 43 74	 mov	 r8d, DWORD PTR [rbx+116]
  00155	48 8b 56 68	 mov	 rdx, QWORD PTR [rsi+104]
  00159	4d 03 c0	 add	 r8, r8
  0015c	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00160	e8 00 00 00 00	 call	 memcpy

; 1328 :     zmemcpy(ds->pending_buf, ss->pending_buf, ds->lit_bufsize * LIT_BUFS);

  00165	44 8b 83 f0 16
	00 00		 mov	 r8d, DWORD PTR [rbx+5872]
  0016c	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  00170	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00174	41 c1 e0 02	 shl	 r8d, 2
  00178	e8 00 00 00 00	 call	 memcpy

; 1329 : 
; 1330 :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  0017d	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00181	48 2b 46 10	 sub	 rax, QWORD PTR [rsi+16]
  00185	48 03 43 10	 add	 rax, QWORD PTR [rbx+16]
  00189	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0018e	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 1331 : #ifdef LIT_MEM
; 1332 :     ds->d_buf = (ushf *)(ds->pending_buf + (ds->lit_bufsize << 1));
; 1333 :     ds->l_buf = ds->pending_buf + (ds->lit_bufsize << 2);
; 1334 : #else
; 1335 :     ds->sym_buf = ds->pending_buf + ds->lit_bufsize;

  00192	8b 83 f0 16 00
	00		 mov	 eax, DWORD PTR [rbx+5872]
  00198	48 03 43 10	 add	 rax, QWORD PTR [rbx+16]
  0019c	48 89 83 e8 16
	00 00		 mov	 QWORD PTR [rbx+5864], rax

; 1336 : #endif
; 1337 : 
; 1338 :     ds->l_desc.dyn_tree = ds->dyn_ltree;

  001a3	48 8d 83 bc 00
	00 00		 lea	 rax, QWORD PTR [rbx+188]
  001aa	48 89 83 40 0b
	00 00		 mov	 QWORD PTR [rbx+2880], rax

; 1339 :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  001b1	48 8d 83 b0 09
	00 00		 lea	 rax, QWORD PTR [rbx+2480]
  001b8	48 89 83 58 0b
	00 00		 mov	 QWORD PTR [rbx+2904], rax

; 1340 :     ds->bl_desc.dyn_tree = ds->bl_tree;

  001bf	48 8d 83 a4 0a
	00 00		 lea	 rax, QWORD PTR [rbx+2724]
  001c6	48 89 83 70 0b
	00 00		 mov	 QWORD PTR [rbx+2928], rax

; 1341 : 
; 1342 :     return Z_OK;

  001cd	33 c0		 xor	 eax, eax
  001cf	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1343 : #endif /* MAXSEG_64K */
; 1344 : }

  001d4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d8	5f		 pop	 rdi
  001d9	c3		 ret	 0
$LN6@deflateCop:

; 1320 :         ds->pending_buf == Z_NULL) {
; 1321 :         deflateEnd (dest);

  001da	48 8b cf	 mov	 rcx, rdi
  001dd	e8 00 00 00 00	 call	 deflateEnd
$LN17@deflateCop:

; 1322 :         return Z_MEM_ERROR;

  001e2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001e7	b8 fc ff ff ff	 mov	 eax, -4
  001ec	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 1343 : #endif /* MAXSEG_64K */
; 1344 : }

  001f1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001f5	5f		 pop	 rdi
  001f6	c3		 ret	 0
$LN3@deflateCop:

; 1301 :         return Z_STREAM_ERROR;

  001f7	b8 fe ff ff ff	 mov	 eax, -2

; 1343 : #endif /* MAXSEG_64K */
; 1344 : }

  001fc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00200	5f		 pop	 rdi
  00201	c3		 ret	 0
deflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT longest_match
_TEXT	SEGMENT
s$ = 48
tv791 = 48
cur_match$ = 56
longest_match PROC					; COMDAT

; 1356 : local uInt longest_match(deflate_state *s, IPos cur_match) {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15

; 1357 :     unsigned chain_length = s->max_chain_length;/* max hash chain length */
; 1358 :     register Bytef *scan = s->window + s->strstart; /* current string */

  00018	44 8b 89 94 00
	00 00		 mov	 r9d, DWORD PTR [rcx+148]
  0001f	4c 8b f1	 mov	 r14, rcx
  00022	44 8b 91 a4 00
	00 00		 mov	 r10d, DWORD PTR [rcx+164]

; 1359 :     register Bytef *match;                      /* matched string */
; 1360 :     register int len;                           /* length of current match */
; 1361 :     int best_len = (int)s->prev_length;         /* best match length so far */
; 1362 :     int nice_match = s->nice_match;             /* stop if match long enough */
; 1363 :     IPos limit = s->strstart > (IPos)MAX_DIST(s) ?

  00029	45 33 e4	 xor	 r12d, r12d
  0002c	48 63 99 a0 00
	00 00		 movsxd	 rbx, DWORD PTR [rcx+160]
  00033	45 8b c1	 mov	 r8d, r9d
  00036	44 8b b9 b8 00
	00 00		 mov	 r15d, DWORD PTR [rcx+184]
  0003d	44 8b da	 mov	 r11d, edx
  00040	8b 51 44	 mov	 edx, DWORD PTR [rcx+68]
  00043	44 2b c2	 sub	 r8d, edx
  00046	48 8b 79 50	 mov	 rdi, QWORD PTR [rcx+80]
  0004a	41 81 c0 06 01
	00 00		 add	 r8d, 262		; 00000106H

; 1364 :         s->strstart - (IPos)MAX_DIST(s) : NIL;
; 1365 :     /* Stop when cur_match becomes <= limit. To simplify the code,
; 1366 :      * we prevent matches with the string of window index 0.
; 1367 :      */
; 1368 :     Posf *prev = s->prev;

  00051	4d 8b 6e 60	 mov	 r13, QWORD PTR [r14+96]
  00055	49 03 f9	 add	 rdi, r9
  00058	48 89 7c 24 30	 mov	 QWORD PTR tv791[rsp], rdi
  0005d	48 8b c7	 mov	 rax, rdi
  00060	8d 8a fa fe ff
	ff		 lea	 ecx, DWORD PTR [rdx-262]
  00066	44 3b c9	 cmp	 r9d, ecx

; 1369 :     uInt wmask = s->w_mask;
; 1370 : 
; 1371 : #ifdef UNALIGNED_OK
; 1372 :     /* Compare two bytes at a time. Note: this is not always beneficial.
; 1373 :      * Try with and without -DUNALIGNED_OK to check.
; 1374 :      */
; 1375 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
; 1376 :     register ush scan_start = *(ushf*)scan;
; 1377 :     register ush scan_end   = *(ushf*)(scan + best_len - 1);
; 1378 : #else
; 1379 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH;
; 1380 :     register Byte scan_end1  = scan[best_len - 1];

  00069	0f b6 74 3b ff	 movzx	 esi, BYTE PTR [rbx+rdi-1]

; 1381 :     register Byte scan_end   = scan[best_len];

  0006e	0f b6 2c 3b	 movzx	 ebp, BYTE PTR [rbx+rdi]
  00072	45 0f 47 e0	 cmova	 r12d, r8d
  00076	4c 8d 87 02 01
	00 00		 lea	 r8, QWORD PTR [rdi+258]

; 1382 : #endif
; 1383 : 
; 1384 :     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
; 1385 :      * It is easy to get rid of this optimization if necessary.
; 1386 :      */
; 1387 :     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
; 1388 : 
; 1389 :     /* Do not waste too much time if we already have a good match: */
; 1390 :     if (s->prev_length >= s->good_match) {
; 1391 :         chain_length >>= 2;
; 1392 :     }
; 1393 :     /* Do not look for matches beyond the end of the input. This is necessary
; 1394 :      * to make deflate deterministic.
; 1395 :      */
; 1396 :     if ((uInt)nice_match > s->lookahead) nice_match = (int)s->lookahead;

  0007d	41 8b fa	 mov	 edi, r10d
  00080	c1 ef 02	 shr	 edi, 2
  00083	41 3b 9e b4 00
	00 00		 cmp	 ebx, DWORD PTR [r14+180]
  0008a	41 0f 42 fa	 cmovb	 edi, r10d
  0008e	45 8b 96 9c 00
	00 00		 mov	 r10d, DWORD PTR [r14+156]
  00095	45 3b fa	 cmp	 r15d, r10d
  00098	45 0f 47 fa	 cmova	 r15d, r10d
  0009c	0f 1f 40 00	 npad	 4
$LL4@longest_ma:

; 1397 : 
; 1398 :     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
; 1399 :            "need lookahead");
; 1400 : 
; 1401 :     do {
; 1402 :         Assert(cur_match < s->strstart, "no future");
; 1403 :         match = s->window + cur_match;

  000a0	49 8b 56 50	 mov	 rdx, QWORD PTR [r14+80]
  000a4	45 8b cb	 mov	 r9d, r11d
  000a7	49 03 d1	 add	 rdx, r9

; 1404 : 
; 1405 :         /* Skip to next match if the match length cannot increase
; 1406 :          * or if the match length is less than 2.  Note that the checks below
; 1407 :          * for insufficient lookahead only occur occasionally for performance
; 1408 :          * reasons.  Therefore uninitialized memory will be accessed, and
; 1409 :          * conditional jumps will be made that depend on those values.
; 1410 :          * However the length of the match is limited to the lookahead, so
; 1411 :          * the output of deflate is not affected by the uninitialized values.
; 1412 :          */
; 1413 : #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
; 1414 :         /* This code assumes sizeof(unsigned short) == 2. Do not use
; 1415 :          * UNALIGNED_OK if your compiler uses a different size.
; 1416 :          */
; 1417 :         if (*(ushf*)(match + best_len - 1) != scan_end ||
; 1418 :             *(ushf*)match != scan_start) continue;
; 1419 : 
; 1420 :         /* It is not necessary to compare scan[2] and match[2] since they are
; 1421 :          * always equal when the other bytes match, given that the hash keys
; 1422 :          * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
; 1423 :          * strstart + 3, + 5, up to strstart + 257. We check for insufficient
; 1424 :          * lookahead only every 4th comparison; the 128th check will be made
; 1425 :          * at strstart + 257. If MAX_MATCH-2 is not a multiple of 8, it is
; 1426 :          * necessary to put more guard bytes at the end of the window, or
; 1427 :          * to check more often for insufficient lookahead.
; 1428 :          */
; 1429 :         Assert(scan[2] == match[2], "scan[2]?");
; 1430 :         scan++, match++;
; 1431 :         do {
; 1432 :         } while (*(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
; 1433 :                  *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
; 1434 :                  *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
; 1435 :                  *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
; 1436 :                  scan < strend);
; 1437 :         /* The funny "do {}" generates better code on most compilers */
; 1438 : 
; 1439 :         /* Here, scan <= window + strstart + 257 */
; 1440 :         Assert(scan <= s->window + (unsigned)(s->window_size - 1),
; 1441 :                "wild scan");
; 1442 :         if (*scan == *match) scan++;
; 1443 : 
; 1444 :         len = (MAX_MATCH - 1) - (int)(strend - scan);
; 1445 :         scan = strend - (MAX_MATCH-1);
; 1446 : 
; 1447 : #else /* UNALIGNED_OK */
; 1448 : 
; 1449 :         if (match[best_len]     != scan_end  ||
; 1450 :             match[best_len - 1] != scan_end1 ||
; 1451 :             *match              != *scan     ||

  000aa	48 63 cb	 movsxd	 rcx, ebx
  000ad	40 38 2c 11	 cmp	 BYTE PTR [rcx+rdx], bpl
  000b1	0f 85 c1 00 00
	00		 jne	 $LN2@longest_ma
  000b7	40 38 74 11 ff	 cmp	 BYTE PTR [rcx+rdx-1], sil
  000bc	0f 85 b6 00 00
	00		 jne	 $LN2@longest_ma
  000c2	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000c5	38 0a		 cmp	 BYTE PTR [rdx], cl
  000c7	0f 85 ab 00 00
	00		 jne	 $LN2@longest_ma
  000cd	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  000d1	38 4a 01	 cmp	 BYTE PTR [rdx+1], cl
  000d4	0f 85 9e 00 00
	00		 jne	 $LN2@longest_ma

; 1452 :             *++match            != scan[1])      continue;
; 1453 : 
; 1454 :         /* The check at best_len - 1 can be removed because it will be made
; 1455 :          * again later. (This heuristic is not always a win.)
; 1456 :          * It is not necessary to compare scan[2] and match[2] since they
; 1457 :          * are always equal when the other bytes match, given that
; 1458 :          * the hash keys are equal and that HASH_BITS >= 8.
; 1459 :          */
; 1460 :         scan += 2, match++;

  000da	48 83 c0 02	 add	 rax, 2
  000de	48 83 c2 02	 add	 rdx, 2
$LL7@longest_ma:

; 1461 :         Assert(*scan == *match, "match[2]?");
; 1462 : 
; 1463 :         /* We check for insufficient lookahead only every 8th comparison;
; 1464 :          * the 256th check will be made at strstart + 258.
; 1465 :          */
; 1466 :         do {
; 1467 :         } while (*++scan == *++match && *++scan == *++match &&
; 1468 :                  *++scan == *++match && *++scan == *++match &&
; 1469 :                  *++scan == *++match && *++scan == *++match &&
; 1470 :                  *++scan == *++match && *++scan == *++match &&

  000e2	0f b6 4a 01	 movzx	 ecx, BYTE PTR [rdx+1]
  000e6	48 ff c0	 inc	 rax
  000e9	38 08		 cmp	 BYTE PTR [rax], cl
  000eb	75 56		 jne	 SHORT $LN12@longest_ma
  000ed	0f b6 4a 02	 movzx	 ecx, BYTE PTR [rdx+2]
  000f1	48 ff c0	 inc	 rax
  000f4	38 08		 cmp	 BYTE PTR [rax], cl
  000f6	75 4b		 jne	 SHORT $LN12@longest_ma
  000f8	0f b6 4a 03	 movzx	 ecx, BYTE PTR [rdx+3]
  000fc	48 ff c0	 inc	 rax
  000ff	38 08		 cmp	 BYTE PTR [rax], cl
  00101	75 40		 jne	 SHORT $LN12@longest_ma
  00103	0f b6 4a 04	 movzx	 ecx, BYTE PTR [rdx+4]
  00107	48 ff c0	 inc	 rax
  0010a	38 08		 cmp	 BYTE PTR [rax], cl
  0010c	75 35		 jne	 SHORT $LN12@longest_ma
  0010e	0f b6 4a 05	 movzx	 ecx, BYTE PTR [rdx+5]
  00112	48 ff c0	 inc	 rax
  00115	38 08		 cmp	 BYTE PTR [rax], cl
  00117	75 2a		 jne	 SHORT $LN12@longest_ma
  00119	0f b6 4a 06	 movzx	 ecx, BYTE PTR [rdx+6]
  0011d	48 ff c0	 inc	 rax
  00120	38 08		 cmp	 BYTE PTR [rax], cl
  00122	75 1f		 jne	 SHORT $LN12@longest_ma
  00124	0f b6 4a 07	 movzx	 ecx, BYTE PTR [rdx+7]
  00128	48 ff c0	 inc	 rax
  0012b	38 08		 cmp	 BYTE PTR [rax], cl
  0012d	75 14		 jne	 SHORT $LN12@longest_ma
  0012f	0f b6 4a 08	 movzx	 ecx, BYTE PTR [rdx+8]
  00133	48 83 c2 08	 add	 rdx, 8
  00137	48 ff c0	 inc	 rax
  0013a	38 08		 cmp	 BYTE PTR [rax], cl
  0013c	75 05		 jne	 SHORT $LN12@longest_ma
  0013e	49 3b c0	 cmp	 rax, r8
  00141	72 9f		 jb	 SHORT $LL7@longest_ma
$LN12@longest_ma:

; 1471 :                  scan < strend);
; 1472 : 
; 1473 :         Assert(scan <= s->window + (unsigned)(s->window_size - 1),
; 1474 :                "wild scan");
; 1475 : 
; 1476 :         len = MAX_MATCH - (int)(strend - scan);

  00143	41 2b c0	 sub	 eax, r8d
  00146	8d 88 02 01 00
	00		 lea	 ecx, DWORD PTR [rax+258]

; 1477 :         scan = strend - MAX_MATCH;

  0014c	48 8b 44 24 30	 mov	 rax, QWORD PTR tv791[rsp]

; 1478 : 
; 1479 : #endif /* UNALIGNED_OK */
; 1480 : 
; 1481 :         if (len > best_len) {

  00151	3b cb		 cmp	 ecx, ebx
  00153	7e 23		 jle	 SHORT $LN2@longest_ma

; 1482 :             s->match_start = cur_match;

  00155	45 89 9e 98 00
	00 00		 mov	 DWORD PTR [r14+152], r11d

; 1483 :             best_len = len;

  0015c	8b d9		 mov	 ebx, ecx

; 1484 :             if (len >= nice_match) break;

  0015e	41 3b cf	 cmp	 ecx, r15d
  00161	7d 30		 jge	 SHORT $LN3@longest_ma

; 1485 : #ifdef UNALIGNED_OK
; 1486 :             scan_end = *(ushf*)(scan + best_len - 1);
; 1487 : #else
; 1488 :             scan_end1  = scan[best_len - 1];

  00163	48 63 c9	 movsxd	 rcx, ecx
  00166	42 0f b6 b4 01
	fd fe ff ff	 movzx	 esi, BYTE PTR [rcx+r8-259]

; 1489 :             scan_end   = scan[best_len];

  0016f	42 0f b6 ac 01
	fe fe ff ff	 movzx	 ebp, BYTE PTR [rcx+r8-258]
$LN2@longest_ma:

; 1490 : #endif
; 1491 :         }
; 1492 :     } while ((cur_match = prev[cur_match & wmask]) > limit
; 1493 :              && --chain_length != 0);

  00178	41 8b 4e 4c	 mov	 ecx, DWORD PTR [r14+76]
  0017c	49 23 c9	 and	 rcx, r9
  0017f	45 0f b7 5c 4d
	00		 movzx	 r11d, WORD PTR [r13+rcx*2]
  00185	45 3b dc	 cmp	 r11d, r12d
  00188	76 09		 jbe	 SHORT $LN3@longest_ma
  0018a	83 c7 ff	 add	 edi, -1			; ffffffffH
  0018d	0f 85 0d ff ff
	ff		 jne	 $LL4@longest_ma
$LN3@longest_ma:

; 1494 : 
; 1495 :     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
; 1496 :     return s->lookahead;
; 1497 : }

  00193	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00198	41 3b da	 cmp	 ebx, r10d
  0019b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001a0	44 0f 46 d3	 cmovbe	 r10d, ebx
  001a4	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  001a9	41 8b c2	 mov	 eax, r10d
  001ac	41 5f		 pop	 r15
  001ae	41 5e		 pop	 r14
  001b0	41 5d		 pop	 r13
  001b2	41 5c		 pop	 r12
  001b4	5f		 pop	 rdi
  001b5	c3		 ret	 0
longest_match ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflate_stored
_TEXT	SEGMENT
s$ = 80
used$1$ = 80
tv982 = 80
flush$ = 88
deflate_stored PROC					; COMDAT

; 1635 : local block_state deflate_stored(deflate_state *s, int flush) {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 57		 push	 r15
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1636 :     /* Smallest worthy block size when not flushing or finishing. By default
; 1637 :      * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
; 1638 :      * large input and output buffers, the stored block size will be larger.
; 1639 :      */
; 1640 :     unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);

  00009	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
  0000c	44 8b fa	 mov	 r15d, edx
  0000f	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00014	83 c0 fb	 add	 eax, -5			; fffffffbH
  00017	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  0001c	48 8b d9	 mov	 rbx, rcx
  0001f	44 8b 69 44	 mov	 r13d, DWORD PTR [rcx+68]

; 1641 : 
; 1642 :     /* Copy as many min_block or larger stored blocks directly to next_out as
; 1643 :      * possible. If flushing, copy the remaining available input to next_out as
; 1644 :      * stored blocks, if there is enough space.
; 1645 :      */
; 1646 :     int last = 0;

  00023	41 3b c5	 cmp	 eax, r13d

; 1647 :     unsigned len, left, have;
; 1648 :     unsigned used = s->strm->avail_in;

  00026	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0002b	44 0f 46 e8	 cmovbe	 r13d, eax
  0002f	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00034	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00037	33 ed		 xor	 ebp, ebp
  00039	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  0003e	44 8b 60 08	 mov	 r12d, DWORD PTR [rax+8]
  00042	44 89 64 24 50	 mov	 DWORD PTR used$1$[rsp], r12d
  00047	41 bc ff ff 00
	00		 mov	 r12d, 65535		; 0000ffffH
  0004d	0f 1f 00	 npad	 3
$LL4@deflate_st:

; 1649 :     do {
; 1650 :         /* Set len to the maximum size block that we can copy directly with the
; 1651 :          * available input data and output space. Set left to how much of that
; 1652 :          * would be copied from what's left in the window.
; 1653 :          */
; 1654 :         len = MAX_STORED;       /* maximum deflate stored block length */
; 1655 :         have = (s->bi_valid + 42) >> 3;         /* number of header bytes */

  00050	8b 83 10 17 00
	00		 mov	 eax, DWORD PTR [rbx+5904]

; 1656 :         if (s->strm->avail_out < have)          /* need room for header */

  00056	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00059	83 c0 2a	 add	 eax, 42			; 0000002aH
  0005c	c1 f8 03	 sar	 eax, 3
  0005f	8b 4a 18	 mov	 ecx, DWORD PTR [rdx+24]
  00062	3b c8		 cmp	 ecx, eax
  00064	0f 82 3c 01 00
	00		 jb	 $LN3@deflate_st

; 1657 :             break;
; 1658 :             /* maximum stored block length that will fit in avail_out: */
; 1659 :         have = s->strm->avail_out - have;
; 1660 :         left = s->strstart - s->block_start;    /* bytes left in window */

  0006a	44 8b b3 94 00
	00 00		 mov	 r14d, DWORD PTR [rbx+148]
  00071	2b c8		 sub	 ecx, eax
  00073	44 2b b3 84 00
	00 00		 sub	 r14d, DWORD PTR [rbx+132]

; 1661 :         if (len > (ulg)left + s->strm->avail_in)

  0007a	41 8b f4	 mov	 esi, r12d
  0007d	8b 52 08	 mov	 edx, DWORD PTR [rdx+8]
  00080	42 8d 04 32	 lea	 eax, DWORD PTR [rdx+r14]
  00084	41 3b c4	 cmp	 eax, r12d
  00087	0f 42 f0	 cmovb	 esi, eax

; 1662 :             len = left + s->strm->avail_in;     /* limit len to the input */
; 1663 :         if (len > have)

  0008a	3b f1		 cmp	 esi, ecx
  0008c	0f 47 f1	 cmova	 esi, ecx

; 1664 :             len = have;                         /* limit len to the output */
; 1665 : 
; 1666 :         /* If the stored block would be less than min_block in length, or if
; 1667 :          * unable to copy all of the available input when flushing, then try
; 1668 :          * copying to the window and the pending buffer instead. Also don't
; 1669 :          * write an empty block when flushing -- deflate() does that.
; 1670 :          */
; 1671 :         if (len < min_block && ((len == 0 && flush != Z_FINISH) ||

  0008f	41 3b f5	 cmp	 esi, r13d
  00092	73 25		 jae	 SHORT $LN51@deflate_st
  00094	85 f6		 test	 esi, esi
  00096	75 0c		 jne	 SHORT $LN10@deflate_st
  00098	41 83 ff 04	 cmp	 r15d, 4
  0009c	0f 85 04 01 00
	00		 jne	 $LN3@deflate_st
  000a2	eb 09		 jmp	 SHORT $LN69@deflate_st
$LN10@deflate_st:
  000a4	45 85 ff	 test	 r15d, r15d
  000a7	0f 84 f9 00 00
	00		 je	 $LN3@deflate_st
$LN69@deflate_st:
  000ad	42 8d 04 32	 lea	 eax, DWORD PTR [rdx+r14]
  000b1	3b f0		 cmp	 esi, eax
  000b3	0f 85 ed 00 00
	00		 jne	 $LN3@deflate_st
$LN51@deflate_st:

; 1672 :                                 flush == Z_NO_FLUSH ||
; 1673 :                                 len != left + s->strm->avail_in))
; 1674 :             break;
; 1675 : 
; 1676 :         /* Make a dummy stored block in pending to get the header bytes,
; 1677 :          * including any pending bits. This also updates the debugging counts.
; 1678 :          */
; 1679 :         last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;

  000b9	41 83 ff 04	 cmp	 r15d, 4
  000bd	75 0f		 jne	 SHORT $LN59@deflate_st
  000bf	42 8d 04 32	 lea	 eax, DWORD PTR [rdx+r14]
  000c3	3b f0		 cmp	 esi, eax
  000c5	75 07		 jne	 SHORT $LN59@deflate_st
  000c7	bd 01 00 00 00	 mov	 ebp, 1
  000cc	eb 02		 jmp	 SHORT $LN37@deflate_st
$LN59@deflate_st:
  000ce	33 ed		 xor	 ebp, ebp
$LN37@deflate_st:

; 1680 :         _tr_stored_block(s, (char *)0, 0L, last);

  000d0	44 8b cd	 mov	 r9d, ebp
  000d3	45 33 c0	 xor	 r8d, r8d
  000d6	33 d2		 xor	 edx, edx
  000d8	48 8b cb	 mov	 rcx, rbx
  000db	e8 00 00 00 00	 call	 _tr_stored_block

; 1681 : 
; 1682 :         /* Replace the lengths in the dummy stored block with len. */
; 1683 :         s->pending_buf[s->pending - 4] = (Bytef)len;

  000e0	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 1684 :         s->pending_buf[s->pending - 3] = (Bytef)(len >> 8);

  000e3	8b d6		 mov	 edx, esi
  000e5	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000e9	83 e9 04	 sub	 ecx, 4
  000ec	c1 ea 08	 shr	 edx, 8
  000ef	40 88 34 01	 mov	 BYTE PTR [rcx+rax], sil
  000f3	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000f6	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000fa	83 e9 03	 sub	 ecx, 3
  000fd	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1685 :         s->pending_buf[s->pending - 2] = (Bytef)~len;

  00100	40 0f b6 d6	 movzx	 edx, sil
  00104	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00107	f6 d2		 not	 dl
  00109	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0010d	83 e9 02	 sub	 ecx, 2
  00110	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1686 :         s->pending_buf[s->pending - 1] = (Bytef)(~len >> 8);

  00113	8b d6		 mov	 edx, esi
  00115	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00118	f7 d2		 not	 edx
  0011a	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0011e	ff c9		 dec	 ecx
  00120	c1 ea 08	 shr	 edx, 8
  00123	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1687 : 
; 1688 :         /* Write the stored block header bytes. */
; 1689 :         flush_pending(s->strm);

  00126	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00129	e8 00 00 00 00	 call	 flush_pending

; 1690 : 
; 1691 : #ifdef ZLIB_DEBUG
; 1692 :         /* Update debugging counts for the data about to be copied. */
; 1693 :         s->compressed_len += len << 3;
; 1694 :         s->bits_sent += len << 3;
; 1695 : #endif
; 1696 : 
; 1697 :         /* Copy uncompressed bytes from the window to next_out. */
; 1698 :         if (left) {

  0012e	45 85 f6	 test	 r14d, r14d
  00131	74 43		 je	 SHORT $LN64@deflate_st

; 1699 :             if (left > len)
; 1700 :                 left = len;
; 1701 :             zmemcpy(s->strm->next_out, s->window + s->block_start, left);

  00133	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00136	44 3b f6	 cmp	 r14d, esi
  00139	48 63 93 84 00
	00 00		 movsxd	 rdx, DWORD PTR [rbx+132]
  00140	44 0f 47 f6	 cmova	 r14d, esi
  00144	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  00148	45 8b c6	 mov	 r8d, r14d
  0014b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0014f	41 8b fe	 mov	 edi, r14d
  00152	e8 00 00 00 00	 call	 memcpy

; 1702 :             s->strm->next_out += left;

  00157	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0015a	48 01 78 10	 add	 QWORD PTR [rax+16], rdi

; 1703 :             s->strm->avail_out -= left;

  0015e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00161	44 29 70 18	 sub	 DWORD PTR [rax+24], r14d

; 1704 :             s->strm->total_out += left;

  00165	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00168	44 01 70 1c	 add	 DWORD PTR [rax+28], r14d

; 1705 :             s->block_start += left;

  0016c	44 01 b3 84 00
	00 00		 add	 DWORD PTR [rbx+132], r14d

; 1706 :             len -= left;

  00173	41 2b f6	 sub	 esi, r14d
$LN64@deflate_st:

; 1707 :         }
; 1708 : 
; 1709 :         /* Copy uncompressed bytes directly from next_in to next_out, updating
; 1710 :          * the check value.
; 1711 :          */
; 1712 :         if (len) {

  00176	85 f6		 test	 esi, esi
  00178	74 24		 je	 SHORT $LN2@deflate_st

; 1713 :             read_buf(s->strm, s->strm->next_out, len);

  0017a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0017d	44 8b c6	 mov	 r8d, esi
  00180	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  00184	e8 00 00 00 00	 call	 read_buf

; 1714 :             s->strm->next_out += len;

  00189	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0018c	8b c6		 mov	 eax, esi
  0018e	48 01 41 10	 add	 QWORD PTR [rcx+16], rax

; 1715 :             s->strm->avail_out -= len;

  00192	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00195	29 70 18	 sub	 DWORD PTR [rax+24], esi

; 1716 :             s->strm->total_out += len;

  00198	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0019b	01 70 1c	 add	 DWORD PTR [rax+28], esi
$LN2@deflate_st:

; 1717 :         }
; 1718 :     } while (last == 0);

  0019e	85 ed		 test	 ebp, ebp
  001a0	0f 84 aa fe ff
	ff		 je	 $LL4@deflate_st
$LN3@deflate_st:

; 1719 : 
; 1720 :     /* Update the sliding window with the last s->w_size bytes of the copied
; 1721 :      * data, or append all of the copied data to the existing window if less
; 1722 :      * than s->w_size bytes were copied. Also update the number of bytes to
; 1723 :      * insert in the hash tables, in the event that deflateParams() switches to
; 1724 :      * a non-zero compression level.
; 1725 :      */
; 1726 :     used -= s->strm->avail_in;      /* number of input bytes directly copied */

  001a6	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001a9	44 8b 64 24 50	 mov	 r12d, DWORD PTR used$1$[rsp]
  001ae	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  001b3	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]
  001b8	44 2b 60 08	 sub	 r12d, DWORD PTR [rax+8]

; 1727 :     if (used) {

  001bc	0f 84 c3 00 00
	00		 je	 $LN65@deflate_st

; 1728 :         /* If any input was used, then no unused input remains in the window,
; 1729 :          * therefore s->block_start == s->strstart.
; 1730 :          */
; 1731 :         if (used >= s->w_size) {    /* supplant the previous history */

  001c2	8b 53 44	 mov	 edx, DWORD PTR [rbx+68]
  001c5	44 3b e2	 cmp	 r12d, edx
  001c8	72 26		 jb	 SHORT $LN15@deflate_st

; 1732 :             s->matches = 2;         /* clear hash */
; 1733 :             zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);

  001ca	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  001ce	44 8b c2	 mov	 r8d, edx
  001d1	c7 83 04 17 00
	00 02 00 00 00	 mov	 DWORD PTR [rbx+5892], 2
  001db	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001de	49 2b d0	 sub	 rdx, r8
  001e1	e8 00 00 00 00	 call	 memcpy

; 1734 :             s->strstart = s->w_size;

  001e6	8b 53 44	 mov	 edx, DWORD PTR [rbx+68]

; 1735 :             s->insert = s->strstart;

  001e9	8b c2		 mov	 eax, edx

; 1736 :         }

  001eb	e9 83 00 00 00	 jmp	 $LN101@deflate_st
$LN15@deflate_st:

; 1737 :         else {
; 1738 :             if (s->window_size - s->strstart <= used) {

  001f0	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  001f6	8b 43 58	 mov	 eax, DWORD PTR [rbx+88]
  001f9	2b c1		 sub	 eax, ecx
  001fb	41 3b c4	 cmp	 eax, r12d
  001fe	77 3f		 ja	 SHORT $LN19@deflate_st

; 1739 :                 /* Slide the window down. */
; 1740 :                 s->strstart -= s->w_size;

  00200	2b ca		 sub	 ecx, edx
  00202	44 8b c1	 mov	 r8d, ecx

; 1741 :                 zmemcpy(s->window, s->window + s->w_size, s->strstart);

  00205	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  00209	48 03 d1	 add	 rdx, rcx
  0020c	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d
  00213	e8 00 00 00 00	 call	 memcpy

; 1742 :                 if (s->matches < 2)

  00218	8b 83 04 17 00
	00		 mov	 eax, DWORD PTR [rbx+5892]
  0021e	83 f8 02	 cmp	 eax, 2
  00221	73 08		 jae	 SHORT $LN18@deflate_st

; 1743 :                     s->matches++;   /* add a pending slide_hash() */

  00223	ff c0		 inc	 eax
  00225	89 83 04 17 00
	00		 mov	 DWORD PTR [rbx+5892], eax
$LN18@deflate_st:

; 1744 :                 if (s->insert > s->strstart)

  0022b	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00231	39 8b 08 17 00
	00		 cmp	 DWORD PTR [rbx+5896], ecx
  00237	76 06		 jbe	 SHORT $LN19@deflate_st

; 1745 :                     s->insert = s->strstart;

  00239	89 8b 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], ecx
$LN19@deflate_st:

; 1746 :             }
; 1747 :             zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);

  0023f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00242	48 03 4b 50	 add	 rcx, QWORD PTR [rbx+80]
  00246	45 8b c4	 mov	 r8d, r12d
  00249	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0024c	49 2b d0	 sub	 rdx, r8
  0024f	e8 00 00 00 00	 call	 memcpy

; 1748 :             s->strstart += used;
; 1749 :             s->insert += MIN(used, s->w_size - s->insert);

  00254	8b 8b 08 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5896]
  0025a	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]
  00260	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  00263	41 03 d4	 add	 edx, r12d
  00266	2b c1		 sub	 eax, ecx
  00268	44 3b e0	 cmp	 r12d, eax
  0026b	44 0f 47 e0	 cmova	 r12d, eax
  0026f	42 8d 04 21	 lea	 eax, DWORD PTR [rcx+r12]
$LN101@deflate_st:

; 1750 :         }
; 1751 :         s->block_start = s->strstart;

  00273	89 93 94 00 00
	00		 mov	 DWORD PTR [rbx+148], edx
  00279	89 83 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], eax
  0027f	89 93 84 00 00
	00		 mov	 DWORD PTR [rbx+132], edx
$LN65@deflate_st:

; 1752 :     }
; 1753 :     if (s->high_water < s->strstart)

  00285	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]
  0028b	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  00290	39 93 18 17 00
	00		 cmp	 DWORD PTR [rbx+5912], edx
  00296	73 06		 jae	 SHORT $LN20@deflate_st

; 1754 :         s->high_water = s->strstart;

  00298	89 93 18 17 00
	00		 mov	 DWORD PTR [rbx+5912], edx
$LN20@deflate_st:

; 1755 : 
; 1756 :     /* If the last block was written to next_out, then done. */
; 1757 :     if (last) {

  0029e	85 ed		 test	 ebp, ebp
  002a0	74 14		 je	 SHORT $LN21@deflate_st

; 1758 :         s->bi_used = 8;

  002a2	c7 83 14 17 00
	00 08 00 00 00	 mov	 DWORD PTR [rbx+5908], 8

; 1759 :         return finish_done;

  002ac	b8 03 00 00 00	 mov	 eax, 3
  002b1	e9 87 01 00 00	 jmp	 $LN1@deflate_st
$LN21@deflate_st:

; 1760 :     }
; 1761 : 
; 1762 :     /* If flushing and all input has been consumed, then done. */
; 1763 :     if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
; 1764 :         s->strm->avail_in == 0 && (long)s->strstart == s->block_start)

  002b6	41 f7 c7 fb ff
	ff ff		 test	 r15d, -5		; fffffffbH
  002bd	74 1b		 je	 SHORT $LN22@deflate_st
  002bf	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002c2	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  002c6	75 12		 jne	 SHORT $LN22@deflate_st
  002c8	3b 93 84 00 00
	00		 cmp	 edx, DWORD PTR [rbx+132]
  002ce	75 0a		 jne	 SHORT $LN22@deflate_st

; 1765 :         return block_done;

  002d0	b8 01 00 00 00	 mov	 eax, 1
  002d5	e9 63 01 00 00	 jmp	 $LN1@deflate_st
$LN22@deflate_st:

; 1766 : 
; 1767 :     /* Fill the window with any remaining input. */
; 1768 :     have = s->window_size - s->strstart;
; 1769 :     if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {

  002da	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002dd	8b 7b 58	 mov	 edi, DWORD PTR [rbx+88]
  002e0	2b fa		 sub	 edi, edx
  002e2	39 78 08	 cmp	 DWORD PTR [rax+8], edi
  002e5	76 58		 jbe	 SHORT $LN25@deflate_st
  002e7	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  002ea	8b 8b 84 00 00
	00		 mov	 ecx, DWORD PTR [rbx+132]
  002f0	3b c8		 cmp	 ecx, eax
  002f2	7c 4b		 jl	 SHORT $LN25@deflate_st

; 1770 :         /* Slide the window down. */
; 1771 :         s->block_start -= s->w_size;

  002f4	2b c8		 sub	 ecx, eax

; 1772 :         s->strstart -= s->w_size;

  002f6	2b d0		 sub	 edx, eax
  002f8	44 8b c2	 mov	 r8d, edx
  002fb	89 8b 84 00 00
	00		 mov	 DWORD PTR [rbx+132], ecx

; 1773 :         zmemcpy(s->window, s->window + s->w_size, s->strstart);

  00301	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  00305	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d
  0030c	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00310	e8 00 00 00 00	 call	 memcpy

; 1774 :         if (s->matches < 2)

  00315	8b 83 04 17 00
	00		 mov	 eax, DWORD PTR [rbx+5892]
  0031b	83 f8 02	 cmp	 eax, 2
  0031e	73 08		 jae	 SHORT $LN24@deflate_st

; 1775 :             s->matches++;           /* add a pending slide_hash() */

  00320	ff c0		 inc	 eax
  00322	89 83 04 17 00
	00		 mov	 DWORD PTR [rbx+5892], eax
$LN24@deflate_st:

; 1776 :         have += s->w_size;          /* more space now */

  00328	03 7b 44	 add	 edi, DWORD PTR [rbx+68]

; 1777 :         if (s->insert > s->strstart)

  0032b	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00331	39 83 08 17 00
	00		 cmp	 DWORD PTR [rbx+5896], eax
  00337	76 06		 jbe	 SHORT $LN25@deflate_st

; 1778 :             s->insert = s->strstart;

  00339	89 83 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], eax
$LN25@deflate_st:

; 1779 :     }
; 1780 :     if (have > s->strm->avail_in)

  0033f	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00342	8b 71 08	 mov	 esi, DWORD PTR [rcx+8]

; 1781 :         have = s->strm->avail_in;
; 1782 :     if (have) {

  00345	3b fe		 cmp	 edi, esi
  00347	0f 46 f7	 cmovbe	 esi, edi
  0034a	85 f6		 test	 esi, esi
  0034c	74 31		 je	 SHORT $LN66@deflate_st

; 1783 :         read_buf(s->strm, s->window + s->strstart, have);

  0034e	8b 93 94 00 00
	00		 mov	 edx, DWORD PTR [rbx+148]
  00354	44 8b c6	 mov	 r8d, esi
  00357	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0035b	e8 00 00 00 00	 call	 read_buf

; 1784 :         s->strstart += have;
; 1785 :         s->insert += MIN(have, s->w_size - s->insert);

  00360	8b 8b 08 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5896]
  00366	01 b3 94 00 00
	00		 add	 DWORD PTR [rbx+148], esi
  0036c	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  0036f	2b c1		 sub	 eax, ecx
  00371	3b f0		 cmp	 esi, eax
  00373	0f 47 f0	 cmova	 esi, eax
  00376	8d 04 31	 lea	 eax, DWORD PTR [rcx+rsi]
  00379	89 83 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], eax
$LN66@deflate_st:

; 1786 :     }
; 1787 :     if (s->high_water < s->strstart)

  0037f	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00385	39 8b 18 17 00
	00		 cmp	 DWORD PTR [rbx+5912], ecx
  0038b	73 06		 jae	 SHORT $LN28@deflate_st

; 1788 :         s->high_water = s->strstart;

  0038d	89 8b 18 17 00
	00		 mov	 DWORD PTR [rbx+5912], ecx
$LN28@deflate_st:

; 1789 : 
; 1790 :     /* There was not enough avail_out to write a complete worthy or flushed
; 1791 :      * stored block to next_out. Write a stored block to pending instead, if we
; 1792 :      * have enough input for a worthy block, or if flushing and there is enough
; 1793 :      * room for the remaining input as a stored block in the pending buffer.
; 1794 :      */
; 1795 :     have = (s->bi_valid + 42) >> 3;         /* number of header bytes */

  00393	8b 83 10 17 00
	00		 mov	 eax, DWORD PTR [rbx+5904]

; 1796 :         /* maximum stored block length that will fit in pending: */
; 1797 :     have = MIN(s->pending_buf_size - have, MAX_STORED);

  00399	8b 53 18	 mov	 edx, DWORD PTR [rbx+24]
  0039c	83 c0 2a	 add	 eax, 42			; 0000002aH
  0039f	c1 f8 03	 sar	 eax, 3
  003a2	2b d0		 sub	 edx, eax
  003a4	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  003a9	3b d0		 cmp	 edx, eax
  003ab	0f 47 d0	 cmova	 edx, eax

; 1798 :     min_block = MIN(have, s->w_size);
; 1799 :     left = s->strstart - s->block_start;

  003ae	2b 8b 84 00 00
	00		 sub	 ecx, DWORD PTR [rbx+132]
  003b4	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  003b7	3b d0		 cmp	 edx, eax
  003b9	0f 46 c2	 cmovbe	 eax, edx

; 1800 :     if (left >= min_block ||

  003bc	3b c8		 cmp	 ecx, eax
  003be	73 1e		 jae	 SHORT $LN67@deflate_st
  003c0	85 c9		 test	 ecx, ecx
  003c2	75 08		 jne	 SHORT $LN31@deflate_st
  003c4	41 83 ff 04	 cmp	 r15d, 4
  003c8	75 6c		 jne	 SHORT $LN32@deflate_st
  003ca	eb 05		 jmp	 SHORT $LN68@deflate_st
$LN31@deflate_st:
  003cc	45 85 ff	 test	 r15d, r15d
  003cf	74 65		 je	 SHORT $LN32@deflate_st
$LN68@deflate_st:
  003d1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003d4	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  003d8	75 5c		 jne	 SHORT $LN32@deflate_st
  003da	3b ca		 cmp	 ecx, edx
  003dc	77 58		 ja	 SHORT $LN32@deflate_st
$LN67@deflate_st:

; 1801 :         ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&
; 1802 :          s->strm->avail_in == 0 && left <= have)) {
; 1803 :         len = MIN(left, have);

  003de	3b ca		 cmp	 ecx, edx
  003e0	8b f9		 mov	 edi, ecx
  003e2	0f 47 fa	 cmova	 edi, edx

; 1804 :         last = flush == Z_FINISH && s->strm->avail_in == 0 &&

  003e5	41 83 ff 04	 cmp	 r15d, 4
  003e9	75 14		 jne	 SHORT $LN46@deflate_st
  003eb	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003ee	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  003f2	75 0b		 jne	 SHORT $LN46@deflate_st
  003f4	3b f9		 cmp	 edi, ecx
  003f6	75 07		 jne	 SHORT $LN46@deflate_st
  003f8	bd 01 00 00 00	 mov	 ebp, 1
  003fd	eb 02		 jmp	 SHORT $LN47@deflate_st
$LN46@deflate_st:
  003ff	33 ed		 xor	 ebp, ebp
$LN47@deflate_st:

; 1805 :                len == left ? 1 : 0;
; 1806 :         _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);

  00401	48 63 93 84 00
	00 00		 movsxd	 rdx, DWORD PTR [rbx+132]
  00408	44 8b cd	 mov	 r9d, ebp
  0040b	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0040f	44 8b c7	 mov	 r8d, edi
  00412	48 8b cb	 mov	 rcx, rbx
  00415	e8 00 00 00 00	 call	 _tr_stored_block

; 1807 :         s->block_start += len;
; 1808 :         flush_pending(s->strm);

  0041a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0041d	01 bb 84 00 00
	00		 add	 DWORD PTR [rbx+132], edi
  00423	e8 00 00 00 00	 call	 flush_pending

; 1809 :     }
; 1810 : 
; 1811 :     /* We've done all we can with the available input and output. */
; 1812 :     if (last)

  00428	85 ed		 test	 ebp, ebp
  0042a	74 0a		 je	 SHORT $LN32@deflate_st

; 1813 :         s->bi_used = 8;

  0042c	c7 83 14 17 00
	00 08 00 00 00	 mov	 DWORD PTR [rbx+5908], 8
$LN32@deflate_st:

; 1814 :     return last ? finish_started : need_more;

  00436	f7 dd		 neg	 ebp
  00438	1b c0		 sbb	 eax, eax
  0043a	83 e0 02	 and	 eax, 2
$LN1@deflate_st:

; 1815 : }

  0043d	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00442	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00447	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0044b	41 5f		 pop	 r15
  0044d	5d		 pop	 rbp
  0044e	5b		 pop	 rbx
  0044f	c3		 ret	 0
deflate_stored ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflate_fast
_TEXT	SEGMENT
s$ = 80
tv1091 = 80
flush$ = 88
deflate_fast PROC					; COMDAT

; 1824 : local block_state deflate_fast(deflate_state *s, int flush) {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001c	44 8b fa	 mov	 r15d, edx
  0001f	48 8d b1 94 00
	00 00		 lea	 rsi, QWORD PTR [rcx+148]
  00026	48 8b d9	 mov	 rbx, rcx
  00029	48 8d 79 50	 lea	 rdi, QWORD PTR [rcx+80]
  0002d	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:__ImageBase
  00034	33 ed		 xor	 ebp, ebp
  00036	41 bd 00 01 00
	00		 mov	 r13d, 256		; 00000100H
  0003c	0f 1f 40 00	 npad	 4
$LL4@deflate_fa:

; 1825 :     IPos hash_head;       /* head of the hash chain */
; 1826 :     int bflush;           /* set if current block must be flushed */
; 1827 : 
; 1828 :     for (;;) {
; 1829 :         /* Make sure that we always have enough lookahead, except
; 1830 :          * at the end of the input file. We need MAX_MATCH bytes
; 1831 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1832 :          * string following the next match.
; 1833 :          */
; 1834 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00040	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00046	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0004b	73 2d		 jae	 SHORT $LN10@deflate_fa

; 1835 :             fill_window(s);

  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 fill_window

; 1836 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00055	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  0005b	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00060	73 09		 jae	 SHORT $LN9@deflate_fa
  00062	45 85 ff	 test	 r15d, r15d
  00065	0f 84 ee 03 00
	00		 je	 $LN39@deflate_fa
$LN9@deflate_fa:

; 1837 :                 return need_more;
; 1838 :             }
; 1839 :             if (s->lookahead == 0) break; /* flush the current block */

  0006b	48 8d b3 94 00
	00 00		 lea	 rsi, QWORD PTR [rbx+148]
  00072	85 c0		 test	 eax, eax
  00074	0f 84 2a 03 00
	00		 je	 $LN38@deflate_fa
$LN10@deflate_fa:

; 1840 :         }
; 1841 : 
; 1842 :         /* Insert the string window[strstart .. strstart + 2] in the
; 1843 :          * dictionary, and set hash_head to the head of the hash chain:
; 1844 :          */
; 1845 :         hash_head = NIL;
; 1846 :         if (s->lookahead >= MIN_MATCH) {

  0007a	83 f8 03	 cmp	 eax, 3
  0007d	0f 82 8e 00 00
	00		 jb	 $LN12@deflate_fa

; 1847 :             INSERT_STRING(s, s->strstart, hash_head);

  00083	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  00089	48 8d 7b 50	 lea	 rdi, QWORD PTR [rbx+80]
  0008d	44 8b 43 70	 mov	 r8d, DWORD PTR [rbx+112]
  00091	44 8b 16	 mov	 r10d, DWORD PTR [rsi]
  00094	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00097	41 d3 e0	 shl	 r8d, cl
  0009a	41 8d 4a 02	 lea	 ecx, DWORD PTR [r10+2]
  0009e	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  000a2	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000a5	44 33 c2	 xor	 r8d, edx
  000a8	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  000ac	4c 23 d0	 and	 r10, rax
  000af	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  000b3	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000b7	45 8b c8	 mov	 r9d, r8d
  000ba	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  000be	42 0f b7 04 42	 movzx	 eax, WORD PTR [rdx+r8*2]
  000c3	66 42 89 04 51	 mov	 WORD PTR [rcx+r10*2], ax
  000c8	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]
  000cb	44 8b 06	 mov	 r8d, DWORD PTR [rsi]
  000ce	41 8b c8	 mov	 ecx, r8d
  000d1	48 23 c8	 and	 rcx, rax
  000d4	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000d8	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  000dc	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  000df	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  000e3	66 44 89 04 48	 mov	 WORD PTR [rax+rcx*2], r8w

; 1848 :         }
; 1849 : 
; 1850 :         /* Find the longest match, discarding those <= prev_length.
; 1851 :          * At this point we have always match_length < MIN_MATCH
; 1852 :          */
; 1853 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  000e8	85 d2		 test	 edx, edx
  000ea	74 1e		 je	 SHORT $LN63@deflate_fa
  000ec	8b 0e		 mov	 ecx, DWORD PTR [rsi]
  000ee	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  000f1	2b ca		 sub	 ecx, edx
  000f3	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  000f8	3b c8		 cmp	 ecx, eax
  000fa	77 0e		 ja	 SHORT $LN63@deflate_fa

; 1854 :             /* To simplify the code, we prevent matches with the string
; 1855 :              * of window index 0 (in particular we have to avoid a match
; 1856 :              * of the string with itself at the start of the input file).
; 1857 :              */
; 1858 :             s->match_length = longest_match (s, hash_head);

  000fc	48 8b cb	 mov	 rcx, rbx
  000ff	e8 00 00 00 00	 call	 longest_match
  00104	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax
$LN63@deflate_fa:

; 1859 :             /* longest_match() sets match_start */
; 1860 :         }
; 1861 :         if (s->match_length >= MIN_MATCH) {

  0010a	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:__ImageBase
$LN12@deflate_fa:
  00111	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [rbx+136]
  00117	83 f8 03	 cmp	 eax, 3
  0011a	0f 82 b5 01 00
	00		 jb	 $LN13@deflate_fa

; 1862 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1863 : 
; 1864 :             _tr_tally_dist(s, s->strstart - s->match_start,

  00120	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00126	2c 03		 sub	 al, 3
  00128	44 0f b7 0e	 movzx	 r9d, WORD PTR [rsi]
  0012c	66 44 2b 8b 98
	00 00 00	 sub	 r9w, WORD PTR [rbx+152]
  00134	44 0f b6 c0	 movzx	 r8d, al
  00138	41 0f b7 d1	 movzx	 edx, r9w
  0013c	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00143	66 c1 ea 08	 shr	 dx, 8
  00147	44 88 0c 01	 mov	 BYTE PTR [rcx+rax], r9b
  0014b	66 41 ff c9	 dec	 r9w
  0014f	8b 83 f4 16 00
	00		 mov	 eax, DWORD PTR [rbx+5876]
  00155	ff c0		 inc	 eax
  00157	89 83 f4 16 00
	00		 mov	 DWORD PTR [rbx+5876], eax
  0015d	8b c8		 mov	 ecx, eax
  0015f	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00166	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00169	8b 83 f4 16 00
	00		 mov	 eax, DWORD PTR [rbx+5876]
  0016f	ff c0		 inc	 eax
  00171	89 83 f4 16 00
	00		 mov	 DWORD PTR [rbx+5876], eax
  00177	8b c8		 mov	 ecx, eax
  00179	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00180	44 88 04 01	 mov	 BYTE PTR [rcx+rax], r8b
  00184	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0018a	43 0f b6 84 30
	00 00 00 00	 movzx	 eax, BYTE PTR _length_code[r8+r14]
  00193	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  0019b	66 45 3b cd	 cmp	 r9w, r13w
  0019f	73 06		 jae	 SHORT $LN24@deflate_fa
  001a1	41 0f b7 c1	 movzx	 eax, r9w
  001a5	eb 0a		 jmp	 SHORT $LN25@deflate_fa
$LN24@deflate_fa:
  001a7	41 0f b7 c1	 movzx	 eax, r9w
  001ab	c1 e8 07	 shr	 eax, 7
  001ae	41 03 c5	 add	 eax, r13d
$LN25@deflate_fa:
  001b1	42 0f b6 84 30
	00 00 00 00	 movzx	 eax, BYTE PTR _dist_code[rax+r14]
  001ba	44 8b d5	 mov	 r10d, ebp
  001bd	66 ff 84 83 b0
	09 00 00	 inc	 WORD PTR [rbx+rax*4+2480]
  001c5	8b 83 f8 16 00
	00		 mov	 eax, DWORD PTR [rbx+5880]
  001cb	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 1865 :                            s->match_length - MIN_MATCH, bflush);
; 1866 : 
; 1867 :             s->lookahead -= s->match_length;

  001d1	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  001d7	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [rbx+136]
  001dd	41 0f 94 c2	 sete	 r10b
  001e1	2b c1		 sub	 eax, ecx
  001e3	89 83 9c 00 00
	00		 mov	 DWORD PTR [rbx+156], eax

; 1868 : 
; 1869 :             /* Insert new strings in the hash table only if the match length
; 1870 :              * is not too large. This saves time but degrades compression.
; 1871 :              */
; 1872 : #ifndef FASTEST
; 1873 :             if (s->match_length <= s->max_insert_length &&

  001e9	3b 8b a8 00 00
	00		 cmp	 ecx, DWORD PTR [rbx+168]
  001ef	0f 87 97 00 00
	00		 ja	 $LN57@deflate_fa
  001f5	83 f8 03	 cmp	 eax, 3
  001f8	0f 82 8e 00 00
	00		 jb	 $LN57@deflate_fa

; 1874 :                 s->lookahead >= MIN_MATCH) {
; 1875 :                 s->match_length--; /* string at strstart already in table */

  001fe	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00201	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax
  00207	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@deflate_fa:

; 1876 :                 do {
; 1877 :                     s->strstart++;

  00210	ff 83 94 00 00
	00		 inc	 DWORD PTR [rbx+148]

; 1878 :                     INSERT_STRING(s, s->strstart, hash_head);

  00216	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0021a	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]
  00221	8b 53 4c	 mov	 edx, DWORD PTR [rbx+76]
  00224	49 23 d1	 and	 rdx, r9
  00227	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  0022b	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  00230	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00233	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  00239	d3 e0		 shl	 eax, cl
  0023b	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0023f	44 33 c0	 xor	 r8d, eax
  00242	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  00246	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  0024a	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  0024e	42 0f b7 04 40	 movzx	 eax, WORD PTR [rax+r8*2]
  00253	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00257	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  0025a	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0025e	0f b7 83 94 00
	00 00		 movzx	 eax, WORD PTR [rbx+148]
  00265	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax

; 1879 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1880 :                      * always MIN_MATCH bytes ahead.
; 1881 :                      */
; 1882 :                 } while (--s->match_length != 0);

  00269	83 83 88 00 00
	00 ff		 add	 DWORD PTR [rbx+136], -1	; ffffffffH
  00270	75 9e		 jne	 SHORT $LL7@deflate_fa

; 1883 :                 s->strstart++;

  00272	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]

; 1888 :                 s->match_length = 0;
; 1889 :                 s->ins_h = s->window[s->strstart];
; 1890 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart + 1]);
; 1891 : #if MIN_MATCH != 3
; 1892 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1893 : #endif
; 1894 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1895 :                  * matter since it will be recomputed at next deflate call.
; 1896 :                  */
; 1897 :             }
; 1898 :         } else {

  00279	48 8d 7b 50	 lea	 rdi, QWORD PTR [rbx+80]
  0027d	41 ff c0	 inc	 r8d
  00280	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d
  00287	e9 c4 00 00 00	 jmp	 $LN14@deflate_fa
$LN57@deflate_fa:

; 1884 :             } else
; 1885 : #endif
; 1886 :             {
; 1887 :                 s->strstart += s->match_length;

  0028c	44 8b 8b 94 00
	00 00		 mov	 r9d, DWORD PTR [rbx+148]

; 1888 :                 s->match_length = 0;
; 1889 :                 s->ins_h = s->window[s->strstart];
; 1890 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart + 1]);
; 1891 : #if MIN_MATCH != 3
; 1892 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1893 : #endif
; 1894 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1895 :                  * matter since it will be recomputed at next deflate call.
; 1896 :                  */
; 1897 :             }
; 1898 :         } else {

  00293	48 8d 7b 50	 lea	 rdi, QWORD PTR [rbx+80]
  00297	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]
  0029b	44 03 c9	 add	 r9d, ecx
  0029e	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  002a4	44 89 8b 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r9d
  002ab	89 ab 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ebp
  002b1	45 0f b6 04 11	 movzx	 r8d, BYTE PTR [r9+rdx]
  002b6	41 8d 41 01	 lea	 eax, DWORD PTR [r9+1]
  002ba	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  002be	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  002c2	41 d3 e0	 shl	 r8d, cl
  002c5	44 33 c0	 xor	 r8d, eax
  002c8	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  002cc	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  002d0	45 8b c1	 mov	 r8d, r9d
  002d3	eb 7b		 jmp	 SHORT $LN14@deflate_fa
$LN13@deflate_fa:

; 1899 :             /* No match, output a literal byte */
; 1900 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1901 :             _tr_tally_lit(s, s->window[s->strstart], bflush);

  002d5	8b 0e		 mov	 ecx, DWORD PTR [rsi]
  002d7	44 8b d5	 mov	 r10d, ebp
  002da	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  002dd	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  002e1	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  002e8	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  002ee	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
  002f2	8b 83 f4 16 00
	00		 mov	 eax, DWORD PTR [rbx+5876]
  002f8	ff c0		 inc	 eax
  002fa	89 83 f4 16 00
	00		 mov	 DWORD PTR [rbx+5876], eax
  00300	8b c8		 mov	 ecx, eax
  00302	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00309	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
  0030d	8b 83 f4 16 00
	00		 mov	 eax, DWORD PTR [rbx+5876]
  00313	ff c0		 inc	 eax
  00315	89 83 f4 16 00
	00		 mov	 DWORD PTR [rbx+5876], eax
  0031b	8b c8		 mov	 ecx, eax
  0031d	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00324	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00327	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0032d	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  00335	8b 83 f8 16 00
	00		 mov	 eax, DWORD PTR [rbx+5880]
  0033b	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  00341	41 0f 94 c2	 sete	 r10b

; 1902 :             s->lookahead--;

  00345	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]

; 1903 :             s->strstart++;

  0034b	ff 06		 inc	 DWORD PTR [rsi]
  0034d	44 8b 06	 mov	 r8d, DWORD PTR [rsi]
$LN14@deflate_fa:

; 1904 :         }
; 1905 :         if (bflush) FLUSH_BLOCK(s, 0);

  00350	45 85 d2	 test	 r10d, r10d
  00353	0f 84 e7 fc ff
	ff		 je	 $LL4@deflate_fa
  00359	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0035f	85 c0		 test	 eax, eax
  00361	78 07		 js	 SHORT $LN26@deflate_fa
  00363	8b d0		 mov	 edx, eax
  00365	48 03 17	 add	 rdx, QWORD PTR [rdi]
  00368	eb 03		 jmp	 SHORT $LN27@deflate_fa
$LN26@deflate_fa:
  0036a	48 8b d5	 mov	 rdx, rbp
$LN27@deflate_fa:
  0036d	44 2b c0	 sub	 r8d, eax
  00370	45 33 c9	 xor	 r9d, r9d
  00373	48 8b cb	 mov	 rcx, rbx
  00376	e8 00 00 00 00	 call	 _tr_flush_block
  0037b	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00381	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00384	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  0038a	e8 00 00 00 00	 call	 flush_pending
  0038f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00392	39 68 18	 cmp	 DWORD PTR [rax+24], ebp
  00395	0f 84 be 00 00
	00		 je	 $LN39@deflate_fa
  0039b	48 8d 7b 50	 lea	 rdi, QWORD PTR [rbx+80]
  0039f	e9 9c fc ff ff	 jmp	 $LL4@deflate_fa
$LN38@deflate_fa:

; 1906 :     }
; 1907 :     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;

  003a4	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  003ab	b8 02 00 00 00	 mov	 eax, 2
  003b0	44 3b c0	 cmp	 r8d, eax
  003b3	41 0f 42 c0	 cmovb	 eax, r8d
  003b7	89 83 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], eax

; 1908 :     if (flush == Z_FINISH) {

  003bd	41 83 ff 04	 cmp	 r15d, 4
  003c1	75 49		 jne	 SHORT $LN19@deflate_fa

; 1909 :         FLUSH_BLOCK(s, 1);

  003c3	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  003c9	85 c0		 test	 eax, eax
  003cb	78 08		 js	 SHORT $LN30@deflate_fa
  003cd	8b d0		 mov	 edx, eax
  003cf	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  003d3	eb 03		 jmp	 SHORT $LN31@deflate_fa
$LN30@deflate_fa:
  003d5	48 8b d5	 mov	 rdx, rbp
$LN31@deflate_fa:
  003d8	44 2b c0	 sub	 r8d, eax
  003db	41 b9 01 00 00
	00		 mov	 r9d, 1
  003e1	48 8b cb	 mov	 rcx, rbx
  003e4	e8 00 00 00 00	 call	 _tr_flush_block
  003e9	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  003ef	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003f2	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  003f8	e8 00 00 00 00	 call	 flush_pending
  003fd	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00400	39 68 18	 cmp	 DWORD PTR [rax+24], ebp
  00403	40 0f 95 c5	 setne	 bpl
  00407	8d 45 02	 lea	 eax, DWORD PTR [rbp+2]
  0040a	eb 4f		 jmp	 SHORT $LN1@deflate_fa
$LN19@deflate_fa:

; 1910 :         return finish_done;
; 1911 :     }
; 1912 :     if (s->sym_next)

  0040c	39 ab f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], ebp
  00412	74 3e		 je	 SHORT $LN22@deflate_fa

; 1913 :         FLUSH_BLOCK(s, 0);

  00414	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0041a	85 c0		 test	 eax, eax
  0041c	78 06		 js	 SHORT $LN32@deflate_fa
  0041e	8b e8		 mov	 ebp, eax
  00420	48 03 6b 50	 add	 rbp, QWORD PTR [rbx+80]
$LN32@deflate_fa:
  00424	44 2b c0	 sub	 r8d, eax
  00427	45 33 c9	 xor	 r9d, r9d
  0042a	48 8b d5	 mov	 rdx, rbp
  0042d	48 8b cb	 mov	 rcx, rbx
  00430	e8 00 00 00 00	 call	 _tr_flush_block
  00435	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0043b	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0043e	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00444	e8 00 00 00 00	 call	 flush_pending
  00449	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0044c	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00450	74 07		 je	 SHORT $LN39@deflate_fa
$LN22@deflate_fa:

; 1914 :     return block_done;

  00452	b8 01 00 00 00	 mov	 eax, 1
  00457	eb 02		 jmp	 SHORT $LN1@deflate_fa
$LN39@deflate_fa:

; 1904 :         }
; 1905 :         if (bflush) FLUSH_BLOCK(s, 0);

  00459	33 c0		 xor	 eax, eax
$LN1@deflate_fa:

; 1915 : }

  0045b	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00460	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00465	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0046a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0046e	41 5f		 pop	 r15
  00470	41 5e		 pop	 r14
  00472	41 5d		 pop	 r13
  00474	41 5c		 pop	 r12
  00476	5f		 pop	 rdi
  00477	c3		 ret	 0
deflate_fast ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflate_slow
_TEXT	SEGMENT
s$ = 80
tv1238 = 80
flush$ = 88
deflate_slow PROC					; COMDAT

; 1923 : local block_state deflate_slow(deflate_state *s, int flush) {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001c	44 8b ea	 mov	 r13d, edx
  0001f	48 8d b9 94 00
	00 00		 lea	 rdi, QWORD PTR [rcx+148]
  00026	48 8b d9	 mov	 rbx, rcx
  00029	4c 8d b1 94 00
	00 00		 lea	 r14, QWORD PTR [rcx+148]
  00030	33 ed		 xor	 ebp, ebp
  00032	be 02 00 00 00	 mov	 esi, 2
  00037	41 bf 00 01 00
	00		 mov	 r15d, 256		; 00000100H
  0003d	0f 1f 00	 npad	 3
$LL4@deflate_sl:

; 1924 :     IPos hash_head;          /* head of hash chain */
; 1925 :     int bflush;              /* set if current block must be flushed */
; 1926 : 
; 1927 :     /* Process the input block. */
; 1928 :     for (;;) {
; 1929 :         /* Make sure that we always have enough lookahead, except
; 1930 :          * at the end of the input file. We need MAX_MATCH bytes
; 1931 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1932 :          * string following the next match.
; 1933 :          */
; 1934 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00040	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00046	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  0004b	73 34		 jae	 SHORT $LN10@deflate_sl

; 1935 :             fill_window(s);

  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 fill_window

; 1936 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00055	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  0005b	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00060	73 10		 jae	 SHORT $LN9@deflate_sl
  00062	45 85 ed	 test	 r13d, r13d
  00065	0f 84 8c 03 00
	00		 je	 $LN48@deflate_sl
  0006b	4c 8d b3 94 00
	00 00		 lea	 r14, QWORD PTR [rbx+148]
$LN9@deflate_sl:

; 1937 :                 return need_more;
; 1938 :             }
; 1939 :             if (s->lookahead == 0) break; /* flush the current block */

  00072	48 8d bb 94 00
	00 00		 lea	 rdi, QWORD PTR [rbx+148]
  00079	85 c0		 test	 eax, eax
  0007b	0f 84 b1 03 00
	00		 je	 $LN46@deflate_sl
$LN10@deflate_sl:

; 1940 :         }
; 1941 : 
; 1942 :         /* Insert the string window[strstart .. strstart + 2] in the
; 1943 :          * dictionary, and set hash_head to the head of the hash chain:
; 1944 :          */
; 1945 :         hash_head = NIL;

  00081	44 8b cd	 mov	 r9d, ebp

; 1946 :         if (s->lookahead >= MIN_MATCH) {

  00084	83 f8 03	 cmp	 eax, 3
  00087	72 59		 jb	 SHORT $LN11@deflate_sl

; 1947 :             INSERT_STRING(s, s->strstart, hash_head);

  00089	44 8b 0f	 mov	 r9d, DWORD PTR [rdi]
  0008c	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00090	8b 53 4c	 mov	 edx, DWORD PTR [rbx+76]
  00093	49 23 d1	 and	 rdx, r9
  00096	41 8d 49 02	 lea	 ecx, DWORD PTR [r9+2]
  0009a	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  0009f	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000a2	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  000a8	d3 e0		 shl	 eax, cl
  000aa	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000ae	44 33 c0	 xor	 r8d, eax
  000b1	44 23 43 7c	 and	 r8d, DWORD PTR [rbx+124]
  000b5	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  000b9	44 89 43 70	 mov	 DWORD PTR [rbx+112], r8d
  000bd	42 0f b7 04 40	 movzx	 eax, WORD PTR [rax+r8*2]
  000c2	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  000c6	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  000ca	8b 17		 mov	 edx, DWORD PTR [rdi]
  000cc	8b 4b 4c	 mov	 ecx, DWORD PTR [rbx+76]
  000cf	48 23 ca	 and	 rcx, rdx
  000d2	44 0f b7 0c 48	 movzx	 r9d, WORD PTR [rax+rcx*2]
  000d7	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  000da	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  000de	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
$LN11@deflate_sl:

; 1948 :         }
; 1949 : 
; 1950 :         /* Find the longest match, discarding those <= prev_length.
; 1951 :          */
; 1952 :         s->prev_length = s->match_length, s->prev_match = s->match_start;

  000e2	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [rbx+136]

; 1953 :         s->match_length = MIN_MATCH-1;

  000e8	44 8b c6	 mov	 r8d, esi
  000eb	8b 83 98 00 00
	00		 mov	 eax, DWORD PTR [rbx+152]
  000f1	89 8b a0 00 00
	00		 mov	 DWORD PTR [rbx+160], ecx
  000f7	89 83 8c 00 00
	00		 mov	 DWORD PTR [rbx+140], eax
  000fd	89 b3 88 00 00
	00		 mov	 DWORD PTR [rbx+136], esi

; 1954 : 
; 1955 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&

  00103	45 85 c9	 test	 r9d, r9d
  00106	74 5c		 je	 SHORT $LN13@deflate_sl
  00108	3b 8b a8 00 00
	00		 cmp	 ecx, DWORD PTR [rbx+168]
  0010e	73 54		 jae	 SHORT $LN13@deflate_sl
  00110	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00112	8b 43 44	 mov	 eax, DWORD PTR [rbx+68]
  00115	41 2b c9	 sub	 ecx, r9d
  00118	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  0011d	3b c8		 cmp	 ecx, eax
  0011f	77 43		 ja	 SHORT $LN13@deflate_sl

; 1956 :             s->strstart - hash_head <= MAX_DIST(s)) {
; 1957 :             /* To simplify the code, we prevent matches with the string
; 1958 :              * of window index 0 (in particular we have to avoid a match
; 1959 :              * of the string with itself at the start of the input file).
; 1960 :              */
; 1961 :             s->match_length = longest_match (s, hash_head);

  00121	41 8b d1	 mov	 edx, r9d
  00124	48 8b cb	 mov	 rcx, rbx
  00127	e8 00 00 00 00	 call	 longest_match
  0012c	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax

; 1962 :             /* longest_match() sets match_start */
; 1963 : 
; 1964 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED

  00132	44 8b c0	 mov	 r8d, eax
  00135	83 f8 05	 cmp	 eax, 5
  00138	77 2a		 ja	 SHORT $LN13@deflate_sl
  0013a	83 bb b0 00 00
	00 01		 cmp	 DWORD PTR [rbx+176], 1
  00141	74 18		 je	 SHORT $LN14@deflate_sl
  00143	83 f8 03	 cmp	 eax, 3
  00146	75 1c		 jne	 SHORT $LN13@deflate_sl
  00148	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0014e	2b 83 98 00 00
	00		 sub	 eax, DWORD PTR [rbx+152]
  00154	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00159	76 09		 jbe	 SHORT $LN13@deflate_sl
$LN14@deflate_sl:

; 1965 : #if TOO_FAR <= 32767
; 1966 :                 || (s->match_length == MIN_MATCH &&
; 1967 :                     s->strstart - s->match_start > TOO_FAR)
; 1968 : #endif
; 1969 :                 )) {
; 1970 : 
; 1971 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1972 :                  * but we will ignore the current match anyway.
; 1973 :                  */
; 1974 :                 s->match_length = MIN_MATCH-1;

  0015b	89 b3 88 00 00
	00		 mov	 DWORD PTR [rbx+136], esi
  00161	44 8b c6	 mov	 r8d, esi
$LN13@deflate_sl:

; 1975 :             }
; 1976 :         }
; 1977 :         /* If there was a match at the previous step and the current
; 1978 :          * match is not better, output the previous match:
; 1979 :          */
; 1980 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  00164	8b 93 a0 00 00
	00		 mov	 edx, DWORD PTR [rbx+160]
  0016a	83 fa 03	 cmp	 edx, 3
  0016d	0f 82 c4 01 00
	00		 jb	 $LN57@deflate_sl
  00173	44 3b c2	 cmp	 r8d, edx
  00176	0f 87 bb 01 00
	00		 ja	 $LN57@deflate_sl

; 1981 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;

  0017c	44 8b 9b 9c 00
	00 00		 mov	 r11d, DWORD PTR [rbx+156]
  00183	48 8d bb 94 00
	00 00		 lea	 rdi, QWORD PTR [rbx+148]
  0018a	8b 0f		 mov	 ecx, DWORD PTR [rdi]

; 1982 :             /* Do not insert strings in hash table beyond this. */
; 1983 : 
; 1984 :             check_match(s, s->strstart - 1, s->prev_match, s->prev_length);
; 1985 : 
; 1986 :             _tr_tally_dist(s, s->strstart - 1 - s->prev_match,

  0018c	80 ea 03	 sub	 dl, 3
  0018f	44 0f b7 8b 8c
	00 00 00	 movzx	 r9d, WORD PTR [rbx+140]
  00197	41 83 c3 fd	 add	 r11d, -3		; fffffffdH
  0019b	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  001a2	44 03 d9	 add	 r11d, ecx
  001a5	44 0f b6 c2	 movzx	 r8d, dl
  001a9	66 41 f7 d1	 not	 r9w
  001ad	66 44 03 c9	 add	 r9w, cx
  001b1	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001b7	44 88 0c 01	 mov	 BYTE PTR [rcx+rax], r9b
  001bb	41 0f b7 c9	 movzx	 ecx, r9w
  001bf	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  001c5	66 41 ff c9	 dec	 r9w
  001c9	8b 93 f4 16 00
	00		 mov	 edx, DWORD PTR [rbx+5876]
  001cf	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  001d6	66 c1 e9 08	 shr	 cx, 8
  001da	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl
  001dd	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  001e3	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001e9	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  001f0	44 88 04 01	 mov	 BYTE PTR [rcx+rax], r8b
  001f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  001fb	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00201	41 0f b6 84 08
	00 00 00 00	 movzx	 eax, BYTE PTR _length_code[r8+rcx]
  0020a	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  00212	66 45 3b cf	 cmp	 r9w, r15w
  00216	73 06		 jae	 SHORT $LN30@deflate_sl
  00218	41 0f b7 c1	 movzx	 eax, r9w
  0021c	eb 0a		 jmp	 SHORT $LN31@deflate_sl
$LN30@deflate_sl:
  0021e	41 0f b7 c1	 movzx	 eax, r9w
  00222	c1 e8 07	 shr	 eax, 7
  00225	41 03 c7	 add	 eax, r15d
$LN31@deflate_sl:
  00228	0f b6 84 08 00
	00 00 00	 movzx	 eax, BYTE PTR _dist_code[rax+rcx]
  00230	66 ff 84 83 b0
	09 00 00	 inc	 WORD PTR [rbx+rax*4+2480]

; 1987 :                            s->prev_length - MIN_MATCH, bflush);
; 1988 : 
; 1989 :             /* Insert in hash table all strings up to the end of the match.
; 1990 :              * strstart - 1 and strstart are already inserted. If there is not
; 1991 :              * enough lookahead, the last two strings are not inserted in
; 1992 :              * the hash table.
; 1993 :              */
; 1994 :             s->lookahead -= s->prev_length - 1;

  00238	b8 01 00 00 00	 mov	 eax, 1
  0023d	8b 8b a0 00 00
	00		 mov	 ecx, DWORD PTR [rbx+160]
  00243	2b c1		 sub	 eax, ecx
  00245	01 83 9c 00 00
	00		 add	 DWORD PTR [rbx+156], eax
  0024b	44 8b b3 f8 16
	00 00		 mov	 r14d, DWORD PTR [rbx+5880]
  00252	44 8b bb f4 16
	00 00		 mov	 r15d, DWORD PTR [rbx+5876]

; 1995 :             s->prev_length -= 2;

  00259	8d 41 fe	 lea	 eax, DWORD PTR [rcx-2]
  0025c	89 83 a0 00 00
	00		 mov	 DWORD PTR [rbx+160], eax
$LL7@deflate_sl:

; 1996 :             do {
; 1997 :                 if (++s->strstart <= max_insert) {

  00262	44 8b 17	 mov	 r10d, DWORD PTR [rdi]
  00265	41 ff c2	 inc	 r10d
  00268	44 89 17	 mov	 DWORD PTR [rdi], r10d
  0026b	45 3b d3	 cmp	 r10d, r11d
  0026e	77 51		 ja	 SHORT $LN5@deflate_sl

; 1998 :                     INSERT_STRING(s, s->strstart, hash_head);

  00270	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  00276	44 8b 4b 70	 mov	 r9d, DWORD PTR [rbx+112]
  0027a	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0027e	44 8b 43 4c	 mov	 r8d, DWORD PTR [rbx+76]
  00282	41 d3 e1	 shl	 r9d, cl
  00285	41 8d 4a 02	 lea	 ecx, DWORD PTR [r10+2]
  00289	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  0028d	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00291	44 33 ca	 xor	 r9d, edx
  00294	44 23 4b 7c	 and	 r9d, DWORD PTR [rbx+124]
  00298	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0029c	44 89 4b 70	 mov	 DWORD PTR [rbx+112], r9d
  002a0	41 8b c2	 mov	 eax, r10d
  002a3	4c 23 c0	 and	 r8, rax
  002a6	42 0f b7 04 4a	 movzx	 eax, WORD PTR [rdx+r9*2]
  002ab	66 42 89 04 41	 mov	 WORD PTR [rcx+r8*2], ax
  002b0	8b 53 70	 mov	 edx, DWORD PTR [rbx+112]
  002b3	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  002b7	0f b7 07	 movzx	 eax, WORD PTR [rdi]
  002ba	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  002be	44 8b 17	 mov	 r10d, DWORD PTR [rdi]
$LN5@deflate_sl:

; 1999 :                 }
; 2000 :             } while (--s->prev_length != 0);

  002c1	83 83 a0 00 00
	00 ff		 add	 DWORD PTR [rbx+160], -1	; ffffffffH
  002c8	75 98		 jne	 SHORT $LL7@deflate_sl

; 2001 :             s->match_available = 0;

  002ca	89 ab 90 00 00
	00		 mov	 DWORD PTR [rbx+144], ebp

; 2002 :             s->match_length = MIN_MATCH-1;
; 2003 :             s->strstart++;

  002d0	45 8d 42 01	 lea	 r8d, DWORD PTR [r10+1]
  002d4	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d
  002db	89 b3 88 00 00
	00		 mov	 DWORD PTR [rbx+136], esi

; 2004 : 
; 2005 :             if (bflush) FLUSH_BLOCK(s, 0);

  002e1	45 3b fe	 cmp	 r15d, r14d
  002e4	75 43		 jne	 SHORT $LN19@deflate_sl
  002e6	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002ec	85 c0		 test	 eax, eax
  002ee	78 08		 js	 SHORT $LN32@deflate_sl
  002f0	8b d0		 mov	 edx, eax
  002f2	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  002f6	eb 03		 jmp	 SHORT $LN33@deflate_sl
$LN32@deflate_sl:
  002f8	48 8b d5	 mov	 rdx, rbp
$LN33@deflate_sl:
  002fb	44 2b c0	 sub	 r8d, eax
  002fe	45 33 c9	 xor	 r9d, r9d
  00301	48 8b cb	 mov	 rcx, rbx
  00304	e8 00 00 00 00	 call	 _tr_flush_block
  00309	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0030f	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00312	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00318	e8 00 00 00 00	 call	 flush_pending
  0031d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00320	39 68 18	 cmp	 DWORD PTR [rax+24], ebp
  00323	0f 84 ce 00 00
	00		 je	 $LN48@deflate_sl
$LN19@deflate_sl:
  00329	41 bf 00 01 00
	00		 mov	 r15d, 256		; 00000100H
  0032f	4c 8b f7	 mov	 r14, rdi
  00332	e9 09 fd ff ff	 jmp	 $LL4@deflate_sl
$LN57@deflate_sl:

; 2006 : 
; 2007 :         } else if (s->match_available) {

  00337	48 8d bb 94 00
	00 00		 lea	 rdi, QWORD PTR [rbx+148]
  0033e	8b 07		 mov	 eax, DWORD PTR [rdi]
  00340	39 ab 90 00 00
	00		 cmp	 DWORD PTR [rbx+144], ebp
  00346	0f 84 ca 00 00
	00		 je	 $LN20@deflate_sl

; 2008 :             /* If there was no match at the previous position, output a
; 2009 :              * single literal. If there was a match but the current match
; 2010 :              * is longer, truncate the previous match to a single literal.
; 2011 :              */
; 2012 :             Tracevv((stderr,"%c", s->window[s->strstart - 1]));
; 2013 :             _tr_tally_lit(s, s->window[s->strstart - 1], bflush);

  0034c	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  0034f	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00353	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00357	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0035d	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00364	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
  00368	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0036e	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00374	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  0037b	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
  0037f	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00385	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0038b	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00392	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00395	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0039b	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  003a3	8b 83 f8 16 00
	00		 mov	 eax, DWORD PTR [rbx+5880]
  003a9	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 2014 :             if (bflush) {

  003af	75 36		 jne	 SHORT $LN22@deflate_sl

; 2015 :                 FLUSH_BLOCK_ONLY(s, 0);

  003b1	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  003b7	85 c0		 test	 eax, eax
  003b9	78 08		 js	 SHORT $LN34@deflate_sl
  003bb	8b d0		 mov	 edx, eax
  003bd	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  003c1	eb 03		 jmp	 SHORT $LN35@deflate_sl
$LN34@deflate_sl:
  003c3	48 8b d5	 mov	 rdx, rbp
$LN35@deflate_sl:
  003c6	44 8b 07	 mov	 r8d, DWORD PTR [rdi]
  003c9	45 33 c9	 xor	 r9d, r9d
  003cc	44 2b c0	 sub	 r8d, eax
  003cf	48 8b cb	 mov	 rcx, rbx
  003d2	e8 00 00 00 00	 call	 _tr_flush_block
  003d7	8b 07		 mov	 eax, DWORD PTR [rdi]
  003d9	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003dc	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  003e2	e8 00 00 00 00	 call	 flush_pending
$LN22@deflate_sl:

; 2016 :             }
; 2017 :             s->strstart++;
; 2018 :             s->lookahead--;
; 2019 :             if (s->strm->avail_out == 0) return need_more;

  003e7	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003ea	ff 07		 inc	 DWORD PTR [rdi]
  003ec	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  003f2	39 68 18	 cmp	 DWORD PTR [rax+24], ebp
  003f5	75 33		 jne	 SHORT $LN2@deflate_sl
$LN48@deflate_sl:
  003f7	33 c0		 xor	 eax, eax
$LN1@deflate_sl:

; 2043 : }

  003f9	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  003fe	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00403	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00408	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0040c	41 5f		 pop	 r15
  0040e	41 5e		 pop	 r14
  00410	41 5d		 pop	 r13
  00412	41 5c		 pop	 r12
  00414	5f		 pop	 rdi
  00415	c3		 ret	 0
$LN20@deflate_sl:

; 2020 :         } else {
; 2021 :             /* There is no previous match to compare with, wait for
; 2022 :              * the next step to decide.
; 2023 :              */
; 2024 :             s->match_available = 1;
; 2025 :             s->strstart++;

  00416	ff c0		 inc	 eax
  00418	c7 83 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rbx+144], 1

; 2026 :             s->lookahead--;

  00422	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  00428	89 07		 mov	 DWORD PTR [rdi], eax
$LN2@deflate_sl:

; 1998 :                     INSERT_STRING(s, s->strstart, hash_head);

  0042a	4c 8b f7	 mov	 r14, rdi
  0042d	e9 0e fc ff ff	 jmp	 $LL4@deflate_sl
$LN46@deflate_sl:

; 2027 :         }
; 2028 :     }
; 2029 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 2030 :     if (s->match_available) {

  00432	39 ab 90 00 00
	00		 cmp	 DWORD PTR [rbx+144], ebp
  00438	74 5f		 je	 SHORT $LN72@deflate_sl

; 2031 :         Tracevv((stderr,"%c", s->window[s->strstart - 1]));
; 2032 :         _tr_tally_lit(s, s->window[s->strstart - 1], bflush);

  0043a	41 8b 0e	 mov	 ecx, DWORD PTR [r14]
  0043d	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00441	ff c9		 dec	 ecx
  00443	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00447	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0044d	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00454	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
  00458	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0045e	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00464	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  0046b	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
  0046f	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00475	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0047b	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00482	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00485	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0048b	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]

; 2033 :         s->match_available = 0;

  00493	89 ab 90 00 00
	00		 mov	 DWORD PTR [rbx+144], ebp
$LN72@deflate_sl:

; 2034 :     }
; 2035 :     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;

  00499	45 8b 06	 mov	 r8d, DWORD PTR [r14]
  0049c	44 3b c6	 cmp	 r8d, esi
  0049f	41 0f 42 f0	 cmovb	 esi, r8d
  004a3	89 b3 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], esi

; 2036 :     if (flush == Z_FINISH) {

  004a9	41 83 fd 04	 cmp	 r13d, 4
  004ad	75 4c		 jne	 SHORT $LN25@deflate_sl

; 2037 :         FLUSH_BLOCK(s, 1);

  004af	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  004b5	85 c0		 test	 eax, eax
  004b7	78 08		 js	 SHORT $LN38@deflate_sl
  004b9	8b d0		 mov	 edx, eax
  004bb	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  004bf	eb 03		 jmp	 SHORT $LN39@deflate_sl
$LN38@deflate_sl:
  004c1	48 8b d5	 mov	 rdx, rbp
$LN39@deflate_sl:
  004c4	44 2b c0	 sub	 r8d, eax
  004c7	41 b9 01 00 00
	00		 mov	 r9d, 1
  004cd	48 8b cb	 mov	 rcx, rbx
  004d0	e8 00 00 00 00	 call	 _tr_flush_block
  004d5	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  004db	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  004de	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  004e4	e8 00 00 00 00	 call	 flush_pending
  004e9	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  004ec	39 68 18	 cmp	 DWORD PTR [rax+24], ebp
  004ef	40 0f 95 c5	 setne	 bpl
  004f3	8d 45 02	 lea	 eax, DWORD PTR [rbp+2]
  004f6	e9 fe fe ff ff	 jmp	 $LN1@deflate_sl
$LN25@deflate_sl:

; 2038 :         return finish_done;
; 2039 :     }
; 2040 :     if (s->sym_next)

  004fb	39 ab f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], ebp
  00501	74 42		 je	 SHORT $LN28@deflate_sl

; 2041 :         FLUSH_BLOCK(s, 0);

  00503	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00509	85 c0		 test	 eax, eax
  0050b	78 06		 js	 SHORT $LN40@deflate_sl
  0050d	8b e8		 mov	 ebp, eax
  0050f	48 03 6b 50	 add	 rbp, QWORD PTR [rbx+80]
$LN40@deflate_sl:
  00513	44 2b c0	 sub	 r8d, eax
  00516	45 33 c9	 xor	 r9d, r9d
  00519	48 8b d5	 mov	 rdx, rbp
  0051c	48 8b cb	 mov	 rcx, rbx
  0051f	e8 00 00 00 00	 call	 _tr_flush_block
  00524	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  0052a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0052d	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00533	e8 00 00 00 00	 call	 flush_pending
  00538	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0053b	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0053f	0f 84 b2 fe ff
	ff		 je	 $LN48@deflate_sl
$LN28@deflate_sl:

; 2042 :     return block_done;

  00545	b8 01 00 00 00	 mov	 eax, 1
  0054a	e9 aa fe ff ff	 jmp	 $LN1@deflate_sl
deflate_slow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflate_rle
_TEXT	SEGMENT
s$ = 64
flush$ = 72
deflate_rle PROC					; COMDAT

; 2051 : local block_state deflate_rle(deflate_state *s, int flush) {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00013	44 8b f2	 mov	 r14d, edx
  00016	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0001b	48 8b d9	 mov	 rbx, rcx
  0001e	48 8d b9 94 00
	00 00		 lea	 rdi, QWORD PTR [rcx+148]
  00025	33 ed		 xor	 ebp, ebp
  00027	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:_length_code
  0002e	66 90		 npad	 2
$LL4@deflate_rl:

; 2052 :     int bflush;             /* set if current block must be flushed */
; 2053 :     uInt prev;              /* byte at distance one to match */
; 2054 :     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
; 2055 : 
; 2056 :     for (;;) {
; 2057 :         /* Make sure that we always have enough lookahead, except
; 2058 :          * at the end of the input file. We need MAX_MATCH bytes
; 2059 :          * for the longest run, plus one for the unrolled loop.
; 2060 :          */
; 2061 :         if (s->lookahead <= MAX_MATCH) {

  00030	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  00036	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  0003b	77 30		 ja	 SHORT $LN10@deflate_rl

; 2062 :             fill_window(s);

  0003d	48 8b cb	 mov	 rcx, rbx
  00040	e8 00 00 00 00	 call	 fill_window

; 2063 :             if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {

  00045	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [rbx+156]
  0004b	48 8b f7	 mov	 rsi, rdi
  0004e	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  00053	77 10		 ja	 SHORT $LN9@deflate_rl
  00055	45 85 f6	 test	 r14d, r14d
  00058	0f 84 2f 02 00
	00		 je	 $LN37@deflate_rl
  0005e	48 8d b3 94 00
	00 00		 lea	 rsi, QWORD PTR [rbx+148]
$LN9@deflate_rl:

; 2064 :                 return need_more;
; 2065 :             }
; 2066 :             if (s->lookahead == 0) break; /* flush the current block */

  00065	85 c0		 test	 eax, eax
  00067	0f 84 3b 02 00
	00		 je	 $LN36@deflate_rl
$LN10@deflate_rl:

; 2067 :         }
; 2068 : 
; 2069 :         /* See how many times the previous byte repeats */
; 2070 :         s->match_length = 0;

  0006d	89 ab 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ebp

; 2071 :         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {

  00073	83 f8 03	 cmp	 eax, 3
  00076	0f 82 51 01 00
	00		 jb	 $LN15@deflate_rl
  0007c	8b 07		 mov	 eax, DWORD PTR [rdi]
  0007e	85 c0		 test	 eax, eax
  00080	0f 84 47 01 00
	00		 je	 $LN15@deflate_rl

; 2072 :             scan = s->window + s->strstart - 1;

  00086	4c 8b 43 50	 mov	 r8, QWORD PTR [rbx+80]
  0008a	4c 03 c0	 add	 r8, rax

; 2073 :             prev = *scan;

  0008d	41 0f b6 48 ff	 movzx	 ecx, BYTE PTR [r8-1]

; 2074 :             if (prev == *++scan && prev == *++scan && prev == *++scan) {

  00092	41 3a 08	 cmp	 cl, BYTE PTR [r8]
  00095	0f 85 32 01 00
	00		 jne	 $LN15@deflate_rl
  0009b	41 3a 48 01	 cmp	 cl, BYTE PTR [r8+1]
  0009f	0f 85 28 01 00
	00		 jne	 $LN15@deflate_rl
  000a5	41 3a 48 02	 cmp	 cl, BYTE PTR [r8+2]
  000a9	49 8d 50 02	 lea	 rdx, QWORD PTR [r8+2]
  000ad	0f 85 1a 01 00
	00		 jne	 $LN15@deflate_rl

; 2075 :                 strend = s->window + s->strstart + MAX_MATCH;

  000b3	49 81 c0 02 01
	00 00		 add	 r8, 258			; 00000102H
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL7@deflate_rl:

; 2076 :                 do {
; 2077 :                 } while (prev == *++scan && prev == *++scan &&
; 2078 :                          prev == *++scan && prev == *++scan &&
; 2079 :                          prev == *++scan && prev == *++scan &&
; 2080 :                          prev == *++scan && prev == *++scan &&

  000c0	3a 4a 01	 cmp	 cl, BYTE PTR [rdx+1]
  000c3	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  000c7	75 41		 jne	 SHORT $LN13@deflate_rl
  000c9	48 8d 50 01	 lea	 rdx, QWORD PTR [rax+1]
  000cd	8b c2		 mov	 eax, edx
  000cf	3a 0a		 cmp	 cl, BYTE PTR [rdx]
  000d1	75 37		 jne	 SHORT $LN13@deflate_rl
  000d3	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  000d6	3a 4a 01	 cmp	 cl, BYTE PTR [rdx+1]
  000d9	75 2f		 jne	 SHORT $LN13@deflate_rl
  000db	8d 42 02	 lea	 eax, DWORD PTR [rdx+2]
  000de	3a 4a 02	 cmp	 cl, BYTE PTR [rdx+2]
  000e1	75 27		 jne	 SHORT $LN13@deflate_rl
  000e3	8d 42 03	 lea	 eax, DWORD PTR [rdx+3]
  000e6	3a 4a 03	 cmp	 cl, BYTE PTR [rdx+3]
  000e9	75 1f		 jne	 SHORT $LN13@deflate_rl
  000eb	8d 42 04	 lea	 eax, DWORD PTR [rdx+4]
  000ee	3a 4a 04	 cmp	 cl, BYTE PTR [rdx+4]
  000f1	75 17		 jne	 SHORT $LN13@deflate_rl
  000f3	8d 42 05	 lea	 eax, DWORD PTR [rdx+5]
  000f6	3a 4a 05	 cmp	 cl, BYTE PTR [rdx+5]
  000f9	75 0f		 jne	 SHORT $LN13@deflate_rl
  000fb	48 83 c2 06	 add	 rdx, 6
  000ff	8b c2		 mov	 eax, edx
  00101	3a 0a		 cmp	 cl, BYTE PTR [rdx]
  00103	75 05		 jne	 SHORT $LN13@deflate_rl
  00105	49 3b d0	 cmp	 rdx, r8
  00108	72 b6		 jb	 SHORT $LL7@deflate_rl
$LN13@deflate_rl:

; 2081 :                          scan < strend);
; 2082 :                 s->match_length = MAX_MATCH - (uInt)(strend - scan);
; 2083 :                 if (s->match_length > s->lookahead)

  0010a	8b 8b 9c 00 00
	00		 mov	 ecx, DWORD PTR [rbx+156]
  00110	41 2b c0	 sub	 eax, r8d
  00113	05 02 01 00 00	 add	 eax, 258		; 00000102H
  00118	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax
  0011e	3b c1		 cmp	 eax, ecx
  00120	76 08		 jbe	 SHORT $LN14@deflate_rl

; 2084 :                     s->match_length = s->lookahead;

  00122	89 8b 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ecx
  00128	8b c1		 mov	 eax, ecx
$LN14@deflate_rl:

; 2085 :             }
; 2086 :             Assert(scan <= s->window + (uInt)(s->window_size - 1),
; 2087 :                    "wild scan");
; 2088 :         }
; 2089 : 
; 2090 :         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
; 2091 :         if (s->match_length >= MIN_MATCH) {

  0012a	83 f8 03	 cmp	 eax, 3
  0012d	0f 82 9a 00 00
	00		 jb	 $LN15@deflate_rl

; 2092 :             check_match(s, s->strstart, s->strstart - 1, s->match_length);
; 2093 : 
; 2094 :             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

  00133	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]

; 2095 : 
; 2096 :             s->lookahead -= s->match_length;
; 2097 :             s->strstart += s->match_length;
; 2098 :             s->match_length = 0;

  00139	48 8d bb 94 00
	00 00		 lea	 rdi, QWORD PTR [rbx+148]
  00140	2c 03		 sub	 al, 3
  00142	0f b6 d0	 movzx	 edx, al
  00145	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  0014c	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
  00150	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00156	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0015c	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00163	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
  00167	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0016d	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00173	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  0017a	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0017d	42 0f b6 04 3a	 movzx	 eax, BYTE PTR [rdx+r15]
  00182	8b d5		 mov	 edx, ebp
  00184	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0018a	66 ff 84 83 c0
	04 00 00	 inc	 WORD PTR [rbx+rax*4+1216]
  00192	66 ff 83 b0 09
	00 00		 inc	 WORD PTR [rbx+2480]
  00199	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [rbx+136]
  0019f	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  001a6	8b 83 f8 16 00
	00		 mov	 eax, DWORD PTR [rbx+5880]
  001ac	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  001b2	89 ab 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ebp
  001b8	0f 94 c2	 sete	 dl
  001bb	29 8b 9c 00 00
	00		 sub	 DWORD PTR [rbx+156], ecx
  001c1	44 03 c1	 add	 r8d, ecx
  001c4	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d

; 2099 :         } else {

  001cb	eb 79		 jmp	 SHORT $LN16@deflate_rl
$LN15@deflate_rl:

; 2100 :             /* No match, output a literal byte */
; 2101 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 2102 :             _tr_tally_lit(s, s->window[s->strstart], bflush);

  001cd	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001d1	48 8d bb 94 00
	00 00		 lea	 rdi, QWORD PTR [rbx+148]
  001d8	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  001da	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  001de	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001e4	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  001eb	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
  001ef	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  001f5	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  001fb	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00202	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
  00206	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0020c	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00212	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00219	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0021c	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00222	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]
  0022a	8b d5		 mov	 edx, ebp
  0022c	8b 83 f8 16 00
	00		 mov	 eax, DWORD PTR [rbx+5880]
  00232	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax
  00238	0f 94 c2	 sete	 dl

; 2103 :             s->lookahead--;

  0023b	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]

; 2104 :             s->strstart++;

  00241	ff 07		 inc	 DWORD PTR [rdi]
  00243	44 8b 07	 mov	 r8d, DWORD PTR [rdi]
$LN16@deflate_rl:

; 2105 :         }
; 2106 :         if (bflush) FLUSH_BLOCK(s, 0);

  00246	85 d2		 test	 edx, edx
  00248	0f 84 e2 fd ff
	ff		 je	 $LL4@deflate_rl
  0024e	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00254	85 c0		 test	 eax, eax
  00256	78 08		 js	 SHORT $LN26@deflate_rl
  00258	8b d0		 mov	 edx, eax
  0025a	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0025e	eb 03		 jmp	 SHORT $LN27@deflate_rl
$LN26@deflate_rl:
  00260	48 8b d5	 mov	 rdx, rbp
$LN27@deflate_rl:
  00263	44 2b c0	 sub	 r8d, eax
  00266	45 33 c9	 xor	 r9d, r9d
  00269	48 8b cb	 mov	 rcx, rbx
  0026c	e8 00 00 00 00	 call	 _tr_flush_block
  00271	8b 07		 mov	 eax, DWORD PTR [rdi]
  00273	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00276	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  0027c	e8 00 00 00 00	 call	 flush_pending
  00281	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00284	39 68 18	 cmp	 DWORD PTR [rax+24], ebp
  00287	0f 85 a3 fd ff
	ff		 jne	 $LL4@deflate_rl
$LN37@deflate_rl:
  0028d	33 c0		 xor	 eax, eax
$LN1@deflate_rl:
  0028f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 2116 : }

  00294	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00299	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0029e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002a2	41 5f		 pop	 r15
  002a4	41 5e		 pop	 r14
  002a6	5f		 pop	 rdi
  002a7	c3		 ret	 0
$LN36@deflate_rl:

; 2107 :     }
; 2108 :     s->insert = 0;

  002a8	89 ab 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], ebp

; 2109 :     if (flush == Z_FINISH) {

  002ae	41 83 fe 04	 cmp	 r14d, 4
  002b2	75 48		 jne	 SHORT $LN19@deflate_rl

; 2110 :         FLUSH_BLOCK(s, 1);

  002b4	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  002ba	85 c0		 test	 eax, eax
  002bc	78 08		 js	 SHORT $LN28@deflate_rl
  002be	8b d0		 mov	 edx, eax
  002c0	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  002c4	eb 03		 jmp	 SHORT $LN29@deflate_rl
$LN28@deflate_rl:
  002c6	48 8b d5	 mov	 rdx, rbp
$LN29@deflate_rl:
  002c9	44 8b 06	 mov	 r8d, DWORD PTR [rsi]
  002cc	41 b9 01 00 00
	00		 mov	 r9d, 1
  002d2	44 2b c0	 sub	 r8d, eax
  002d5	48 8b cb	 mov	 rcx, rbx
  002d8	e8 00 00 00 00	 call	 _tr_flush_block
  002dd	8b 06		 mov	 eax, DWORD PTR [rsi]
  002df	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  002e2	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  002e8	e8 00 00 00 00	 call	 flush_pending
  002ed	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002f0	39 68 18	 cmp	 DWORD PTR [rax+24], ebp
  002f3	40 0f 95 c5	 setne	 bpl
  002f7	8d 45 02	 lea	 eax, DWORD PTR [rbp+2]
  002fa	eb 93		 jmp	 SHORT $LN1@deflate_rl
$LN19@deflate_rl:

; 2111 :         return finish_done;
; 2112 :     }
; 2113 :     if (s->sym_next)

  002fc	39 ab f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], ebp
  00302	74 41		 je	 SHORT $LN22@deflate_rl

; 2114 :         FLUSH_BLOCK(s, 0);

  00304	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0030a	85 c0		 test	 eax, eax
  0030c	78 06		 js	 SHORT $LN30@deflate_rl
  0030e	8b e8		 mov	 ebp, eax
  00310	48 03 6b 50	 add	 rbp, QWORD PTR [rbx+80]
$LN30@deflate_rl:
  00314	44 8b 06	 mov	 r8d, DWORD PTR [rsi]
  00317	45 33 c9	 xor	 r9d, r9d
  0031a	44 2b c0	 sub	 r8d, eax
  0031d	48 8b d5	 mov	 rdx, rbp
  00320	48 8b cb	 mov	 rcx, rbx
  00323	e8 00 00 00 00	 call	 _tr_flush_block
  00328	8b 06		 mov	 eax, DWORD PTR [rsi]
  0032a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0032d	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  00333	e8 00 00 00 00	 call	 flush_pending
  00338	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0033b	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0033f	0f 84 48 ff ff
	ff		 je	 $LN37@deflate_rl
$LN22@deflate_rl:

; 2115 :     return block_done;

  00345	b8 01 00 00 00	 mov	 eax, 1
  0034a	e9 40 ff ff ff	 jmp	 $LN1@deflate_rl
deflate_rle ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\deflate.c
;	COMDAT deflate_huff
_TEXT	SEGMENT
s$ = 48
flush$ = 56
deflate_huff PROC					; COMDAT

; 2122 : local block_state deflate_huff(deflate_state *s, int flush) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b f2		 mov	 esi, edx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	33 ff		 xor	 edi, edi
$LL4@deflate_hu:

; 2123 :     int bflush;             /* set if current block must be flushed */
; 2124 : 
; 2125 :     for (;;) {
; 2126 :         /* Make sure that we have a literal to write. */
; 2127 :         if (s->lookahead == 0) {

  00016	39 bb 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], edi
  0001c	75 14		 jne	 SHORT $LN6@deflate_hu

; 2128 :             fill_window(s);

  0001e	48 8b cb	 mov	 rcx, rbx
  00021	e8 00 00 00 00	 call	 fill_window

; 2129 :             if (s->lookahead == 0) {

  00026	39 bb 9c 00 00
	00		 cmp	 DWORD PTR [rbx+156], edi
  0002c	0f 84 de 00 00
	00		 je	 $LN23@deflate_hu
$LN6@deflate_hu:

; 2131 :                     return need_more;
; 2132 :                 break;      /* flush the current block */
; 2133 :             }
; 2134 :         }
; 2135 : 
; 2136 :         /* Output a literal byte */
; 2137 :         s->match_length = 0;
; 2138 :         Tracevv((stderr,"%c", s->window[s->strstart]));
; 2139 :         _tr_tally_lit(s, s->window[s->strstart], bflush);

  00032	8b 8b 94 00 00
	00		 mov	 ecx, DWORD PTR [rbx+148]
  00038	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0003c	89 bb 88 00 00
	00		 mov	 DWORD PTR [rbx+136], edi
  00042	0f b6 14 01	 movzx	 edx, BYTE PTR [rcx+rax]
  00046	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0004c	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00053	40 88 3c 01	 mov	 BYTE PTR [rcx+rax], dil
  00057	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0005d	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  00063	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  0006a	40 88 3c 01	 mov	 BYTE PTR [rcx+rax], dil
  0006e	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  00074	8b 8b f4 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5876]
  0007a	48 8b 83 e8 16
	00 00		 mov	 rax, QWORD PTR [rbx+5864]
  00081	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00084	ff 83 f4 16 00
	00		 inc	 DWORD PTR [rbx+5876]
  0008a	66 ff 84 93 bc
	00 00 00	 inc	 WORD PTR [rbx+rdx*4+188]

; 2140 :         s->lookahead--;
; 2141 :         s->strstart++;

  00092	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  00099	ff 8b 9c 00 00
	00		 dec	 DWORD PTR [rbx+156]
  0009f	41 ff c0	 inc	 r8d
  000a2	8b 83 f8 16 00
	00		 mov	 eax, DWORD PTR [rbx+5880]
  000a8	44 89 83 94 00
	00 00		 mov	 DWORD PTR [rbx+148], r8d
  000af	39 83 f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], eax

; 2142 :         if (bflush) FLUSH_BLOCK(s, 0);

  000b5	0f 85 5b ff ff
	ff		 jne	 $LL4@deflate_hu
  000bb	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  000c1	85 c0		 test	 eax, eax
  000c3	78 08		 js	 SHORT $LN15@deflate_hu
  000c5	8b d0		 mov	 edx, eax
  000c7	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  000cb	eb 03		 jmp	 SHORT $LN16@deflate_hu
$LN15@deflate_hu:
  000cd	48 8b d7	 mov	 rdx, rdi
$LN16@deflate_hu:
  000d0	44 2b c0	 sub	 r8d, eax
  000d3	45 33 c9	 xor	 r9d, r9d
  000d6	48 8b cb	 mov	 rcx, rbx
  000d9	e8 00 00 00 00	 call	 _tr_flush_block
  000de	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  000e4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000e7	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  000ed	e8 00 00 00 00	 call	 flush_pending
  000f2	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000f5	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  000f8	0f 85 18 ff ff
	ff		 jne	 $LL4@deflate_hu
$LN24@deflate_hu:
  000fe	33 c0		 xor	 eax, eax

; 2151 :     return block_done;
; 2152 : }

  00100	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00105	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
$LN23@deflate_hu:

; 2130 :                 if (flush == Z_NO_FLUSH)

  00110	85 f6		 test	 esi, esi
  00112	74 ea		 je	 SHORT $LN24@deflate_hu

; 2143 :     }
; 2144 :     s->insert = 0;

  00114	89 bb 08 17 00
	00		 mov	 DWORD PTR [rbx+5896], edi

; 2145 :     if (flush == Z_FINISH) {

  0011a	83 fe 04	 cmp	 esi, 4
  0011d	75 5e		 jne	 SHORT $LN10@deflate_hu

; 2146 :         FLUSH_BLOCK(s, 1);

  0011f	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  00125	85 c0		 test	 eax, eax
  00127	78 08		 js	 SHORT $LN17@deflate_hu
  00129	8b d0		 mov	 edx, eax
  0012b	48 03 53 50	 add	 rdx, QWORD PTR [rbx+80]
  0012f	eb 03		 jmp	 SHORT $LN18@deflate_hu
$LN17@deflate_hu:
  00131	48 8b d7	 mov	 rdx, rdi
$LN18@deflate_hu:
  00134	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0013b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00141	44 2b c0	 sub	 r8d, eax
  00144	48 8b cb	 mov	 rcx, rbx
  00147	e8 00 00 00 00	 call	 _tr_flush_block
  0014c	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  00152	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00155	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  0015b	e8 00 00 00 00	 call	 flush_pending
  00160	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00163	39 78 18	 cmp	 DWORD PTR [rax+24], edi
  00166	40 0f 95 c7	 setne	 dil
  0016a	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]

; 2151 :     return block_done;
; 2152 : }

  0016d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00172	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00177	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0017b	5f		 pop	 rdi
  0017c	c3		 ret	 0
$LN10@deflate_hu:

; 2147 :         return finish_done;
; 2148 :     }
; 2149 :     if (s->sym_next)

  0017d	39 bb f4 16 00
	00		 cmp	 DWORD PTR [rbx+5876], edi
  00183	74 49		 je	 SHORT $LN13@deflate_hu

; 2150 :         FLUSH_BLOCK(s, 0);

  00185	8b 83 84 00 00
	00		 mov	 eax, DWORD PTR [rbx+132]
  0018b	85 c0		 test	 eax, eax
  0018d	78 06		 js	 SHORT $LN19@deflate_hu
  0018f	8b f8		 mov	 edi, eax
  00191	48 03 7b 50	 add	 rdi, QWORD PTR [rbx+80]
$LN19@deflate_hu:
  00195	44 8b 83 94 00
	00 00		 mov	 r8d, DWORD PTR [rbx+148]
  0019c	45 33 c9	 xor	 r9d, r9d
  0019f	44 2b c0	 sub	 r8d, eax
  001a2	48 8b d7	 mov	 rdx, rdi
  001a5	48 8b cb	 mov	 rcx, rbx
  001a8	e8 00 00 00 00	 call	 _tr_flush_block
  001ad	8b 83 94 00 00
	00		 mov	 eax, DWORD PTR [rbx+148]
  001b3	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  001b6	89 83 84 00 00
	00		 mov	 DWORD PTR [rbx+132], eax
  001bc	e8 00 00 00 00	 call	 flush_pending
  001c1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001c4	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  001c8	0f 84 30 ff ff
	ff		 je	 $LN24@deflate_hu
$LN13@deflate_hu:

; 2151 :     return block_done;
; 2152 : }

  001ce	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001d3	b8 01 00 00 00	 mov	 eax, 1
  001d8	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001dd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001e1	5f		 pop	 rdi
  001e2	c3		 ret	 0
deflate_huff ENDP
_TEXT	ENDS
END
