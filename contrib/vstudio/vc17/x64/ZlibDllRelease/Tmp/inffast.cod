; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35209.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	inflate_fast
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_fast DD imagerel $LN158
	DD	imagerel $LN158+1238
	DD	imagerel $unwind$inflate_fast
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_fast DD 091501H
	DD	0f0116215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inffast.c
;	COMDAT inflate_fast
_TEXT	SEGMENT
tv866 = 0
tv868 = 4
end$1$ = 8
dcode$1$ = 16
last$1$ = 24
beg$1$ = 32
strm$ = 128
start$ = 136
wsize$1$ = 136
tv865 = 144
whave$1$ = 152
inflate_fast PROC					; COMDAT

; 50   : void ZLIB_INTERNAL inflate_fast(z_streamp strm, unsigned start) {

$LN158:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 51   :     struct inflate_state FAR *state;
; 52   :     z_const unsigned char FAR *in;      /* local strm->next_in */
; 53   :     z_const unsigned char FAR *last;    /* have enough input while in < last */
; 54   :     unsigned char FAR *out;     /* local strm->next_out */
; 55   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 56   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 57   : #ifdef INFLATE_STRICT
; 58   :     unsigned dmax;              /* maximum distance from zlib header */
; 59   : #endif
; 60   :     unsigned wsize;             /* window size or zero if not using window */
; 61   :     unsigned whave;             /* valid bytes in the window */
; 62   :     unsigned wnext;             /* window write index */
; 63   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 64   :     unsigned long hold;         /* local strm->hold */
; 65   :     unsigned bits;              /* local strm->bits */
; 66   :     code const FAR *lcode;      /* local strm->lencode */
; 67   :     code const FAR *dcode;      /* local strm->distcode */
; 68   :     unsigned lmask;             /* mask for first level of length codes */
; 69   :     unsigned dmask;             /* mask for first level of distance codes */
; 70   :     code const *here;           /* retrieved table entry */
; 71   :     unsigned op;                /* code bits, operation, extra bits, or */
; 72   :                                 /*  window position, window bytes to copy */
; 73   :     unsigned len;               /* match length, unused bytes */
; 74   :     unsigned dist;              /* match distance */
; 75   :     unsigned char FAR *from;    /* where to copy match from */
; 76   : 
; 77   :     /* copy state to local variables */
; 78   :     state = (struct inflate_state FAR *)strm->state;

  00015	4c 8b 69 28	 mov	 r13, QWORD PTR [rcx+40]

; 79   :     in = strm->next_in;
; 80   :     last = in + (strm->avail_in - 5);
; 81   :     out = strm->next_out;
; 82   :     beg = out - (start - strm->avail_out);
; 83   :     end = out + (strm->avail_out - 257);
; 84   : #ifdef INFLATE_STRICT
; 85   :     dmax = state->dmax;
; 86   : #endif
; 87   :     wsize = state->wsize;
; 88   :     whave = state->whave;
; 89   :     wnext = state->wnext;
; 90   :     window = state->window;
; 91   :     hold = state->hold;
; 92   :     bits = state->bits;
; 93   :     lcode = state->lencode;
; 94   :     dcode = state->distcode;
; 95   :     lmask = (1U << state->lenbits) - 1;

  00019	bd 01 00 00 00	 mov	 ebp, 1
  0001e	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00021	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00025	83 e8 05	 sub	 eax, 5
  00028	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  0002b	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0002e	48 03 c7	 add	 rax, rdi
  00031	49 8b 75 68	 mov	 rsi, QWORD PTR [r13+104]
  00035	2b d1		 sub	 edx, ecx
  00037	45 8b 75 3c	 mov	 r14d, DWORD PTR [r13+60]
  0003b	4d 8b 7d 40	 mov	 r15, QWORD PTR [r13+64]
  0003f	41 8b 5d 48	 mov	 ebx, DWORD PTR [r13+72]
  00043	44 8d 99 ff fe
	ff ff		 lea	 r11d, DWORD PTR [rcx-257]
  0004a	41 8b 4d 70	 mov	 ecx, DWORD PTR [r13+112]
  0004e	4d 03 d8	 add	 r11, r8
  00051	45 8b 55 4c	 mov	 r10d, DWORD PTR [r13+76]
  00055	4d 8b 65 60	 mov	 r12, QWORD PTR [r13+96]
  00059	48 89 44 24 18	 mov	 QWORD PTR last$1$[rsp], rax
  0005e	8b c2		 mov	 eax, edx
  00060	49 8b d0	 mov	 rdx, r8
  00063	48 2b d0	 sub	 rdx, rax
  00066	4c 89 5c 24 08	 mov	 QWORD PTR end$1$[rsp], r11
  0006b	41 8b 45 34	 mov	 eax, DWORD PTR [r13+52]
  0006f	89 84 24 88 00
	00 00		 mov	 DWORD PTR wsize$1$[rsp], eax
  00076	41 8b 45 38	 mov	 eax, DWORD PTR [r13+56]
  0007a	48 89 54 24 20	 mov	 QWORD PTR beg$1$[rsp], rdx
  0007f	8b d5		 mov	 edx, ebp
  00081	89 84 24 98 00
	00 00		 mov	 DWORD PTR whave$1$[rsp], eax

; 96   :     dmask = (1U << state->distbits) - 1;

  00088	8b c5		 mov	 eax, ebp
  0008a	d3 e2		 shl	 edx, cl
  0008c	41 8b 4d 74	 mov	 ecx, DWORD PTR [r13+116]
  00090	ff ca		 dec	 edx
  00092	d3 e0		 shl	 eax, cl
  00094	ff c8		 dec	 eax
  00096	48 89 74 24 10	 mov	 QWORD PTR dcode$1$[rsp], rsi
  0009b	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv865[rsp], eax
  000a2	89 14 24	 mov	 DWORD PTR tv866[rsp], edx
$LL4@inflate_fa:

; 97   : 
; 98   :     /* decode literals and length/distances until end-of-block or not enough
; 99   :        input data or output space */
; 100  :     do {
; 101  :         if (bits < 15) {

  000a5	41 83 fa 0f	 cmp	 r10d, 15
  000a9	73 1e		 jae	 SHORT $LN22@inflate_fa

; 102  :             hold += (unsigned long)(*in++) << bits;

  000ab	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  000ae	41 8b ca	 mov	 ecx, r10d
  000b1	d3 e0		 shl	 eax, cl

; 103  :             bits += 8;
; 104  :             hold += (unsigned long)(*in++) << bits;

  000b3	41 8d 4a 08	 lea	 ecx, DWORD PTR [r10+8]
  000b7	03 d8		 add	 ebx, eax
  000b9	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]
  000bd	d3 e0		 shl	 eax, cl
  000bf	48 83 c7 02	 add	 rdi, 2
  000c3	03 d8		 add	 ebx, eax

; 105  :             bits += 8;

  000c5	41 83 c2 10	 add	 r10d, 16
$LN22@inflate_fa:

; 106  :         }
; 107  :         here = lcode + (hold & lmask);

  000c9	8b ca		 mov	 ecx, edx
  000cb	8b c3		 mov	 eax, ebx
  000cd	48 23 c8	 and	 rcx, rax

; 108  :       dolen:
; 109  :         op = (unsigned)(here->bits);
; 110  :         hold >>= op;
; 111  :         bits -= op;
; 112  :         op = (unsigned)(here->op);

  000d0	41 0f b6 14 8c	 movzx	 edx, BYTE PTR [r12+rcx*4]
  000d5	4d 8d 0c 8c	 lea	 r9, QWORD PTR [r12+rcx*4]
  000d9	41 0f b6 4c 8c
	01		 movzx	 ecx, BYTE PTR [r12+rcx*4+1]
  000df	d3 eb		 shr	 ebx, cl
  000e1	44 2b d1	 sub	 r10d, ecx

; 113  :         if (op == 0) {                          /* literal */

  000e4	85 d2		 test	 edx, edx
  000e6	74 3c		 je	 SHORT $LN72@inflate_fa
$dolen$159:

; 118  :         }
; 119  :         else if (op & 16) {                     /* length base */

  000e8	f6 c2 10	 test	 dl, 16
  000eb	75 47		 jne	 SHORT $LN73@inflate_fa

; 271  :             }
; 272  :         }
; 273  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000ed	f6 c2 40	 test	 dl, 64			; 00000040H
  000f0	0f 85 2a 03 00
	00		 jne	 $LN52@inflate_fa

; 274  :             here = lcode + here->val + (hold & ((1U << op) - 1));

  000f6	8b ca		 mov	 ecx, edx
  000f8	8b c5		 mov	 eax, ebp
  000fa	d3 e0		 shl	 eax, cl
  000fc	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  000ff	8b c3		 mov	 eax, ebx
  00101	48 23 c8	 and	 rcx, rax
  00104	41 0f b7 41 02	 movzx	 eax, WORD PTR [r9+2]
  00109	48 03 c8	 add	 rcx, rax
  0010c	41 0f b6 14 8c	 movzx	 edx, BYTE PTR [r12+rcx*4]
  00111	4d 8d 0c 8c	 lea	 r9, QWORD PTR [r12+rcx*4]
  00115	41 0f b6 4c 8c
	01		 movzx	 ecx, BYTE PTR [r12+rcx*4+1]
  0011b	d3 eb		 shr	 ebx, cl
  0011d	44 2b d1	 sub	 r10d, ecx
  00120	85 d2		 test	 edx, edx
  00122	75 c4		 jne	 SHORT $dolen$159
$LN72@inflate_fa:

; 114  :             Tracevv((stderr, here->val >= 0x20 && here->val < 0x7f ?
; 115  :                     "inflate:         literal '%c'\n" :
; 116  :                     "inflate:         literal 0x%02x\n", here->val));
; 117  :             *out++ = (unsigned char)(here->val);

  00124	41 0f b6 41 02	 movzx	 eax, BYTE PTR [r9+2]
  00129	41 88 00	 mov	 BYTE PTR [r8], al
  0012c	49 ff c0	 inc	 r8

; 285  :             break;
; 286  :         }
; 287  :     } while (in < last && out < end);

  0012f	e9 d8 02 00 00	 jmp	 $LN2@inflate_fa
$LN73@inflate_fa:

; 120  :             len = (unsigned)(here->val);

  00134	45 0f b7 59 02	 movzx	 r11d, WORD PTR [r9+2]

; 121  :             op &= 15;                           /* number of extra bits */

  00139	83 e2 0f	 and	 edx, 15

; 122  :             if (op) {

  0013c	74 28		 je	 SHORT $LN27@inflate_fa

; 123  :                 if (bits < op) {

  0013e	44 3b d2	 cmp	 r10d, edx
  00141	73 11		 jae	 SHORT $LN28@inflate_fa

; 124  :                     hold += (unsigned long)(*in++) << bits;

  00143	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00146	41 8b ca	 mov	 ecx, r10d
  00149	d3 e0		 shl	 eax, cl
  0014b	48 ff c7	 inc	 rdi
  0014e	03 d8		 add	 ebx, eax

; 125  :                     bits += 8;

  00150	41 83 c2 08	 add	 r10d, 8
$LN28@inflate_fa:

; 126  :                 }
; 127  :                 len += (unsigned)hold & ((1U << op) - 1);

  00154	8b ca		 mov	 ecx, edx
  00156	8b c5		 mov	 eax, ebp
  00158	d3 e0		 shl	 eax, cl
  0015a	ff c8		 dec	 eax
  0015c	23 c3		 and	 eax, ebx

; 128  :                 hold >>= op;

  0015e	d3 eb		 shr	 ebx, cl
  00160	44 03 d8	 add	 r11d, eax

; 129  :                 bits -= op;

  00163	44 2b d2	 sub	 r10d, edx
$LN27@inflate_fa:

; 130  :             }
; 131  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 132  :             if (bits < 15) {

  00166	41 83 fa 0f	 cmp	 r10d, 15
  0016a	73 1e		 jae	 SHORT $LN29@inflate_fa

; 133  :                 hold += (unsigned long)(*in++) << bits;

  0016c	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  0016f	41 8b ca	 mov	 ecx, r10d
  00172	d3 e0		 shl	 eax, cl

; 134  :                 bits += 8;
; 135  :                 hold += (unsigned long)(*in++) << bits;

  00174	41 8d 4a 08	 lea	 ecx, DWORD PTR [r10+8]
  00178	03 d8		 add	 ebx, eax
  0017a	0f b6 47 01	 movzx	 eax, BYTE PTR [rdi+1]
  0017e	d3 e0		 shl	 eax, cl
  00180	48 83 c7 02	 add	 rdi, 2
  00184	03 d8		 add	 ebx, eax

; 136  :                 bits += 8;

  00186	41 83 c2 10	 add	 r10d, 16
$LN29@inflate_fa:

; 137  :             }
; 138  :             here = dcode + (hold & dmask);

  0018a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv865[rsp]
  00191	8b c3		 mov	 eax, ebx
  00193	48 23 c8	 and	 rcx, rax

; 139  :           dodist:
; 140  :             op = (unsigned)(here->bits);
; 141  :             hold >>= op;
; 142  :             bits -= op;
; 143  :             op = (unsigned)(here->op);

  00196	0f b6 14 8e	 movzx	 edx, BYTE PTR [rsi+rcx*4]
  0019a	4c 8d 0c 8e	 lea	 r9, QWORD PTR [rsi+rcx*4]
  0019e	0f b6 4c 8e 01	 movzx	 ecx, BYTE PTR [rsi+rcx*4+1]
  001a3	d3 eb		 shr	 ebx, cl
  001a5	44 2b d1	 sub	 r10d, ecx

; 144  :             if (op & 16) {                      /* distance base */

  001a8	f6 c2 10	 test	 dl, 16
  001ab	75 39		 jne	 SHORT $LN74@inflate_fa
  001ad	0f 1f 00	 npad	 3
$dodist$160:

; 260  :                     }
; 261  :                 }
; 262  :             }
; 263  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001b0	f6 c2 40	 test	 dl, 64			; 00000040H
  001b3	0f 85 93 02 00
	00		 jne	 $LN50@inflate_fa

; 264  :                 here = dcode + here->val + (hold & ((1U << op) - 1));

  001b9	8b ca		 mov	 ecx, edx
  001bb	8b c5		 mov	 eax, ebp
  001bd	d3 e0		 shl	 eax, cl
  001bf	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  001c2	8b c3		 mov	 eax, ebx
  001c4	48 23 c8	 and	 rcx, rax
  001c7	41 0f b7 41 02	 movzx	 eax, WORD PTR [r9+2]
  001cc	48 03 c8	 add	 rcx, rax
  001cf	0f b6 14 8e	 movzx	 edx, BYTE PTR [rsi+rcx*4]
  001d3	4c 8d 0c 8e	 lea	 r9, QWORD PTR [rsi+rcx*4]
  001d7	0f b6 4c 8e 01	 movzx	 ecx, BYTE PTR [rsi+rcx*4+1]
  001dc	d3 eb		 shr	 ebx, cl
  001de	44 2b d1	 sub	 r10d, ecx
  001e1	f6 c2 10	 test	 dl, 16
  001e4	74 ca		 je	 SHORT $dodist$160
$LN74@inflate_fa:

; 145  :                 dist = (unsigned)(here->val);

  001e6	41 0f b7 71 02	 movzx	 esi, WORD PTR [r9+2]

; 146  :                 op &= 15;                       /* number of extra bits */

  001eb	83 e2 0f	 and	 edx, 15

; 147  :                 if (bits < op) {

  001ee	44 3b d2	 cmp	 r10d, edx
  001f1	73 27		 jae	 SHORT $LN33@inflate_fa

; 148  :                     hold += (unsigned long)(*in++) << bits;

  001f3	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  001f6	41 8b ca	 mov	 ecx, r10d
  001f9	d3 e0		 shl	 eax, cl
  001fb	48 ff c7	 inc	 rdi
  001fe	03 d8		 add	 ebx, eax

; 149  :                     bits += 8;

  00200	41 83 c2 08	 add	 r10d, 8

; 150  :                     if (bits < op) {

  00204	44 3b d2	 cmp	 r10d, edx
  00207	73 11		 jae	 SHORT $LN33@inflate_fa

; 151  :                         hold += (unsigned long)(*in++) << bits;

  00209	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  0020c	41 8b ca	 mov	 ecx, r10d
  0020f	d3 e0		 shl	 eax, cl
  00211	48 ff c7	 inc	 rdi
  00214	03 d8		 add	 ebx, eax

; 152  :                         bits += 8;

  00216	41 83 c2 08	 add	 r10d, 8
$LN33@inflate_fa:

; 153  :                     }
; 154  :                 }
; 155  :                 dist += (unsigned)hold & ((1U << op) - 1);

  0021a	8b ca		 mov	 ecx, edx
  0021c	8b c5		 mov	 eax, ebp
  0021e	d3 e0		 shl	 eax, cl

; 156  : #ifdef INFLATE_STRICT
; 157  :                 if (dist > dmax) {
; 158  :                     strm->msg = (z_const char *)"invalid distance too far back";
; 159  :                     state->mode = BAD;
; 160  :                     break;
; 161  :                 }
; 162  : #endif
; 163  :                 hold >>= op;
; 164  :                 bits -= op;

  00220	44 2b d2	 sub	 r10d, edx
  00223	ff c8		 dec	 eax
  00225	23 c3		 and	 eax, ebx
  00227	d3 eb		 shr	 ebx, cl
  00229	03 f0		 add	 esi, eax

; 165  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 166  :                 op = (unsigned)(out - beg);     /* max distance in output */

  0022b	41 8b c0	 mov	 eax, r8d
  0022e	2b 44 24 20	 sub	 eax, DWORD PTR beg$1$[rsp]

; 167  :                 if (dist > op) {                /* see if copy from window */

  00232	3b f0		 cmp	 esi, eax
  00234	0f 86 6f 01 00
	00		 jbe	 $LN34@inflate_fa

; 168  :                     op = dist - op;             /* distance back in window */

  0023a	8b d6		 mov	 edx, esi
  0023c	2b d0		 sub	 edx, eax

; 169  :                     if (op > whave) {

  0023e	3b 94 24 98 00
	00 00		 cmp	 edx, DWORD PTR whave$1$[rsp]
  00245	76 0e		 jbe	 SHORT $LN37@inflate_fa

; 170  :                         if (state->sane) {

  00247	41 83 bd e0 1b
	00 00 00	 cmp	 DWORD PTR [r13+7136], 0
  0024f	0f 85 00 02 00
	00		 jne	 $LN75@inflate_fa
$LN37@inflate_fa:

; 172  :                                 (z_const char *)"invalid distance too far back";
; 173  :                             state->mode = BAD;
; 174  :                             break;
; 175  :                         }
; 176  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 177  :                         if (len <= op - whave) {
; 178  :                             do {
; 179  :                                 *out++ = 0;
; 180  :                             } while (--len);
; 181  :                             continue;
; 182  :                         }
; 183  :                         len -= op - whave;
; 184  :                         do {
; 185  :                             *out++ = 0;
; 186  :                         } while (--op > whave);
; 187  :                         if (op == 0) {
; 188  :                             from = out - dist;
; 189  :                             do {
; 190  :                                 *out++ = *from++;
; 191  :                             } while (--len);
; 192  :                             continue;
; 193  :                         }
; 194  : #endif
; 195  :                     }
; 196  :                     from = window;
; 197  :                     if (wnext == 0) {           /* very common case */

  00255	45 85 f6	 test	 r14d, r14d
  00258	75 3e		 jne	 SHORT $LN38@inflate_fa

; 198  :                         from += wsize - op;

  0025a	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR wsize$1$[rsp]
  00262	44 2b ca	 sub	 r9d, edx
  00265	4d 03 cf	 add	 r9, r15

; 199  :                         if (op < len) {         /* some from window */

  00268	41 3b d3	 cmp	 edx, r11d
  0026b	0f 83 ba 00 00
	00		 jae	 $LN69@inflate_fa

; 200  :                             len -= op;

  00271	44 2b da	 sub	 r11d, edx
  00274	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL7@inflate_fa:

; 201  :                             do {
; 202  :                                 *out++ = *from++;

  00280	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00284	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00288	41 88 00	 mov	 BYTE PTR [r8], al
  0028b	49 ff c0	 inc	 r8

; 203  :                             } while (--op);

  0028e	83 c2 ff	 add	 edx, -1			; ffffffffH
  00291	75 ed		 jne	 SHORT $LL7@inflate_fa

; 204  :                             from = out - dist;  /* rest from output */
; 205  :                         }
; 206  :                     }

  00293	e9 8b 00 00 00	 jmp	 $LN155@inflate_fa
$LN38@inflate_fa:

; 207  :                     else if (wnext < op) {      /* wrap around window */

  00298	41 8b c6	 mov	 eax, r14d
  0029b	2b c2		 sub	 eax, edx
  0029d	44 3b f2	 cmp	 r14d, edx
  002a0	73 53		 jae	 SHORT $LN41@inflate_fa

; 208  :                         from += wsize + wnext - op;

  002a2	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR wsize$1$[rsp]

; 209  :                         op -= wnext;

  002aa	41 2b d6	 sub	 edx, r14d
  002ad	44 03 c8	 add	 r9d, eax
  002b0	4d 03 cf	 add	 r9, r15

; 210  :                         if (op < len) {         /* some from end of window */

  002b3	41 3b d3	 cmp	 edx, r11d
  002b6	73 73		 jae	 SHORT $LN69@inflate_fa

; 211  :                             len -= op;

  002b8	44 2b da	 sub	 r11d, edx
  002bb	4d 2b c8	 sub	 r9, r8
  002be	66 90		 npad	 2
$LL10@inflate_fa:

; 212  :                             do {
; 213  :                                 *out++ = *from++;

  002c0	43 0f b6 04 01	 movzx	 eax, BYTE PTR [r9+r8]
  002c5	41 88 00	 mov	 BYTE PTR [r8], al
  002c8	49 ff c0	 inc	 r8

; 214  :                             } while (--op);

  002cb	83 c2 ff	 add	 edx, -1			; ffffffffH
  002ce	75 f0		 jne	 SHORT $LL10@inflate_fa

; 215  :                             from = window;

  002d0	4d 8b cf	 mov	 r9, r15

; 216  :                             if (wnext < len) {  /* some from start of window */

  002d3	45 3b f3	 cmp	 r14d, r11d
  002d6	73 53		 jae	 SHORT $LN69@inflate_fa

; 217  :                                 op = wnext;

  002d8	41 8b ce	 mov	 ecx, r14d

; 218  :                                 len -= op;

  002db	45 2b de	 sub	 r11d, r14d
  002de	66 90		 npad	 2
$LL13@inflate_fa:

; 219  :                                 do {
; 220  :                                     *out++ = *from++;

  002e0	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  002e4	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  002e8	41 88 00	 mov	 BYTE PTR [r8], al
  002eb	49 ff c0	 inc	 r8

; 221  :                                 } while (--op);

  002ee	83 c1 ff	 add	 ecx, -1			; ffffffffH
  002f1	75 ed		 jne	 SHORT $LL13@inflate_fa

; 222  :                                 from = out - dist;      /* rest from output */
; 223  :                             }
; 224  :                         }
; 225  :                     }

  002f3	eb 2e		 jmp	 SHORT $LN155@inflate_fa
$LN41@inflate_fa:

; 226  :                     else {                      /* contiguous in window */
; 227  :                         from += wnext - op;

  002f5	44 8b c8	 mov	 r9d, eax
  002f8	4d 03 cf	 add	 r9, r15

; 228  :                         if (op < len) {         /* some from window */

  002fb	41 3b d3	 cmp	 edx, r11d
  002fe	73 2b		 jae	 SHORT $LN69@inflate_fa

; 229  :                             len -= op;

  00300	44 2b da	 sub	 r11d, edx
  00303	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL16@inflate_fa:

; 230  :                             do {
; 231  :                                 *out++ = *from++;

  00310	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00314	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00318	41 88 00	 mov	 BYTE PTR [r8], al
  0031b	49 ff c0	 inc	 r8

; 232  :                             } while (--op);

  0031e	83 c2 ff	 add	 edx, -1			; ffffffffH
  00321	75 ed		 jne	 SHORT $LL16@inflate_fa
$LN155@inflate_fa:

; 233  :                             from = out - dist;  /* rest from output */
; 234  :                         }
; 235  :                     }
; 236  :                     while (len > 2) {

  00323	8b c6		 mov	 eax, esi
  00325	4d 8b c8	 mov	 r9, r8
  00328	4c 2b c8	 sub	 r9, rax
$LN69@inflate_fa:
  0032b	41 83 fb 02	 cmp	 r11d, 2
  0032f	76 49		 jbe	 SHORT $LN18@inflate_fa
  00331	41 8d 4b fd	 lea	 ecx, DWORD PTR [r11-3]
  00335	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0033a	f7 e1		 mul	 ecx
  0033c	d1 ea		 shr	 edx, 1
  0033e	8d 4a 01	 lea	 ecx, DWORD PTR [rdx+1]
  00341	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL17@inflate_fa:

; 237  :                         *out++ = *from++;

  00350	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]

; 238  :                         *out++ = *from++;
; 239  :                         *out++ = *from++;
; 240  :                         len -= 3;

  00354	41 83 c3 fd	 add	 r11d, -3		; fffffffdH
  00358	41 88 00	 mov	 BYTE PTR [r8], al
  0035b	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00360	41 88 40 01	 mov	 BYTE PTR [r8+1], al
  00364	41 0f b6 41 02	 movzx	 eax, BYTE PTR [r9+2]
  00369	49 83 c1 03	 add	 r9, 3
  0036d	41 88 40 02	 mov	 BYTE PTR [r8+2], al
  00371	49 83 c0 03	 add	 r8, 3
  00375	48 2b cd	 sub	 rcx, rbp
  00378	75 d6		 jne	 SHORT $LL17@inflate_fa
$LN18@inflate_fa:

; 241  :                     }
; 242  :                     if (len) {

  0037a	45 85 db	 test	 r11d, r11d
  0037d	0f 84 7f 00 00
	00		 je	 $LN114@inflate_fa

; 243  :                         *out++ = *from++;

  00383	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]

; 244  :                         if (len > 1)

  00387	48 8b 74 24 10	 mov	 rsi, QWORD PTR dcode$1$[rsp]
  0038c	41 88 00	 mov	 BYTE PTR [r8], al
  0038f	49 ff c0	 inc	 r8
  00392	44 3b dd	 cmp	 r11d, ebp
  00395	4c 8b 5c 24 08	 mov	 r11, QWORD PTR end$1$[rsp]
  0039a	76 70		 jbe	 SHORT $LN2@inflate_fa

; 245  :                             *out++ = *from++;

  0039c	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  003a1	41 88 00	 mov	 BYTE PTR [r8], al
  003a4	49 ff c0	 inc	 r8

; 246  :                     }
; 247  :                 }

  003a7	eb 63		 jmp	 SHORT $LN2@inflate_fa
$LN34@inflate_fa:

; 248  :                 else {
; 249  :                     from = out - dist;          /* copy direct from output */

  003a9	8b c6		 mov	 eax, esi
  003ab	49 8b c8	 mov	 rcx, r8
  003ae	48 2b c8	 sub	 rcx, rax
$LL21@inflate_fa:

; 250  :                     do {                        /* minimum length is three */
; 251  :                         *out++ = *from++;

  003b1	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 252  :                         *out++ = *from++;
; 253  :                         *out++ = *from++;

  003b4	48 8d 49 03	 lea	 rcx, QWORD PTR [rcx+3]
  003b8	41 88 00	 mov	 BYTE PTR [r8], al

; 254  :                         len -= 3;

  003bb	41 83 c3 fd	 add	 r11d, -3		; fffffffdH
  003bf	0f b6 41 fe	 movzx	 eax, BYTE PTR [rcx-2]
  003c3	41 88 40 01	 mov	 BYTE PTR [r8+1], al
  003c7	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  003cb	41 88 40 02	 mov	 BYTE PTR [r8+2], al
  003cf	49 83 c0 03	 add	 r8, 3

; 255  :                     } while (len > 2);

  003d3	41 83 fb 02	 cmp	 r11d, 2
  003d7	77 d8		 ja	 SHORT $LL21@inflate_fa

; 256  :                     if (len) {

  003d9	45 85 db	 test	 r11d, r11d
  003dc	74 24		 je	 SHORT $LN114@inflate_fa

; 257  :                         *out++ = *from++;

  003de	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 258  :                         if (len > 1)

  003e1	48 8b 74 24 10	 mov	 rsi, QWORD PTR dcode$1$[rsp]
  003e6	41 88 00	 mov	 BYTE PTR [r8], al
  003e9	49 ff c0	 inc	 r8
  003ec	44 3b dd	 cmp	 r11d, ebp
  003ef	4c 8b 5c 24 08	 mov	 r11, QWORD PTR end$1$[rsp]
  003f4	76 16		 jbe	 SHORT $LN2@inflate_fa

; 259  :                             *out++ = *from++;

  003f6	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  003fa	41 88 00	 mov	 BYTE PTR [r8], al
  003fd	49 ff c0	 inc	 r8
  00400	eb 0a		 jmp	 SHORT $LN2@inflate_fa
$LN114@inflate_fa:

; 285  :             break;
; 286  :         }
; 287  :     } while (in < last && out < end);

  00402	4c 8b 5c 24 08	 mov	 r11, QWORD PTR end$1$[rsp]
  00407	48 8b 74 24 10	 mov	 rsi, QWORD PTR dcode$1$[rsp]
$LN2@inflate_fa:
  0040c	48 3b 7c 24 18	 cmp	 rdi, QWORD PTR last$1$[rsp]
  00411	73 5f		 jae	 SHORT $LN116@inflate_fa
  00413	4d 3b c3	 cmp	 r8, r11
  00416	73 5a		 jae	 SHORT $LN116@inflate_fa
  00418	8b 14 24	 mov	 edx, DWORD PTR tv866[rsp]
  0041b	e9 85 fc ff ff	 jmp	 $LL4@inflate_fa
$LN52@inflate_fa:

; 275  :             goto dolen;
; 276  :         }
; 277  :         else if (op & 32) {                     /* end-of-block */

  00420	f6 c2 20	 test	 dl, 32			; 00000020H
  00423	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  0042b	74 0a		 je	 SHORT $LN54@inflate_fa

; 278  :             Tracevv((stderr, "inflate:         end of block\n"));
; 279  :             state->mode = TYPE;

  0042d	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH

; 280  :             break;

  00435	eb 48		 jmp	 SHORT $LN3@inflate_fa
$LN54@inflate_fa:

; 281  :         }
; 282  :         else {
; 283  :             strm->msg = (z_const char *)"invalid literal/length code";

  00437	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  0043e	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 284  :             state->mode = BAD;

  00442	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  0044a	eb 33		 jmp	 SHORT $LN3@inflate_fa
$LN50@inflate_fa:

; 265  :                 goto dodist;
; 266  :             }
; 267  :             else {
; 268  :                 strm->msg = (z_const char *)"invalid distance code";

  0044c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@

; 269  :                 state->mode = BAD;
; 270  :                 break;

  00453	eb 07		 jmp	 SHORT $LN156@inflate_fa
$LN75@inflate_fa:

; 171  :                             strm->msg =

  00455	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
$LN156@inflate_fa:

; 288  : 
; 289  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 290  :     len = bits >> 3;

  0045c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  00464	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax
  00468	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00470	eb 08		 jmp	 SHORT $LN56@inflate_fa
$LN116@inflate_fa:
  00472	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
$LN56@inflate_fa:
  0047a	4c 8b 5c 24 08	 mov	 r11, QWORD PTR end$1$[rsp]
$LN3@inflate_fa:
  0047f	41 8b c2	 mov	 eax, r10d

; 291  :     in -= len;
; 292  :     bits -= len << 3;
; 293  :     hold &= (1U << bits) - 1;
; 294  : 
; 295  :     /* update state and return */
; 296  :     strm->next_in = in;
; 297  :     strm->next_out = out;

  00482	4c 89 42 10	 mov	 QWORD PTR [rdx+16], r8
  00486	c1 e8 03	 shr	 eax, 3

; 298  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
; 299  :     strm->avail_out = (unsigned)(out < end ?

  00489	45 2b d8	 sub	 r11d, r8d
  0048c	48 2b f8	 sub	 rdi, rax
  0048f	48 89 3a	 mov	 QWORD PTR [rdx], rdi
  00492	8d 04 c5 00 00
	00 00		 lea	 eax, DWORD PTR [rax*8]
  00499	44 2b d0	 sub	 r10d, eax
  0049c	48 8b 44 24 18	 mov	 rax, QWORD PTR last$1$[rsp]
  004a1	2b c7		 sub	 eax, edi
  004a3	41 8b ca	 mov	 ecx, r10d
  004a6	d3 e5		 shl	 ebp, cl
  004a8	83 c0 05	 add	 eax, 5
  004ab	ff cd		 dec	 ebp
  004ad	89 42 08	 mov	 DWORD PTR [rdx+8], eax
  004b0	23 dd		 and	 ebx, ebp
  004b2	41 81 c3 01 01
	00 00		 add	 r11d, 257		; 00000101H
  004b9	44 89 5a 18	 mov	 DWORD PTR [rdx+24], r11d

; 300  :                                  257 + (end - out) : 257 - (out - end));
; 301  :     state->hold = hold;

  004bd	41 89 5d 48	 mov	 DWORD PTR [r13+72], ebx

; 302  :     state->bits = bits;

  004c1	45 89 55 4c	 mov	 DWORD PTR [r13+76], r10d

; 303  :     return;
; 304  : }

  004c5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  004c9	41 5f		 pop	 r15
  004cb	41 5e		 pop	 r14
  004cd	41 5d		 pop	 r13
  004cf	41 5c		 pop	 r12
  004d1	5f		 pop	 rdi
  004d2	5e		 pop	 rsi
  004d3	5d		 pop	 rbp
  004d4	5b		 pop	 rbx
  004d5	c3		 ret	 0
inflate_fast ENDP
_TEXT	ENDS
END
