; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35209.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	adler32_combine
PUBLIC	adler32
PUBLIC	adler32_z
EXTRN	__chkstk:PROC
EXTRN	memchr:PROC
EXTRN	memcpy:PROC
EXTRN	memmove:PROC
EXTRN	memset:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_combine_ DD imagerel adler32_combine_
	DD	imagerel adler32_combine_+218
	DD	imagerel $unwind$adler32_combine_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_z DD imagerel $LN70
	DD	imagerel $LN70+963
	DD	imagerel $unwind$adler32_z
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_z DD 011d901H
	DD	04f4d9H
	DD	05e4d4H
	DD	06d4cfH
	DD	07c4caH
	DD	0874c5H
	DD	0964c0H
	DD	0a54bbH
	DD	0d34b6H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine_ DD 020501H
	DD	013405H
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\adler32.c
;	COMDAT adler32_z
_TEXT	SEGMENT
n$1$ = 0
tv2771 = 4
tv2774 = 4
tv2755 = 8
tv2775 = 8
tv2756 = 16
tv2757 = 16
adler$ = 96
sum2$1$ = 96
buf$ = 104
len$ = 112
adler$2$ = 120
adler32_z PROC						; COMDAT

; 61   : uLong ZEXPORT adler32_z(uLong adler, const Bytef *buf, z_size_t len) {

$LN70:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	4d 8b d8	 mov	 r11, r8

; 62   :     unsigned long sum2;
; 63   :     unsigned n;
; 64   : 
; 65   :     /* split Adler-32 into component sums */
; 66   :     sum2 = (adler >> 16) & 0xffff;

  00007	44 8b d1	 mov	 r10d, ecx
  0000a	41 c1 ea 10	 shr	 r10d, 16
  0000e	4c 8b ca	 mov	 r9, rdx
  00011	44 89 54 24 60	 mov	 DWORD PTR sum2$1$[rsp], r10d

; 67   :     adler &= 0xffff;

  00016	44 0f b7 c1	 movzx	 r8d, cx

; 68   : 
; 69   :     /* in case user likes doing a byte at a time, keep it fast */
; 70   :     if (len == 1) {

  0001a	49 83 fb 01	 cmp	 r11, 1
  0001e	75 33		 jne	 SHORT $LN13@adler32_z

; 71   :         adler += buf[0];

  00020	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  00023	41 03 c8	 add	 ecx, r8d

; 72   :         if (adler >= BASE)
; 73   :             adler -= BASE;
; 74   :         sum2 += adler;

  00026	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  0002c	8d 91 0f 00 ff
	ff		 lea	 edx, DWORD PTR [rcx-65521]
  00032	0f 42 d1	 cmovb	 edx, ecx
  00035	42 8d 04 12	 lea	 eax, DWORD PTR [rdx+r10]

; 75   :         if (sum2 >= BASE)
; 76   :             sum2 -= BASE;
; 77   :         return adler | (sum2 << 16);

  00039	3d f1 ff 00 00	 cmp	 eax, 65521		; 0000fff1H
  0003e	8d 88 0f 00 ff
	ff		 lea	 ecx, DWORD PTR [rax-65521]
  00044	0f 42 c8	 cmovb	 ecx, eax
  00047	c1 e1 10	 shl	 ecx, 16
  0004a	0b ca		 or	 ecx, edx
  0004c	8b c1		 mov	 eax, ecx

; 125  : }

  0004e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00052	c3		 ret	 0
$LN13@adler32_z:

; 78   :     }
; 79   : 
; 80   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 81   :     if (buf == Z_NULL)

  00053	48 85 d2	 test	 rdx, rdx
  00056	75 0a		 jne	 SHORT $LN16@adler32_z

; 82   :         return 1L;

  00058	b8 01 00 00 00	 mov	 eax, 1

; 125  : }

  0005d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00061	c3		 ret	 0
$LN16@adler32_z:

; 83   : 
; 84   :     /* in case short lengths are provided, keep it somewhat fast */
; 85   :     if (len < 16) {

  00062	49 83 fb 10	 cmp	 r11, 16
  00066	73 49		 jae	 SHORT $LN22@adler32_z

; 86   :         while (len--) {

  00068	4d 85 db	 test	 r11, r11
  0006b	74 17		 je	 SHORT $LN26@adler32_z
  0006d	0f 1f 00	 npad	 3
$LL2@adler32_z:

; 87   :             adler += *buf++;

  00070	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00074	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00078	44 03 c0	 add	 r8d, eax

; 88   :             sum2 += adler;

  0007b	45 03 d0	 add	 r10d, r8d
  0007e	49 83 eb 01	 sub	 r11, 1
  00082	75 ec		 jne	 SHORT $LL2@adler32_z
$LN26@adler32_z:

; 89   :         }
; 90   :         if (adler >= BASE)
; 91   :             adler -= BASE;
; 92   :         MOD28(sum2);            /* only added so many BASE's */

  00084	41 81 f8 f1 ff
	00 00		 cmp	 r8d, 65521		; 0000fff1H
  0008b	41 8d 88 0f 00
	ff ff		 lea	 ecx, DWORD PTR [r8-65521]
  00092	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00097	41 0f 42 c8	 cmovb	 ecx, r8d
  0009b	41 f7 e2	 mul	 r10d
  0009e	c1 ea 0f	 shr	 edx, 15
  000a1	6b c2 0f	 imul	 eax, edx, 15

; 93   :         return adler | (sum2 << 16);

  000a4	41 03 c2	 add	 eax, r10d
  000a7	c1 e0 10	 shl	 eax, 16
  000aa	0b c1		 or	 eax, ecx

; 125  : }

  000ac	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000b0	c3		 ret	 0
$LN22@adler32_z:
  000b1	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  000b6	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  000bb	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  000c0	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  000c5	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  000ca	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  000cf	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  000d4	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15

; 94   :     }
; 95   : 
; 96   :     /* do length NMAX blocks -- requires just one modulo operation */
; 97   :     while (len >= NMAX) {

  000d9	49 81 fb b0 15
	00 00		 cmp	 r11, 5552		; 000015b0H
  000e0	0f 82 6b 01 00
	00		 jb	 $LN50@adler32_z
  000e6	49 8b cb	 mov	 rcx, r11
  000e9	48 b8 f7 b6 98
	63 bb a6 ba 79	 mov	 rax, 8771506548017510135 ; 79baa6bb6398b6f7H
  000f3	49 f7 e3	 mul	 r11
  000f6	48 2b ca	 sub	 rcx, rdx
  000f9	48 d1 e9	 shr	 rcx, 1
  000fc	48 03 ca	 add	 rcx, rdx
  000ff	48 c1 e9 0c	 shr	 rcx, 12
  00103	48 69 c1 50 ea
	ff ff		 imul	 rax, rcx, -5552		; ffffffffffffea50H
  0010a	48 89 4c 24 10	 mov	 QWORD PTR tv2757[rsp], rcx
  0010f	4c 03 d8	 add	 r11, rax
  00112	4c 89 5c 24 70	 mov	 QWORD PTR len$[rsp], r11
  00117	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@adler32_z:

; 98   :         len -= NMAX;
; 99   :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  00120	c7 04 24 5b 01
	00 00		 mov	 DWORD PTR n$1$[rsp], 347 ; 0000015bH
  00127	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL8@adler32_z:

; 100  :         do {
; 101  :             DO16(buf);          /* 16 sums unrolled */

  00130	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00135	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00139	45 0f b6 69 02	 movzx	 r13d, BYTE PTR [r9+2]
  0013e	41 03 c8	 add	 ecx, r8d
  00141	45 0f b6 61 03	 movzx	 r12d, BYTE PTR [r9+3]
  00146	45 0f b6 79 04	 movzx	 r15d, BYTE PTR [r9+4]
  0014b	45 0f b6 71 05	 movzx	 r14d, BYTE PTR [r9+5]
  00150	41 0f b6 69 06	 movzx	 ebp, BYTE PTR [r9+6]
  00155	41 0f b6 71 07	 movzx	 esi, BYTE PTR [r9+7]
  0015a	41 0f b6 79 08	 movzx	 edi, BYTE PTR [r9+8]
  0015f	41 0f b6 59 09	 movzx	 ebx, BYTE PTR [r9+9]
  00164	45 0f b6 59 0a	 movzx	 r11d, BYTE PTR [r9+10]
  00169	45 0f b6 51 0b	 movzx	 r10d, BYTE PTR [r9+11]
  0016e	45 0f b6 41 0c	 movzx	 r8d, BYTE PTR [r9+12]
  00173	41 0f b6 51 0d	 movzx	 edx, BYTE PTR [r9+13]
  00178	89 4c 24 08	 mov	 DWORD PTR tv2775[rsp], ecx
  0017c	03 c8		 add	 ecx, eax
  0017e	41 0f b6 41 0f	 movzx	 eax, BYTE PTR [r9+15]
  00183	44 03 e9	 add	 r13d, ecx
  00186	45 03 e5	 add	 r12d, r13d
  00189	89 4c 24 04	 mov	 DWORD PTR tv2771[rsp], ecx
  0018d	41 0f b6 49 0e	 movzx	 ecx, BYTE PTR [r9+14]
  00192	45 03 fc	 add	 r15d, r12d
  00195	45 03 f7	 add	 r14d, r15d

; 102  :             buf += 16;

  00198	49 83 c1 10	 add	 r9, 16
  0019c	41 03 ee	 add	 ebp, r14d
  0019f	03 f5		 add	 esi, ebp
  001a1	03 fe		 add	 edi, esi
  001a3	03 df		 add	 ebx, edi
  001a5	44 03 db	 add	 r11d, ebx
  001a8	45 03 d3	 add	 r10d, r11d
  001ab	45 03 c2	 add	 r8d, r10d
  001ae	41 03 d0	 add	 edx, r8d
  001b1	03 ca		 add	 ecx, edx
  001b3	03 c1		 add	 eax, ecx
  001b5	89 44 24 78	 mov	 DWORD PTR adler$2$[rsp], eax
  001b9	8d 04 11	 lea	 eax, DWORD PTR [rcx+rdx]
  001bc	41 03 c0	 add	 eax, r8d
  001bf	44 8b 44 24 78	 mov	 r8d, DWORD PTR adler$2$[rsp]
  001c4	41 03 c2	 add	 eax, r10d
  001c7	44 8b 54 24 60	 mov	 r10d, DWORD PTR sum2$1$[rsp]
  001cc	41 03 c3	 add	 eax, r11d
  001cf	03 c3		 add	 eax, ebx
  001d1	03 c7		 add	 eax, edi
  001d3	03 c6		 add	 eax, esi
  001d5	03 c5		 add	 eax, ebp
  001d7	41 03 c6	 add	 eax, r14d
  001da	41 03 c7	 add	 eax, r15d
  001dd	41 03 c4	 add	 eax, r12d
  001e0	41 03 c5	 add	 eax, r13d
  001e3	03 44 24 04	 add	 eax, DWORD PTR tv2771[rsp]
  001e7	03 44 24 08	 add	 eax, DWORD PTR tv2775[rsp]
  001eb	41 03 c0	 add	 eax, r8d
  001ee	44 03 d0	 add	 r10d, eax

; 103  :         } while (--n);

  001f1	83 04 24 ff	 add	 DWORD PTR n$1$[rsp], -1	; ffffffffH
  001f5	44 89 54 24 60	 mov	 DWORD PTR sum2$1$[rsp], r10d
  001fa	0f 85 30 ff ff
	ff		 jne	 $LL8@adler32_z

; 104  :         MOD(adler);

  00200	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00205	41 f7 e0	 mul	 r8d
  00208	c1 ea 0f	 shr	 edx, 15
  0020b	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521	; ffff000fH
  00211	44 03 c0	 add	 r8d, eax

; 105  :         MOD(sum2);

  00214	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00219	41 f7 e2	 mul	 r10d
  0021c	c1 ea 0f	 shr	 edx, 15
  0021f	69 c2 0f 00 ff
	ff		 imul	 eax, edx, -65521	; ffff000fH
  00225	44 03 d0	 add	 r10d, eax
  00228	48 83 6c 24 10
	01		 sub	 QWORD PTR tv2757[rsp], 1
  0022e	44 89 54 24 60	 mov	 DWORD PTR sum2$1$[rsp], r10d
  00233	0f 85 e7 fe ff
	ff		 jne	 $LL4@adler32_z

; 106  :     }
; 107  : 
; 108  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 109  :     if (len) {                  /* avoid modulos if none remaining */

  00239	4c 8b 5c 24 70	 mov	 r11, QWORD PTR len$[rsp]
  0023e	4d 85 db	 test	 r11, r11
  00241	0f 84 45 01 00
	00		 je	 $LN19@adler32_z

; 110  :         while (len >= 16) {

  00247	49 83 fb 10	 cmp	 r11, 16
  0024b	0f 82 ff 00 00
	00		 jb	 $LL11@adler32_z
$LN50@adler32_z:
  00251	49 8b c3	 mov	 rax, r11
  00254	48 c1 e8 04	 shr	 rax, 4
  00258	48 89 44 24 10	 mov	 QWORD PTR tv2756[rsp], rax
  0025d	48 6b c0 f0	 imul	 rax, rax, -16
  00261	4c 03 d8	 add	 r11, rax
  00264	4c 89 5c 24 70	 mov	 QWORD PTR len$[rsp], r11
  00269	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@adler32_z:

; 111  :             len -= 16;
; 112  :             DO16(buf);

  00270	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00275	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00279	45 0f b6 61 02	 movzx	 r12d, BYTE PTR [r9+2]
  0027e	41 03 c8	 add	 ecx, r8d
  00281	45 0f b6 71 03	 movzx	 r14d, BYTE PTR [r9+3]
  00286	41 0f b6 71 04	 movzx	 esi, BYTE PTR [r9+4]
  0028b	41 0f b6 59 05	 movzx	 ebx, BYTE PTR [r9+5]
  00290	45 0f b6 51 06	 movzx	 r10d, BYTE PTR [r9+6]
  00295	41 0f b6 51 07	 movzx	 edx, BYTE PTR [r9+7]
  0029a	45 0f b6 69 09	 movzx	 r13d, BYTE PTR [r9+9]
  0029f	45 0f b6 79 0a	 movzx	 r15d, BYTE PTR [r9+10]
  002a4	41 0f b6 69 0b	 movzx	 ebp, BYTE PTR [r9+11]
  002a9	41 0f b6 79 0c	 movzx	 edi, BYTE PTR [r9+12]
  002ae	45 0f b6 59 0d	 movzx	 r11d, BYTE PTR [r9+13]
  002b3	45 0f b6 41 0e	 movzx	 r8d, BYTE PTR [r9+14]
  002b8	89 4c 24 04	 mov	 DWORD PTR tv2774[rsp], ecx
  002bc	03 c8		 add	 ecx, eax
  002be	41 0f b6 41 0f	 movzx	 eax, BYTE PTR [r9+15]
  002c3	44 03 e1	 add	 r12d, ecx
  002c6	45 03 f4	 add	 r14d, r12d
  002c9	89 4c 24 08	 mov	 DWORD PTR tv2755[rsp], ecx
  002cd	41 0f b6 49 08	 movzx	 ecx, BYTE PTR [r9+8]
  002d2	41 03 f6	 add	 esi, r14d
  002d5	03 de		 add	 ebx, esi

; 113  :             buf += 16;

  002d7	49 83 c1 10	 add	 r9, 16
  002db	44 03 d3	 add	 r10d, ebx
  002de	41 03 d2	 add	 edx, r10d
  002e1	03 ca		 add	 ecx, edx
  002e3	44 03 e9	 add	 r13d, ecx
  002e6	45 03 fd	 add	 r15d, r13d
  002e9	41 03 ef	 add	 ebp, r15d
  002ec	03 fd		 add	 edi, ebp
  002ee	44 03 df	 add	 r11d, edi
  002f1	45 03 c3	 add	 r8d, r11d
  002f4	41 03 c0	 add	 eax, r8d
  002f7	89 44 24 78	 mov	 DWORD PTR adler$2$[rsp], eax
  002fb	8d 04 11	 lea	 eax, DWORD PTR [rcx+rdx]
  002fe	41 03 c2	 add	 eax, r10d
  00301	44 8b 54 24 60	 mov	 r10d, DWORD PTR sum2$1$[rsp]
  00306	03 c3		 add	 eax, ebx
  00308	03 c6		 add	 eax, esi
  0030a	41 03 c6	 add	 eax, r14d
  0030d	41 03 c4	 add	 eax, r12d
  00310	03 44 24 08	 add	 eax, DWORD PTR tv2755[rsp]
  00314	03 44 24 04	 add	 eax, DWORD PTR tv2774[rsp]
  00318	41 03 c0	 add	 eax, r8d
  0031b	44 8b 44 24 78	 mov	 r8d, DWORD PTR adler$2$[rsp]
  00320	41 03 c3	 add	 eax, r11d
  00323	03 c7		 add	 eax, edi
  00325	03 c5		 add	 eax, ebp
  00327	41 03 c7	 add	 eax, r15d
  0032a	41 03 c5	 add	 eax, r13d
  0032d	41 03 c0	 add	 eax, r8d
  00330	44 03 d0	 add	 r10d, eax
  00333	48 83 6c 24 10
	01		 sub	 QWORD PTR tv2756[rsp], 1
  00339	44 89 54 24 60	 mov	 DWORD PTR sum2$1$[rsp], r10d
  0033e	0f 85 2c ff ff
	ff		 jne	 $LL9@adler32_z

; 114  :         }
; 115  :         while (len--) {

  00344	4c 8b 5c 24 70	 mov	 r11, QWORD PTR len$[rsp]
  00349	4d 85 db	 test	 r11, r11
  0034c	74 16		 je	 SHORT $LN30@adler32_z
  0034e	66 90		 npad	 2
$LL11@adler32_z:

; 116  :             adler += *buf++;

  00350	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00354	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  00358	44 03 c0	 add	 r8d, eax

; 117  :             sum2 += adler;

  0035b	45 03 d0	 add	 r10d, r8d
  0035e	49 83 eb 01	 sub	 r11, 1
  00362	75 ec		 jne	 SHORT $LL11@adler32_z
$LN30@adler32_z:

; 118  :         }
; 119  :         MOD(adler);

  00364	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00369	41 f7 e0	 mul	 r8d

; 120  :         MOD(sum2);

  0036c	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00371	c1 ea 0f	 shr	 edx, 15
  00374	69 ca 0f 00 ff
	ff		 imul	 ecx, edx, -65521	; ffff000fH
  0037a	41 f7 e2	 mul	 r10d
  0037d	44 03 c1	 add	 r8d, ecx
  00380	c1 ea 0f	 shr	 edx, 15
  00383	69 ca 0f 00 ff
	ff		 imul	 ecx, edx, -65521	; ffff000fH
  00389	44 03 d1	 add	 r10d, ecx
$LN19@adler32_z:

; 121  :     }
; 122  : 
; 123  :     /* return recombined sums */
; 124  :     return adler | (sum2 << 16);

  0038c	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00391	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  00396	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]
  0039b	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]
  003a0	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  003a5	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  003aa	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  003af	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  003b4	41 c1 e2 10	 shl	 r10d, 16
  003b8	45 0b d0	 or	 r10d, r8d
  003bb	41 8b c2	 mov	 eax, r10d

; 125  : }

  003be	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003c2	c3		 ret	 0
adler32_z ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\adler32.c
;	COMDAT adler32
_TEXT	SEGMENT
adler$ = 8
buf$ = 16
len$ = 24
adler32	PROC						; COMDAT

; 129  :     return adler32_z(adler, buf, len);

  00000	45 8b c0	 mov	 r8d, r8d
  00003	e9 00 00 00 00	 jmp	 adler32_z
adler32	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\adler32.c
;	COMDAT adler32_combine_
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine_ PROC					; COMDAT

; 133  : local uLong adler32_combine_(uLong adler1, uLong adler2, z_off64_t len2) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4d 8b d0	 mov	 r10, r8
  00008	8b da		 mov	 ebx, edx
  0000a	44 8b d9	 mov	 r11d, ecx

; 134  :     unsigned long sum1;
; 135  :     unsigned long sum2;
; 136  :     unsigned rem;
; 137  : 
; 138  :     /* for negative len, return invalid adler32 as a clue for debugging */
; 139  :     if (len2 < 0)

  0000d	4d 85 c0	 test	 r8, r8
  00010	79 0b		 jns	 SHORT $LN2@adler32_co

; 140  :         return 0xffffffffUL;

  00012	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH

; 150  :     if (sum1 >= BASE) sum1 -= BASE;
; 151  :     if (sum1 >= BASE) sum1 -= BASE;
; 152  :     if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);
; 153  :     if (sum2 >= BASE) sum2 -= BASE;
; 154  :     return sum1 | (sum2 << 16);
; 155  : }

  00017	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0001c	c3		 ret	 0
$LN2@adler32_co:

; 141  : 
; 142  :     /* the derivation of this formula is left as an exercise for the reader */
; 143  :     MOD63(len2);                /* assumes len2 >= 0 */
; 144  :     rem = (unsigned)len2;
; 145  :     sum1 = adler1 & 0xffff;

  0001d	41 0f b7 cb	 movzx	 ecx, r11w
  00021	48 b8 cd c5 2f
	0d e1 00 0f 00	 mov	 rax, 4223091239536077	; 000f00e10d2fc5cdH
  0002b	49 f7 e2	 mul	 r10

; 146  :     sum2 = rem * sum1;

  0002e	44 8b c1	 mov	 r8d, ecx

; 147  :     MOD(sum2);
; 148  :     sum1 += (adler2 & 0xffff) + BASE - 1;
; 149  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;

  00031	41 c1 eb 10	 shr	 r11d, 16
  00035	49 8b c2	 mov	 rax, r10
  00038	44 0f b7 cb	 movzx	 r9d, bx
  0003c	48 2b c2	 sub	 rax, rdx
  0003f	c1 eb 10	 shr	 ebx, 16
  00042	48 d1 e8	 shr	 rax, 1
  00045	44 03 c9	 add	 r9d, ecx
  00048	48 03 c2	 add	 rax, rdx
  0004b	48 c1 e8 0f	 shr	 rax, 15
  0004f	69 c0 f1 ff 00
	00		 imul	 eax, eax, 65521		; 0000fff1H
  00055	44 2b d0	 sub	 r10d, eax
  00058	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  0005d	45 0f af c2	 imul	 r8d, r10d
  00061	41 f7 e0	 mul	 r8d
  00064	c1 ea 0f	 shr	 edx, 15
  00067	69 c2 f1 ff 00
	00		 imul	 eax, edx, 65521		; 0000fff1H
  0006d	44 2b d8	 sub	 r11d, eax
  00070	41 8d 81 f0 ff
	00 00		 lea	 eax, DWORD PTR [r9+65520]
  00077	42 8d 0c 1b	 lea	 ecx, DWORD PTR [rbx+r11]

; 150  :     if (sum1 >= BASE) sum1 -= BASE;
; 151  :     if (sum1 >= BASE) sum1 -= BASE;
; 152  :     if (sum2 >= ((unsigned long)BASE << 1)) sum2 -= ((unsigned long)BASE << 1);
; 153  :     if (sum2 >= BASE) sum2 -= BASE;
; 154  :     return sum1 | (sum2 << 16);
; 155  : }

  0007b	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00080	41 2b ca	 sub	 ecx, r10d
  00083	41 ba f0 ff 00
	00		 mov	 r10d, 65520		; 0000fff0H
  00089	41 03 c8	 add	 ecx, r8d
  0008c	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  00092	3d f1 ff 00 00	 cmp	 eax, 65521		; 0000fff1H
  00097	45 0f 42 c2	 cmovb	 r8d, r10d
  0009b	8d 91 f1 ff 00
	00		 lea	 edx, DWORD PTR [rcx+65521]
  000a1	45 03 c1	 add	 r8d, r9d
  000a4	81 c1 0f 00 ff
	ff		 add	 ecx, -65521		; ffff000fH
  000aa	81 fa e2 ff 01
	00		 cmp	 edx, 131042		; 0001ffe2H
  000b0	0f 42 ca	 cmovb	 ecx, edx
  000b3	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  000b9	8d 81 0f 00 ff
	ff		 lea	 eax, DWORD PTR [rcx-65521]
  000bf	0f 42 c1	 cmovb	 eax, ecx
  000c2	41 8d 88 0f 00
	ff ff		 lea	 ecx, DWORD PTR [r8-65521]
  000c9	c1 e0 10	 shl	 eax, 16
  000cc	41 81 f8 f1 ff
	00 00		 cmp	 r8d, 65521		; 0000fff1H
  000d3	41 0f 42 c8	 cmovb	 ecx, r8d
  000d7	0b c1		 or	 eax, ecx
  000d9	c3		 ret	 0
adler32_combine_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\adler32.c
;	COMDAT adler32_combine
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine PROC					; COMDAT

; 159  :     return adler32_combine_(adler1, adler2, len2);

  00000	e9 00 00 00 00	 jmp	 adler32_combine_
adler32_combine ENDP
_TEXT	ENDS
END
