; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35209.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	_length_code
PUBLIC	_dist_code
_length_code DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
_dist_code DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	00H
	DB	00H
	DB	010H
	DB	011H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01bH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01cH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
	DB	01dH
static_dtree DW	00H
	DW	05H
	DW	010H
	DW	05H
	DW	08H
	DW	05H
	DW	018H
	DW	05H
	DW	04H
	DW	05H
	DW	014H
	DW	05H
	DW	0cH
	DW	05H
	DW	01cH
	DW	05H
	DW	02H
	DW	05H
	DW	012H
	DW	05H
	DW	0aH
	DW	05H
	DW	01aH
	DW	05H
	DW	06H
	DW	05H
	DW	016H
	DW	05H
	DW	0eH
	DW	05H
	DW	01eH
	DW	05H
	DW	01H
	DW	05H
	DW	011H
	DW	05H
	DW	09H
	DW	05H
	DW	019H
	DW	05H
	DW	05H
	DW	05H
	DW	015H
	DW	05H
	DW	0dH
	DW	05H
	DW	01dH
	DW	05H
	DW	03H
	DW	05H
	DW	013H
	DW	05H
	DW	0bH
	DW	05H
	DW	01bH
	DW	05H
	DW	07H
	DW	05H
	DW	017H
	DW	05H
	ORG $+8
extra_blbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	03H
	DD	07H
	ORG $+4
extra_lbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	ORG $+12
base_dist DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	06H
	DD	08H
	DD	0cH
	DD	010H
	DD	018H
	DD	020H
	DD	030H
	DD	040H
	DD	060H
	DD	080H
	DD	0c0H
	DD	0100H
	DD	0180H
	DD	0200H
	DD	0300H
	DD	0400H
	DD	0600H
	DD	0800H
	DD	0c00H
	DD	01000H
	DD	01800H
	DD	02000H
	DD	03000H
	DD	04000H
	DD	06000H
	ORG $+8
base_length DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	0aH
	DD	0cH
	DD	0eH
	DD	010H
	DD	014H
	DD	018H
	DD	01cH
	DD	020H
	DD	028H
	DD	030H
	DD	038H
	DD	040H
	DD	050H
	DD	060H
	DD	070H
	DD	080H
	DD	0a0H
	DD	0c0H
	DD	0e0H
	DD	00H
	ORG $+4
static_l_desc DQ FLAT:static_ltree
	DQ	FLAT:extra_lbits
	DD	0101H
	DD	011eH
	DD	0fH
	ORG $+4
static_bl_desc DQ 0000000000000000H
	DQ	FLAT:extra_blbits
	DD	00H
	DD	013H
	DD	07H
	ORG $+4
	ORG $+8
extra_dbits DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
static_ltree DW	0cH
	DW	08H
	DW	08cH
	DW	08H
	DW	04cH
	DW	08H
	DW	0ccH
	DW	08H
	DW	02cH
	DW	08H
	DW	0acH
	DW	08H
	DW	06cH
	DW	08H
	DW	0ecH
	DW	08H
	DW	01cH
	DW	08H
	DW	09cH
	DW	08H
	DW	05cH
	DW	08H
	DW	0dcH
	DW	08H
	DW	03cH
	DW	08H
	DW	0bcH
	DW	08H
	DW	07cH
	DW	08H
	DW	0fcH
	DW	08H
	DW	02H
	DW	08H
	DW	082H
	DW	08H
	DW	042H
	DW	08H
	DW	0c2H
	DW	08H
	DW	022H
	DW	08H
	DW	0a2H
	DW	08H
	DW	062H
	DW	08H
	DW	0e2H
	DW	08H
	DW	012H
	DW	08H
	DW	092H
	DW	08H
	DW	052H
	DW	08H
	DW	0d2H
	DW	08H
	DW	032H
	DW	08H
	DW	0b2H
	DW	08H
	DW	072H
	DW	08H
	DW	0f2H
	DW	08H
	DW	0aH
	DW	08H
	DW	08aH
	DW	08H
	DW	04aH
	DW	08H
	DW	0caH
	DW	08H
	DW	02aH
	DW	08H
	DW	0aaH
	DW	08H
	DW	06aH
	DW	08H
	DW	0eaH
	DW	08H
	DW	01aH
	DW	08H
	DW	09aH
	DW	08H
	DW	05aH
	DW	08H
	DW	0daH
	DW	08H
	DW	03aH
	DW	08H
	DW	0baH
	DW	08H
	DW	07aH
	DW	08H
	DW	0faH
	DW	08H
	DW	06H
	DW	08H
	DW	086H
	DW	08H
	DW	046H
	DW	08H
	DW	0c6H
	DW	08H
	DW	026H
	DW	08H
	DW	0a6H
	DW	08H
	DW	066H
	DW	08H
	DW	0e6H
	DW	08H
	DW	016H
	DW	08H
	DW	096H
	DW	08H
	DW	056H
	DW	08H
	DW	0d6H
	DW	08H
	DW	036H
	DW	08H
	DW	0b6H
	DW	08H
	DW	076H
	DW	08H
	DW	0f6H
	DW	08H
	DW	0eH
	DW	08H
	DW	08eH
	DW	08H
	DW	04eH
	DW	08H
	DW	0ceH
	DW	08H
	DW	02eH
	DW	08H
	DW	0aeH
	DW	08H
	DW	06eH
	DW	08H
	DW	0eeH
	DW	08H
	DW	01eH
	DW	08H
	DW	09eH
	DW	08H
	DW	05eH
	DW	08H
	DW	0deH
	DW	08H
	DW	03eH
	DW	08H
	DW	0beH
	DW	08H
	DW	07eH
	DW	08H
	DW	0feH
	DW	08H
	DW	01H
	DW	08H
	DW	081H
	DW	08H
	DW	041H
	DW	08H
	DW	0c1H
	DW	08H
	DW	021H
	DW	08H
	DW	0a1H
	DW	08H
	DW	061H
	DW	08H
	DW	0e1H
	DW	08H
	DW	011H
	DW	08H
	DW	091H
	DW	08H
	DW	051H
	DW	08H
	DW	0d1H
	DW	08H
	DW	031H
	DW	08H
	DW	0b1H
	DW	08H
	DW	071H
	DW	08H
	DW	0f1H
	DW	08H
	DW	09H
	DW	08H
	DW	089H
	DW	08H
	DW	049H
	DW	08H
	DW	0c9H
	DW	08H
	DW	029H
	DW	08H
	DW	0a9H
	DW	08H
	DW	069H
	DW	08H
	DW	0e9H
	DW	08H
	DW	019H
	DW	08H
	DW	099H
	DW	08H
	DW	059H
	DW	08H
	DW	0d9H
	DW	08H
	DW	039H
	DW	08H
	DW	0b9H
	DW	08H
	DW	079H
	DW	08H
	DW	0f9H
	DW	08H
	DW	05H
	DW	08H
	DW	085H
	DW	08H
	DW	045H
	DW	08H
	DW	0c5H
	DW	08H
	DW	025H
	DW	08H
	DW	0a5H
	DW	08H
	DW	065H
	DW	08H
	DW	0e5H
	DW	08H
	DW	015H
	DW	08H
	DW	095H
	DW	08H
	DW	055H
	DW	08H
	DW	0d5H
	DW	08H
	DW	035H
	DW	08H
	DW	0b5H
	DW	08H
	DW	075H
	DW	08H
	DW	0f5H
	DW	08H
	DW	0dH
	DW	08H
	DW	08dH
	DW	08H
	DW	04dH
	DW	08H
	DW	0cdH
	DW	08H
	DW	02dH
	DW	08H
	DW	0adH
	DW	08H
	DW	06dH
	DW	08H
	DW	0edH
	DW	08H
	DW	01dH
	DW	08H
	DW	09dH
	DW	08H
	DW	05dH
	DW	08H
	DW	0ddH
	DW	08H
	DW	03dH
	DW	08H
	DW	0bdH
	DW	08H
	DW	07dH
	DW	08H
	DW	0fdH
	DW	08H
	DW	013H
	DW	09H
	DW	0113H
	DW	09H
	DW	093H
	DW	09H
	DW	0193H
	DW	09H
	DW	053H
	DW	09H
	DW	0153H
	DW	09H
	DW	0d3H
	DW	09H
	DW	01d3H
	DW	09H
	DW	033H
	DW	09H
	DW	0133H
	DW	09H
	DW	0b3H
	DW	09H
	DW	01b3H
	DW	09H
	DW	073H
	DW	09H
	DW	0173H
	DW	09H
	DW	0f3H
	DW	09H
	DW	01f3H
	DW	09H
	DW	0bH
	DW	09H
	DW	010bH
	DW	09H
	DW	08bH
	DW	09H
	DW	018bH
	DW	09H
	DW	04bH
	DW	09H
	DW	014bH
	DW	09H
	DW	0cbH
	DW	09H
	DW	01cbH
	DW	09H
	DW	02bH
	DW	09H
	DW	012bH
	DW	09H
	DW	0abH
	DW	09H
	DW	01abH
	DW	09H
	DW	06bH
	DW	09H
	DW	016bH
	DW	09H
	DW	0ebH
	DW	09H
	DW	01ebH
	DW	09H
	DW	01bH
	DW	09H
	DW	011bH
	DW	09H
	DW	09bH
	DW	09H
	DW	019bH
	DW	09H
	DW	05bH
	DW	09H
	DW	015bH
	DW	09H
	DW	0dbH
	DW	09H
	DW	01dbH
	DW	09H
	DW	03bH
	DW	09H
	DW	013bH
	DW	09H
	DW	0bbH
	DW	09H
	DW	01bbH
	DW	09H
	DW	07bH
	DW	09H
	DW	017bH
	DW	09H
	DW	0fbH
	DW	09H
	DW	01fbH
	DW	09H
	DW	07H
	DW	09H
	DW	0107H
	DW	09H
	DW	087H
	DW	09H
	DW	0187H
	DW	09H
	DW	047H
	DW	09H
	DW	0147H
	DW	09H
	DW	0c7H
	DW	09H
	DW	01c7H
	DW	09H
	DW	027H
	DW	09H
	DW	0127H
	DW	09H
	DW	0a7H
	DW	09H
	DW	01a7H
	DW	09H
	DW	067H
	DW	09H
	DW	0167H
	DW	09H
	DW	0e7H
	DW	09H
	DW	01e7H
	DW	09H
	DW	017H
	DW	09H
	DW	0117H
	DW	09H
	DW	097H
	DW	09H
	DW	0197H
	DW	09H
	DW	057H
	DW	09H
	DW	0157H
	DW	09H
	DW	0d7H
	DW	09H
	DW	01d7H
	DW	09H
	DW	037H
	DW	09H
	DW	0137H
	DW	09H
	DW	0b7H
	DW	09H
	DW	01b7H
	DW	09H
	DW	077H
	DW	09H
	DW	0177H
	DW	09H
	DW	0f7H
	DW	09H
	DW	01f7H
	DW	09H
	DW	0fH
	DW	09H
	DW	010fH
	DW	09H
	DW	08fH
	DW	09H
	DW	018fH
	DW	09H
	DW	04fH
	DW	09H
	DW	014fH
	DW	09H
	DW	0cfH
	DW	09H
	DW	01cfH
	DW	09H
	DW	02fH
	DW	09H
	DW	012fH
	DW	09H
	DW	0afH
	DW	09H
	DW	01afH
	DW	09H
	DW	06fH
	DW	09H
	DW	016fH
	DW	09H
	DW	0efH
	DW	09H
	DW	01efH
	DW	09H
	DW	01fH
	DW	09H
	DW	011fH
	DW	09H
	DW	09fH
	DW	09H
	DW	019fH
	DW	09H
	DW	05fH
	DW	09H
	DW	015fH
	DW	09H
	DW	0dfH
	DW	09H
	DW	01dfH
	DW	09H
	DW	03fH
	DW	09H
	DW	013fH
	DW	09H
	DW	0bfH
	DW	09H
	DW	01bfH
	DW	09H
	DW	07fH
	DW	09H
	DW	017fH
	DW	09H
	DW	0ffH
	DW	09H
	DW	01ffH
	DW	09H
	DW	00H
	DW	07H
	DW	040H
	DW	07H
	DW	020H
	DW	07H
	DW	060H
	DW	07H
	DW	010H
	DW	07H
	DW	050H
	DW	07H
	DW	030H
	DW	07H
	DW	070H
	DW	07H
	DW	08H
	DW	07H
	DW	048H
	DW	07H
	DW	028H
	DW	07H
	DW	068H
	DW	07H
	DW	018H
	DW	07H
	DW	058H
	DW	07H
	DW	038H
	DW	07H
	DW	078H
	DW	07H
	DW	04H
	DW	07H
	DW	044H
	DW	07H
	DW	024H
	DW	07H
	DW	064H
	DW	07H
	DW	014H
	DW	07H
	DW	054H
	DW	07H
	DW	034H
	DW	07H
	DW	074H
	DW	07H
	DW	03H
	DW	08H
	DW	083H
	DW	08H
	DW	043H
	DW	08H
	DW	0c3H
	DW	08H
	DW	023H
	DW	08H
	DW	0a3H
	DW	08H
	DW	063H
	DW	08H
	DW	0e3H
	DW	08H
static_d_desc DQ FLAT:static_dtree
	DQ	FLAT:extra_dbits
	DD	00H
	DD	01eH
	DD	0fH
	ORG $+4
bl_order DB	010H
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
PUBLIC	_tr_align
PUBLIC	_tr_init
PUBLIC	_tr_flush_block
PUBLIC	_tr_flush_bits
PUBLIC	_tr_stored_block
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress_block DD imagerel compress_block
	DD	imagerel compress_block+18
	DD	imagerel $unwind$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$compress_block DD imagerel compress_block+18
	DD	imagerel compress_block+65
	DD	imagerel $chain$0$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$compress_block DD imagerel compress_block+65
	DD	imagerel compress_block+904
	DD	imagerel $chain$3$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$compress_block DD imagerel compress_block+904
	DD	imagerel compress_block+963
	DD	imagerel $chain$4$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$compress_block DD imagerel compress_block+963
	DD	imagerel compress_block+1055
	DD	imagerel $chain$5$compress_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_all_trees DD imagerel send_all_trees
	DD	imagerel send_all_trees+613
	DD	imagerel $unwind$send_all_trees
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_bl_tree DD imagerel build_bl_tree
	DD	imagerel build_bl_tree+193
	DD	imagerel $unwind$build_bl_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_tree DD imagerel send_tree
	DD	imagerel send_tree+21
	DD	imagerel $unwind$send_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$send_tree DD imagerel send_tree+21
	DD	imagerel send_tree+1315
	DD	imagerel $chain$6$send_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$send_tree DD imagerel send_tree+1315
	DD	imagerel send_tree+1316
	DD	imagerel $chain$7$send_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scan_tree DD imagerel scan_tree
	DD	imagerel scan_tree+38
	DD	imagerel $unwind$scan_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$scan_tree DD imagerel scan_tree+38
	DD	imagerel scan_tree+284
	DD	imagerel $chain$3$scan_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$scan_tree DD imagerel scan_tree+284
	DD	imagerel scan_tree+286
	DD	imagerel $chain$4$scan_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_tree DD imagerel build_tree
	DD	imagerel build_tree+623
	DD	imagerel $unwind$build_tree
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gen_bitlen DD imagerel gen_bitlen
	DD	imagerel gen_bitlen+119
	DD	imagerel $unwind$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gen_bitlen DD imagerel gen_bitlen+119
	DD	imagerel gen_bitlen+127
	DD	imagerel $chain$0$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gen_bitlen DD imagerel gen_bitlen+127
	DD	imagerel gen_bitlen+316
	DD	imagerel $chain$2$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gen_bitlen DD imagerel gen_bitlen+316
	DD	imagerel gen_bitlen+519
	DD	imagerel $chain$3$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$gen_bitlen DD imagerel gen_bitlen+519
	DD	imagerel gen_bitlen+532
	DD	imagerel $chain$4$gen_bitlen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pqdownheap DD imagerel pqdownheap
	DD	imagerel pqdownheap+36
	DD	imagerel $unwind$pqdownheap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pqdownheap DD imagerel pqdownheap+36
	DD	imagerel pqdownheap+188
	DD	imagerel $chain$0$pqdownheap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pqdownheap DD imagerel pqdownheap+188
	DD	imagerel pqdownheap+210
	DD	imagerel $chain$2$pqdownheap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$pqdownheap DD imagerel pqdownheap+210
	DD	imagerel pqdownheap+225
	DD	imagerel $chain$3$pqdownheap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gen_codes DD imagerel gen_codes
	DD	imagerel gen_codes+283
	DD	imagerel $unwind$gen_codes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tr_flush_block DD imagerel $LN29
	DD	imagerel $LN29+539
	DD	imagerel $unwind$_tr_flush_block
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_tr_stored_block DD imagerel $LN11
	DD	imagerel $LN11+255
	DD	imagerel $unwind$_tr_stored_block
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tr_stored_block DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_tr_flush_block DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gen_codes DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$pqdownheap DD 021H
	DD	imagerel pqdownheap
	DD	imagerel pqdownheap+36
	DD	imagerel $unwind$pqdownheap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pqdownheap DD 020021H
	DD	026400H
	DD	imagerel pqdownheap
	DD	imagerel pqdownheap+36
	DD	imagerel $unwind$pqdownheap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pqdownheap DD 020521H
	DD	026405H
	DD	imagerel pqdownheap
	DD	imagerel pqdownheap+36
	DD	imagerel $unwind$pqdownheap
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pqdownheap DD 030601H
	DD	033406H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$gen_bitlen DD 021H
	DD	imagerel gen_bitlen
	DD	imagerel gen_bitlen+119
	DD	imagerel $unwind$gen_bitlen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gen_bitlen DD 021H
	DD	imagerel gen_bitlen+119
	DD	imagerel gen_bitlen+127
	DD	imagerel $chain$0$gen_bitlen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gen_bitlen DD 040c21H
	DD	0e40cH
	DD	015405H
	DD	imagerel gen_bitlen+119
	DD	imagerel gen_bitlen+127
	DD	imagerel $chain$0$gen_bitlen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gen_bitlen DD 020521H
	DD	0a3405H
	DD	imagerel gen_bitlen
	DD	imagerel gen_bitlen+119
	DD	imagerel $unwind$gen_bitlen
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gen_bitlen DD 060d01H
	DD	0f009120dH
	DD	0c005d007H
	DD	060027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_tree DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$scan_tree DD 021H
	DD	imagerel scan_tree
	DD	imagerel scan_tree+38
	DD	imagerel $unwind$scan_tree
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$scan_tree DD 082121H
	DD	05e421H
	DD	046418H
	DD	03540eH
	DD	023405H
	DD	imagerel scan_tree
	DD	imagerel scan_tree+38
	DD	imagerel $unwind$scan_tree
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scan_tree DD 010201H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$send_tree DD 021H
	DD	imagerel send_tree
	DD	imagerel send_tree+21
	DD	imagerel $unwind$send_tree
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$send_tree DD 0e4221H
	DD	0f442H
	DD	01e43cH
	DD	02d424H
	DD	03c41fH
	DD	087414H
	DD	07540cH
	DD	063405H
	DD	imagerel send_tree
	DD	imagerel send_tree+21
	DD	imagerel $unwind$send_tree
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_tree DD 020e01H
	DD	0600a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_bl_tree DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_all_trees DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$compress_block DD 021H
	DD	imagerel compress_block
	DD	imagerel compress_block+18
	DD	imagerel $unwind$compress_block
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$compress_block DD 021H
	DD	imagerel compress_block+18
	DD	imagerel compress_block+65
	DD	imagerel $chain$0$compress_block
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$compress_block DD 061621H
	DD	03f416H
	DD	04e411H
	DD	05d405H
	DD	imagerel compress_block+18
	DD	imagerel compress_block+65
	DD	imagerel $chain$0$compress_block
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$compress_block DD 020521H
	DD	06c405H
	DD	imagerel compress_block
	DD	imagerel compress_block+18
	DD	imagerel $unwind$compress_block
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress_block DD 051201H
	DD	0700e6212H
	DD	0500c600dH
	DD	0300bH
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT _tr_stored_block
_TEXT	SEGMENT
s$ = 48
buf$ = 56
stored_len$ = 64
last$ = 72
_tr_stored_block PROC					; COMDAT

; 861  :                                     ulg stored_len, int last) {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	41 8b f8	 mov	 edi, r8d
  0000d	48 8b d9	 mov	 rbx, rcx

; 862  :     send_bits(s, (STORED_BLOCK<<1) + last, 3);  /* send block type */

  00010	8b 89 10 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5904]
  00016	45 0f b7 c1	 movzx	 r8d, r9w
  0001a	66 41 d3 e0	 shl	 r8w, cl
  0001e	4c 8b d2	 mov	 r10, rdx
  00021	66 44 0b 83 0c
	17 00 00	 or	 r8w, WORD PTR [rbx+5900]
  00029	83 f9 0d	 cmp	 ecx, 13
  0002c	7e 40		 jle	 SHORT $LN2@tr_stored_
  0002e	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00031	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00035	66 44 89 83 0c
	17 00 00	 mov	 WORD PTR [rbx+5900], r8w
  0003d	44 88 04 01	 mov	 BYTE PTR [rcx+rax], r8b
  00041	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00044	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00047	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0004b	0f b6 83 0d 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5901]
  00052	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00055	b9 10 00 00 00	 mov	 ecx, 16
  0005a	8b 93 10 17 00
	00		 mov	 edx, DWORD PTR [rbx+5904]
  00060	2a ca		 sub	 cl, dl
  00062	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00065	66 41 d3 e9	 shr	 r9w, cl
  00069	8d 42 f3	 lea	 eax, DWORD PTR [rdx-13]
  0006c	eb 07		 jmp	 SHORT $LN9@tr_stored_
$LN2@tr_stored_:
  0006e	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
  00071	45 0f b7 c8	 movzx	 r9d, r8w
$LN9@tr_stored_:

; 863  :     bi_windup(s);        /* align on byte boundary */

  00075	89 83 10 17 00
	00		 mov	 DWORD PTR [rbx+5904], eax
  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	66 44 89 8b 0c
	17 00 00	 mov	 WORD PTR [rbx+5900], r9w
  00086	e8 00 00 00 00	 call	 bi_windup

; 864  :     put_short(s, (ush)stored_len);

  0008b	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0008e	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00092	40 88 3c 01	 mov	 BYTE PTR [rcx+rax], dil
  00096	0f b7 cf	 movzx	 ecx, di
  00099	ff 43 28	 inc	 DWORD PTR [rbx+40]
  0009c	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  0009f	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000a3	66 c1 e9 08	 shr	 cx, 8
  000a7	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl

; 865  :     put_short(s, (ush)~stored_len);

  000aa	40 0f b6 cf	 movzx	 ecx, dil
  000ae	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000b1	f6 d1		 not	 cl
  000b3	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000b6	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000ba	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl
  000bd	0f b7 cf	 movzx	 ecx, di
  000c0	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000c3	66 f7 d1	 not	 cx
  000c6	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000c9	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000cd	66 c1 e9 08	 shr	 cx, 8
  000d1	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl
  000d4	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  000d7	ff c0		 inc	 eax
  000d9	89 43 28	 mov	 DWORD PTR [rbx+40], eax

; 866  :     if (stored_len)

  000dc	85 ff		 test	 edi, edi
  000de	74 11		 je	 SHORT $LN6@tr_stored_

; 867  :         zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);

  000e0	8b c8		 mov	 ecx, eax
  000e2	4c 8b c7	 mov	 r8, rdi
  000e5	48 03 4b 10	 add	 rcx, QWORD PTR [rbx+16]
  000e9	49 8b d2	 mov	 rdx, r10
  000ec	e8 00 00 00 00	 call	 memcpy
$LN6@tr_stored_:

; 868  :     s->pending += stored_len;
; 869  : #ifdef ZLIB_DEBUG
; 870  :     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
; 871  :     s->compressed_len += (stored_len + 4) << 3;
; 872  :     s->bits_sent += 2*16;
; 873  :     s->bits_sent += stored_len << 3;
; 874  : #endif
; 875  : }

  000f1	01 7b 28	 add	 DWORD PTR [rbx+40], edi
  000f4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fd	5f		 pop	 rdi
  000fe	c3		 ret	 0
_tr_stored_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT _tr_flush_bits
_TEXT	SEGMENT
s$ = 8
_tr_flush_bits PROC					; COMDAT

; 881  :     bi_flush(s);

  00000	e9 00 00 00 00	 jmp	 bi_flush
_tr_flush_bits ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT _tr_flush_block
_TEXT	SEGMENT
s$ = 48
buf$ = 56
stored_len$ = 64
last$ = 72
_tr_flush_block PROC					; COMDAT

; 998  :                                    ulg stored_len, int last) {

$LN29:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 999  :     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
; 1000 :     int max_blindex = 0;  /* index of last bit length code of non zero freq */

  00014	45 33 db	 xor	 r11d, r11d
  00017	41 8b f1	 mov	 esi, r9d
  0001a	41 8b f8	 mov	 edi, r8d
  0001d	48 8b ea	 mov	 rbp, rdx
  00020	48 8b d9	 mov	 rbx, rcx

; 1001 : 
; 1002 :     /* Build the Huffman trees unless a stored block is forced */
; 1003 :     if (s->level > 0) {

  00023	44 39 99 ac 00
	00 00		 cmp	 DWORD PTR [rcx+172], r11d
  0002a	7e 65		 jle	 SHORT $LN2@tr_flush_b

; 1004 : 
; 1005 :         /* Check if the file is binary or text */
; 1006 :         if (s->strm->data_type == Z_UNKNOWN)

  0002c	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  0002f	41 83 7a 48 02	 cmp	 DWORD PTR [r10+72], 2
  00034	75 09		 jne	 SHORT $LN4@tr_flush_b

; 1007 :             s->strm->data_type = detect_data_type(s);

  00036	e8 00 00 00 00	 call	 detect_data_type
  0003b	41 89 42 48	 mov	 DWORD PTR [r10+72], eax
$LN4@tr_flush_b:

; 1008 : 
; 1009 :         /* Construct the literal and distance trees */
; 1010 :         build_tree(s, (tree_desc *)(&(s->l_desc)));

  0003f	48 8d 93 40 0b
	00 00		 lea	 rdx, QWORD PTR [rbx+2880]
  00046	48 8b cb	 mov	 rcx, rbx
  00049	e8 00 00 00 00	 call	 build_tree

; 1011 :         Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
; 1012 :                 s->static_len));
; 1013 : 
; 1014 :         build_tree(s, (tree_desc *)(&(s->d_desc)));

  0004e	48 8d 93 58 0b
	00 00		 lea	 rdx, QWORD PTR [rbx+2904]
  00055	48 8b cb	 mov	 rcx, rbx
  00058	e8 00 00 00 00	 call	 build_tree

; 1015 :         Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
; 1016 :                 s->static_len));
; 1017 :         /* At this point, opt_len and static_len are the total bit lengths of
; 1018 :          * the compressed block data, excluding the tree representations.
; 1019 :          */
; 1020 : 
; 1021 :         /* Build the bit length tree for the above two trees, and get the index
; 1022 :          * in bl_order of the last bit length code to send.
; 1023 :          */
; 1024 :         max_blindex = build_bl_tree(s);

  0005d	48 8b cb	 mov	 rcx, rbx
  00060	e8 00 00 00 00	 call	 build_bl_tree

; 1025 : 
; 1026 :         /* Determine the best encoding. Compute the block lengths in bytes. */
; 1027 :         opt_lenb = (s->opt_len + 3 + 7) >> 3;

  00065	8b 8b fc 16 00
	00		 mov	 ecx, DWORD PTR [rbx+5884]
  0006b	44 8b d8	 mov	 r11d, eax

; 1028 :         static_lenb = (s->static_len + 3 + 7) >> 3;

  0006e	8b 93 00 17 00
	00		 mov	 edx, DWORD PTR [rbx+5888]
  00074	83 c1 0a	 add	 ecx, 10
  00077	83 c2 0a	 add	 edx, 10
  0007a	c1 e9 03	 shr	 ecx, 3
  0007d	c1 ea 03	 shr	 edx, 3

; 1029 : 
; 1030 :         Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
; 1031 :                 opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
; 1032 :                 s->sym_next / 3));
; 1033 : 
; 1034 : #ifndef FORCE_STATIC
; 1035 :         if (static_lenb <= opt_lenb || s->strategy == Z_FIXED)

  00080	3b d1		 cmp	 edx, ecx
  00082	76 09		 jbe	 SHORT $LN6@tr_flush_b
  00084	83 bb b0 00 00
	00 04		 cmp	 DWORD PTR [rbx+176], 4
  0008b	75 0a		 jne	 SHORT $LN3@tr_flush_b
$LN6@tr_flush_b:

; 1036 : #endif
; 1037 :             opt_lenb = static_lenb;

  0008d	8b ca		 mov	 ecx, edx

; 1038 : 
; 1039 :     } else {

  0008f	eb 06		 jmp	 SHORT $LN3@tr_flush_b
$LN2@tr_flush_b:

; 1040 :         Assert(buf != (char*)0, "lost buf");
; 1041 :         opt_lenb = static_lenb = stored_len + 5; /* force a stored block */

  00091	41 8d 48 05	 lea	 ecx, DWORD PTR [r8+5]
  00095	8b d1		 mov	 edx, ecx
$LN3@tr_flush_b:

; 1042 :     }
; 1043 : 
; 1044 : #ifdef FORCE_STORED
; 1045 :     if (buf != (char*)0) { /* force stored block */
; 1046 : #else
; 1047 :     if (stored_len + 4 <= opt_lenb && buf != (char*)0) {

  00097	8d 47 04	 lea	 eax, DWORD PTR [rdi+4]
  0009a	3b c1		 cmp	 eax, ecx
  0009c	77 1b		 ja	 SHORT $LN7@tr_flush_b
  0009e	48 85 ed	 test	 rbp, rbp
  000a1	74 16		 je	 SHORT $LN7@tr_flush_b

; 1048 :                        /* 4: two words for the lengths */
; 1049 : #endif
; 1050 :         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
; 1051 :          * Otherwise we can't have processed more than WSIZE input bytes since
; 1052 :          * the last block flush, because compression would have been
; 1053 :          * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
; 1054 :          * transform a block into a stored block.
; 1055 :          */
; 1056 :         _tr_stored_block(s, buf, stored_len, last);

  000a3	44 8b ce	 mov	 r9d, esi
  000a6	44 8b c7	 mov	 r8d, edi
  000a9	48 8b d5	 mov	 rdx, rbp
  000ac	48 8b cb	 mov	 rcx, rbx
  000af	e8 00 00 00 00	 call	 _tr_stored_block
  000b4	e9 3c 01 00 00	 jmp	 $LN10@tr_flush_b
$LN7@tr_flush_b:

; 1057 : 
; 1058 :     } else if (static_lenb == opt_lenb) {

  000b9	8b 83 10 17 00
	00		 mov	 eax, DWORD PTR [rbx+5904]
  000bf	3b d1		 cmp	 edx, ecx
  000c1	44 0f b7 93 0c
	17 00 00	 movzx	 r10d, WORD PTR [rbx+5900]
  000c9	8b c8		 mov	 ecx, eax
  000cb	0f 85 86 00 00
	00		 jne	 $LN9@tr_flush_b

; 1059 :         send_bits(s, (STATIC_TREES<<1) + last, 3);

  000d1	44 8d 46 02	 lea	 r8d, DWORD PTR [rsi+2]
  000d5	45 0f b7 c8	 movzx	 r9d, r8w
  000d9	66 41 d3 e1	 shl	 r9w, cl
  000dd	66 45 0b ca	 or	 r9w, r10w
  000e1	83 f8 0d	 cmp	 eax, 13
  000e4	7e 49		 jle	 SHORT $LN11@tr_flush_b
  000e6	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000e9	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000ed	66 44 89 8b 0c
	17 00 00	 mov	 WORD PTR [rbx+5900], r9w
  000f5	44 88 0c 01	 mov	 BYTE PTR [rcx+rax], r9b
  000f9	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000fc	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000ff	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00103	0f b6 83 0d 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5901]
  0010a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0010d	8b 8b 10 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5904]
  00113	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00116	8d 41 f3	 lea	 eax, DWORD PTR [rcx-13]
  00119	89 83 10 17 00
	00		 mov	 DWORD PTR [rbx+5904], eax
  0011f	b8 10 00 00 00	 mov	 eax, 16
  00124	2a c1		 sub	 al, cl
  00126	0f b6 c8	 movzx	 ecx, al
  00129	66 41 d3 e8	 shr	 r8w, cl
  0012d	eb 0d		 jmp	 SHORT $LN12@tr_flush_b
$LN11@tr_flush_b:
  0012f	83 c0 03	 add	 eax, 3
  00132	45 0f b7 c1	 movzx	 r8d, r9w
  00136	89 83 10 17 00
	00		 mov	 DWORD PTR [rbx+5904], eax
$LN12@tr_flush_b:

; 1060 :         compress_block(s, (const ct_data *)static_ltree,

  0013c	66 44 89 83 0c
	17 00 00	 mov	 WORD PTR [rbx+5900], r8w
  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:static_ltree
  0014b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:static_dtree

; 1061 :                        (const ct_data *)static_dtree);
; 1062 : #ifdef ZLIB_DEBUG
; 1063 :         s->compressed_len += 3 + s->static_len;
; 1064 : #endif
; 1065 :     } else {

  00152	e9 96 00 00 00	 jmp	 $LN26@tr_flush_b
$LN9@tr_flush_b:

; 1066 :         send_bits(s, (DYN_TREES<<1) + last, 3);

  00157	44 8d 46 04	 lea	 r8d, DWORD PTR [rsi+4]
  0015b	45 0f b7 c8	 movzx	 r9d, r8w
  0015f	66 41 d3 e1	 shl	 r9w, cl
  00163	66 45 0b ca	 or	 r9w, r10w
  00167	83 f8 0d	 cmp	 eax, 13
  0016a	7e 40		 jle	 SHORT $LN13@tr_flush_b
  0016c	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0016f	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00173	66 44 89 8b 0c
	17 00 00	 mov	 WORD PTR [rbx+5900], r9w
  0017b	44 88 0c 01	 mov	 BYTE PTR [rcx+rax], r9b
  0017f	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00182	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00185	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00189	0f b6 83 0d 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5901]
  00190	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00193	b9 10 00 00 00	 mov	 ecx, 16
  00198	8b 93 10 17 00
	00		 mov	 edx, DWORD PTR [rbx+5904]
  0019e	2a ca		 sub	 cl, dl
  001a0	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001a3	66 41 d3 e8	 shr	 r8w, cl
  001a7	8d 42 f3	 lea	 eax, DWORD PTR [rdx-13]
  001aa	eb 07		 jmp	 SHORT $LN27@tr_flush_b
$LN13@tr_flush_b:
  001ac	83 c0 03	 add	 eax, 3
  001af	45 0f b7 c1	 movzx	 r8d, r9w
$LN27@tr_flush_b:

; 1067 :         send_all_trees(s, s->l_desc.max_code + 1, s->d_desc.max_code + 1,

  001b3	89 83 10 17 00
	00		 mov	 DWORD PTR [rbx+5904], eax
  001b9	45 8d 4b 01	 lea	 r9d, DWORD PTR [r11+1]
  001bd	66 44 89 83 0c
	17 00 00	 mov	 WORD PTR [rbx+5900], r8w
  001c5	48 8b cb	 mov	 rcx, rbx
  001c8	44 8b 83 60 0b
	00 00		 mov	 r8d, DWORD PTR [rbx+2912]
  001cf	8b 93 48 0b 00
	00		 mov	 edx, DWORD PTR [rbx+2888]
  001d5	41 ff c0	 inc	 r8d
  001d8	ff c2		 inc	 edx
  001da	e8 00 00 00 00	 call	 send_all_trees

; 1068 :                        max_blindex + 1);
; 1069 :         compress_block(s, (const ct_data *)s->dyn_ltree,

  001df	4c 8d 83 b0 09
	00 00		 lea	 r8, QWORD PTR [rbx+2480]
  001e6	48 8d 93 bc 00
	00 00		 lea	 rdx, QWORD PTR [rbx+188]
$LN26@tr_flush_b:

; 1070 :                        (const ct_data *)s->dyn_dtree);
; 1071 : #ifdef ZLIB_DEBUG
; 1072 :         s->compressed_len += 3 + s->opt_len;
; 1073 : #endif
; 1074 :     }
; 1075 :     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
; 1076 :     /* The above check is made mod 2^32, for files larger than 512 MB
; 1077 :      * and uLong implemented on 32 bits.
; 1078 :      */
; 1079 :     init_block(s);

  001ed	48 8b cb	 mov	 rcx, rbx
  001f0	e8 00 00 00 00	 call	 compress_block
$LN10@tr_flush_b:
  001f5	48 8b cb	 mov	 rcx, rbx
  001f8	e8 00 00 00 00	 call	 init_block

; 1080 : 
; 1081 :     if (last) {

  001fd	85 f6		 test	 esi, esi
  001ff	74 05		 je	 SHORT $LN15@tr_flush_b

; 1082 :         bi_windup(s);

  00201	e8 00 00 00 00	 call	 bi_windup
$LN15@tr_flush_b:

; 1083 : #ifdef ZLIB_DEBUG
; 1084 :         s->compressed_len += 7;  /* align on byte boundary */
; 1085 : #endif
; 1086 :     }
; 1087 :     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len >> 3,
; 1088 :            s->compressed_len - 7*last));
; 1089 : }

  00206	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0020b	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00210	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00215	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00219	5f		 pop	 rdi
  0021a	c3		 ret	 0
_tr_flush_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT _tr_init
_TEXT	SEGMENT
s$ = 8
_tr_init PROC						; COMDAT

; 457  :     tr_static_init();
; 458  : 
; 459  :     s->l_desc.dyn_tree = s->dyn_ltree;

  00000	48 8d 81 bc 00
	00 00		 lea	 rax, QWORD PTR [rcx+188]
  00007	48 89 81 40 0b
	00 00		 mov	 QWORD PTR [rcx+2880], rax

; 460  :     s->l_desc.stat_desc = &static_l_desc;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:static_l_desc
  00015	48 89 81 50 0b
	00 00		 mov	 QWORD PTR [rcx+2896], rax

; 461  : 
; 462  :     s->d_desc.dyn_tree = s->dyn_dtree;

  0001c	48 8d 81 b0 09
	00 00		 lea	 rax, QWORD PTR [rcx+2480]
  00023	48 89 81 58 0b
	00 00		 mov	 QWORD PTR [rcx+2904], rax

; 463  :     s->d_desc.stat_desc = &static_d_desc;

  0002a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:static_d_desc
  00031	48 89 81 68 0b
	00 00		 mov	 QWORD PTR [rcx+2920], rax

; 464  : 
; 465  :     s->bl_desc.dyn_tree = s->bl_tree;

  00038	48 8d 81 a4 0a
	00 00		 lea	 rax, QWORD PTR [rcx+2724]
  0003f	48 89 81 70 0b
	00 00		 mov	 QWORD PTR [rcx+2928], rax

; 466  :     s->bl_desc.stat_desc = &static_bl_desc;

  00046	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:static_bl_desc
  0004d	48 89 81 80 0b
	00 00		 mov	 QWORD PTR [rcx+2944], rax

; 467  : 
; 468  :     s->bi_buf = 0;

  00054	33 c0		 xor	 eax, eax
  00056	66 89 81 0c 17
	00 00		 mov	 WORD PTR [rcx+5900], ax

; 469  :     s->bi_valid = 0;

  0005d	48 89 81 10 17
	00 00		 mov	 QWORD PTR [rcx+5904], rax

; 470  :     s->bi_used = 0;
; 471  : #ifdef ZLIB_DEBUG
; 472  :     s->compressed_len = 0L;
; 473  :     s->bits_sent = 0L;
; 474  : #endif
; 475  : 
; 476  :     /* Initialize the first block of the first file: */
; 477  :     init_block(s);

  00064	e9 00 00 00 00	 jmp	 init_block
_tr_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT _tr_align
_TEXT	SEGMENT
s$ = 8
_tr_align PROC						; COMDAT

; 888  : void ZLIB_INTERNAL _tr_align(deflate_state *s) {

  00000	4c 8b c1	 mov	 r8, rcx

; 889  :     send_bits(s, STATIC_TREES<<1, 3);

  00003	41 b9 02 00 00
	00		 mov	 r9d, 2
  00009	8b 89 10 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5904]
  0000f	41 8b c1	 mov	 eax, r9d
  00012	66 d3 e0	 shl	 ax, cl
  00015	66 41 0b 80 0c
	17 00 00	 or	 ax, WORD PTR [r8+5900]
  0001d	83 f9 0d	 cmp	 ecx, 13
  00020	7e 48		 jle	 SHORT $LN2@tr_align
  00022	41 8b 48 28	 mov	 ecx, DWORD PTR [r8+40]
  00026	0f b7 d0	 movzx	 edx, ax
  00029	66 41 89 80 0c
	17 00 00	 mov	 WORD PTR [r8+5900], ax
  00031	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]
  00035	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00038	41 ff 40 28	 inc	 DWORD PTR [r8+40]
  0003c	41 8b 50 28	 mov	 edx, DWORD PTR [r8+40]
  00040	49 8b 48 10	 mov	 rcx, QWORD PTR [r8+16]
  00044	41 0f b6 80 0d
	17 00 00	 movzx	 eax, BYTE PTR [r8+5901]
  0004c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004f	b9 10 00 00 00	 mov	 ecx, 16
  00054	41 8b 80 10 17
	00 00		 mov	 eax, DWORD PTR [r8+5904]
  0005b	2a c8		 sub	 cl, al
  0005d	41 ff 40 28	 inc	 DWORD PTR [r8+40]
  00061	66 41 d3 e9	 shr	 r9w, cl
  00065	8d 50 f3	 lea	 edx, DWORD PTR [rax-13]
  00068	eb 07		 jmp	 SHORT $LN7@tr_align
$LN2@tr_align:
  0006a	8d 51 03	 lea	 edx, DWORD PTR [rcx+3]
  0006d	44 0f b7 c8	 movzx	 r9d, ax
$LN7@tr_align:

; 890  :     send_code(s, END_BLOCK, static_ltree);

  00071	41 89 90 10 17
	00 00		 mov	 DWORD PTR [r8+5904], edx
  00078	83 fa 09	 cmp	 edx, 9
  0007b	7e 3e		 jle	 SHORT $LN4@tr_align
  0007d	41 8b 48 28	 mov	 ecx, DWORD PTR [r8+40]
  00081	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]
  00085	66 45 89 88 0c
	17 00 00	 mov	 WORD PTR [r8+5900], r9w
  0008d	44 88 0c 01	 mov	 BYTE PTR [rcx+rax], r9b
  00091	41 ff 40 28	 inc	 DWORD PTR [r8+40]
  00095	41 8b 50 28	 mov	 edx, DWORD PTR [r8+40]
  00099	49 8b 48 10	 mov	 rcx, QWORD PTR [r8+16]
  0009d	41 0f b6 80 0d
	17 00 00	 movzx	 eax, BYTE PTR [r8+5901]
  000a5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000a8	41 8b 90 10 17
	00 00		 mov	 edx, DWORD PTR [r8+5904]
  000af	41 ff 40 28	 inc	 DWORD PTR [r8+40]
  000b3	83 ea 09	 sub	 edx, 9
  000b6	45 33 c9	 xor	 r9d, r9d
  000b9	eb 03		 jmp	 SHORT $LN5@tr_align
$LN4@tr_align:
  000bb	83 c2 07	 add	 edx, 7
$LN5@tr_align:

; 891  : #ifdef ZLIB_DEBUG
; 892  :     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
; 893  : #endif
; 894  :     bi_flush(s);

  000be	66 45 89 88 0c
	17 00 00	 mov	 WORD PTR [r8+5900], r9w
  000c6	49 8b c8	 mov	 rcx, r8
  000c9	41 89 90 10 17
	00 00		 mov	 DWORD PTR [r8+5904], edx
  000d0	e9 00 00 00 00	 jmp	 bi_flush
_tr_align ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT bi_reverse
_TEXT	SEGMENT
code$ = 8
len$ = 16
bi_reverse PROC						; COMDAT

; 155  :     register unsigned res = 0;

  00000	33 c0		 xor	 eax, eax
$LL4@bi_reverse:

; 156  :     do {
; 157  :         res |= code & 1;

  00002	44 8b c1	 mov	 r8d, ecx

; 158  :         code >>= 1, res <<= 1;
; 159  :     } while (--len > 0);

  00005	ff ca		 dec	 edx
  00007	41 83 e0 01	 and	 r8d, 1
  0000b	d1 e9		 shr	 ecx, 1
  0000d	44 0b c0	 or	 r8d, eax
  00010	43 8d 04 00	 lea	 eax, DWORD PTR [r8+r8]
  00014	85 d2		 test	 edx, edx
  00016	7f ea		 jg	 SHORT $LL4@bi_reverse

; 160  :     return res >> 1;

  00018	d1 e8		 shr	 eax, 1

; 161  : }

  0001a	c3		 ret	 0
bi_reverse ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT bi_flush
_TEXT	SEGMENT
s$ = 8
bi_flush PROC						; COMDAT

; 167  :     if (s->bi_valid == 16) {

  00000	8b 81 10 17 00
	00		 mov	 eax, DWORD PTR [rcx+5904]
  00006	4c 8b c9	 mov	 r9, rcx
  00009	83 f8 10	 cmp	 eax, 16
  0000c	75 3e		 jne	 SHORT $LN2@bi_flush

; 168  :         put_short(s, s->bi_buf);

  0000e	0f b6 81 0c 17
	00 00		 movzx	 eax, BYTE PTR [rcx+5900]
  00015	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00019	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  0001d	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00021	ff 41 28	 inc	 DWORD PTR [rcx+40]
  00024	8b 51 28	 mov	 edx, DWORD PTR [rcx+40]
  00027	41 0f b6 81 0d
	17 00 00	 movzx	 eax, BYTE PTR [r9+5901]
  0002f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00033	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00036	41 ff 41 28	 inc	 DWORD PTR [r9+40]

; 169  :         s->bi_buf = 0;

  0003a	33 c0		 xor	 eax, eax

; 170  :         s->bi_valid = 0;

  0003c	41 89 81 10 17
	00 00		 mov	 DWORD PTR [r9+5904], eax

; 175  :     }
; 176  : }

  00043	66 41 89 81 0c
	17 00 00	 mov	 WORD PTR [r9+5900], ax
  0004b	c3		 ret	 0
$LN2@bi_flush:

; 171  :     } else if (s->bi_valid >= 8) {

  0004c	83 f8 08	 cmp	 eax, 8
  0004f	7c 2e		 jl	 SHORT $LN4@bi_flush

; 172  :         put_byte(s, (Byte)s->bi_buf);

  00051	8b 51 28	 mov	 edx, DWORD PTR [rcx+40]
  00054	41 0f b6 81 0c
	17 00 00	 movzx	 eax, BYTE PTR [r9+5900]
  0005c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00060	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00063	41 ff 41 28	 inc	 DWORD PTR [r9+40]

; 173  :         s->bi_buf >>= 8;

  00067	41 0f b6 81 0d
	17 00 00	 movzx	 eax, BYTE PTR [r9+5901]

; 174  :         s->bi_valid -= 8;

  0006f	41 83 81 10 17
	00 00 f8	 add	 DWORD PTR [r9+5904], -8

; 175  :     }
; 176  : }

  00077	66 41 89 81 0c
	17 00 00	 mov	 WORD PTR [r9+5900], ax
$LN4@bi_flush:
  0007f	c3		 ret	 0
bi_flush ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT bi_windup
_TEXT	SEGMENT
s$ = 8
bi_windup PROC						; COMDAT

; 182  :     if (s->bi_valid > 8) {

  00000	8b 81 10 17 00
	00		 mov	 eax, DWORD PTR [rcx+5904]
  00006	4c 8b c9	 mov	 r9, rcx
  00009	83 f8 08	 cmp	 eax, 8
  0000c	7e 1f		 jle	 SHORT $LN2@bi_windup

; 183  :         put_short(s, s->bi_buf);

  0000e	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00012	0f b6 81 0c 17
	00 00		 movzx	 eax, BYTE PTR [rcx+5900]
  00019	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  0001d	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00021	ff 41 28	 inc	 DWORD PTR [rcx+40]
  00024	0f b6 81 0d 17
	00 00		 movzx	 eax, BYTE PTR [rcx+5901]
  0002b	eb 0c		 jmp	 SHORT $LN6@bi_windup
$LN2@bi_windup:

; 184  :     } else if (s->bi_valid > 0) {

  0002d	85 c0		 test	 eax, eax
  0002f	7e 16		 jle	 SHORT $LN4@bi_windup

; 185  :         put_byte(s, (Byte)s->bi_buf);

  00031	41 0f b6 81 0c
	17 00 00	 movzx	 eax, BYTE PTR [r9+5900]
$LN6@bi_windup:

; 186  :     }
; 187  :     s->bi_used = ((s->bi_valid - 1) & 7) + 1;

  00039	8b 51 28	 mov	 edx, DWORD PTR [rcx+40]
  0003c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00040	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00043	41 ff 41 28	 inc	 DWORD PTR [r9+40]
$LN4@bi_windup:
  00047	41 8b 81 10 17
	00 00		 mov	 eax, DWORD PTR [r9+5904]
  0004e	ff c8		 dec	 eax
  00050	83 e0 07	 and	 eax, 7
  00053	ff c0		 inc	 eax
  00055	41 89 81 14 17
	00 00		 mov	 DWORD PTR [r9+5908], eax

; 188  :     s->bi_buf = 0;

  0005c	33 c0		 xor	 eax, eax
  0005e	66 41 89 81 0c
	17 00 00	 mov	 WORD PTR [r9+5900], ax

; 189  :     s->bi_valid = 0;

  00066	41 89 81 10 17
	00 00		 mov	 DWORD PTR [r9+5904], eax

; 190  : #ifdef ZLIB_DEBUG
; 191  :     s->bits_sent = (s->bits_sent + 7) & ~7;
; 192  : #endif
; 193  : }

  0006d	c3		 ret	 0
bi_windup ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT gen_codes
_TEXT	SEGMENT
next_code$ = 32
tree$ = 80
max_code$ = 88
bl_count$ = 96
gen_codes PROC						; COMDAT

; 203  : local void gen_codes(ct_data *tree, int max_code, ushf *bl_count) {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 204  :     ush next_code[MAX_BITS+1]; /* next code value for each bit length */
; 205  :     unsigned code = 0;         /* running code value */
; 206  :     int bits;                  /* bit index */
; 207  :     int n;                     /* code index */
; 208  : 
; 209  :     /* The distribution counts are first used to generate the code values
; 210  :      * without bit reversal.
; 211  :      */
; 212  :     for (bits = 1; bits <= MAX_BITS; bits++) {
; 213  :         code = (code + bl_count[bits - 1]) << 1;

  00004	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  00008	4c 8b d9	 mov	 r11, rcx
  0000b	45 0f b7 48 02	 movzx	 r9d, WORD PTR [r8+2]
  00010	03 c0		 add	 eax, eax
  00012	41 0f b7 48 06	 movzx	 ecx, WORD PTR [r8+6]
  00017	44 03 c8	 add	 r9d, eax

; 214  :         next_code[bits] = (ush)code;

  0001a	66 89 44 24 22	 mov	 WORD PTR next_code$[rsp+2], ax
  0001f	45 03 c9	 add	 r9d, r9d
  00022	41 0f b7 40 04	 movzx	 eax, WORD PTR [r8+4]
  00027	41 03 c1	 add	 eax, r9d
  0002a	66 44 89 4c 24
	24		 mov	 WORD PTR next_code$[rsp+4], r9w
  00030	03 c0		 add	 eax, eax

; 215  :     }
; 216  :     /* Check that the bit counts in bl_count are consistent. The last code
; 217  :      * must be all ones.
; 218  :      */
; 219  :     Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,
; 220  :             "inconsistent bit counts");
; 221  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 222  : 
; 223  :     for (n = 0;  n <= max_code; n++) {

  00032	4c 63 d2	 movsxd	 r10, edx
  00035	03 c8		 add	 ecx, eax
  00037	66 89 44 24 26	 mov	 WORD PTR next_code$[rsp+6], ax
  0003c	41 0f b7 40 08	 movzx	 eax, WORD PTR [r8+8]
  00041	03 c9		 add	 ecx, ecx
  00043	03 c1		 add	 eax, ecx
  00045	66 89 4c 24 28	 mov	 WORD PTR next_code$[rsp+8], cx
  0004a	41 0f b7 48 0a	 movzx	 ecx, WORD PTR [r8+10]
  0004f	03 c0		 add	 eax, eax
  00051	03 c8		 add	 ecx, eax
  00053	66 89 44 24 2a	 mov	 WORD PTR next_code$[rsp+10], ax
  00058	41 0f b7 40 0c	 movzx	 eax, WORD PTR [r8+12]
  0005d	03 c9		 add	 ecx, ecx
  0005f	03 c1		 add	 eax, ecx
  00061	66 89 4c 24 2c	 mov	 WORD PTR next_code$[rsp+12], cx
  00066	41 0f b7 48 0e	 movzx	 ecx, WORD PTR [r8+14]
  0006b	03 c0		 add	 eax, eax
  0006d	03 c8		 add	 ecx, eax
  0006f	66 89 44 24 2e	 mov	 WORD PTR next_code$[rsp+14], ax
  00074	41 0f b7 40 10	 movzx	 eax, WORD PTR [r8+16]
  00079	03 c9		 add	 ecx, ecx
  0007b	03 c1		 add	 eax, ecx
  0007d	66 89 4c 24 30	 mov	 WORD PTR next_code$[rsp+16], cx
  00082	41 0f b7 48 12	 movzx	 ecx, WORD PTR [r8+18]
  00087	03 c0		 add	 eax, eax
  00089	03 c8		 add	 ecx, eax
  0008b	66 89 44 24 32	 mov	 WORD PTR next_code$[rsp+18], ax
  00090	41 0f b7 40 14	 movzx	 eax, WORD PTR [r8+20]
  00095	03 c9		 add	 ecx, ecx
  00097	03 c1		 add	 eax, ecx
  00099	66 89 4c 24 34	 mov	 WORD PTR next_code$[rsp+20], cx
  0009e	41 0f b7 48 16	 movzx	 ecx, WORD PTR [r8+22]
  000a3	03 c0		 add	 eax, eax
  000a5	03 c8		 add	 ecx, eax
  000a7	66 89 44 24 36	 mov	 WORD PTR next_code$[rsp+22], ax
  000ac	41 0f b7 40 18	 movzx	 eax, WORD PTR [r8+24]
  000b1	03 c9		 add	 ecx, ecx
  000b3	03 c1		 add	 eax, ecx
  000b5	66 89 4c 24 38	 mov	 WORD PTR next_code$[rsp+24], cx
  000ba	03 c0		 add	 eax, eax
  000bc	66 89 44 24 3a	 mov	 WORD PTR next_code$[rsp+26], ax
  000c1	66 41 03 40 1a	 add	 ax, WORD PTR [r8+26]
  000c6	66 03 c0	 add	 ax, ax
  000c9	66 89 44 24 3c	 mov	 WORD PTR next_code$[rsp+28], ax
  000ce	66 41 03 40 1c	 add	 ax, WORD PTR [r8+28]
  000d3	66 03 c0	 add	 ax, ax
  000d6	66 89 44 24 3e	 mov	 WORD PTR next_code$[rsp+30], ax
  000db	85 d2		 test	 edx, edx
  000dd	78 37		 js	 SHORT $LN6@gen_codes
  000df	45 33 c9	 xor	 r9d, r9d
$LL7@gen_codes:

; 224  :         int len = tree[n].Len;

  000e2	43 0f b7 54 8b
	02		 movzx	 edx, WORD PTR [r11+r9*4+2]

; 225  :         if (len == 0) continue;

  000e8	85 d2		 test	 edx, edx
  000ea	74 22		 je	 SHORT $LN5@gen_codes

; 226  :         /* Now reverse the bits */
; 227  :         tree[n].Code = (ush)bi_reverse(next_code[len]++, len);

  000ec	48 8d 4c 24 20	 lea	 rcx, QWORD PTR next_code$[rsp]
  000f1	44 0f b7 04 51	 movzx	 r8d, WORD PTR [rcx+rdx*2]
  000f6	48 8d 0c 51	 lea	 rcx, QWORD PTR [rcx+rdx*2]
  000fa	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]
  000fe	66 89 01	 mov	 WORD PTR [rcx], ax
  00101	41 8b c8	 mov	 ecx, r8d
  00104	e8 00 00 00 00	 call	 bi_reverse
  00109	66 43 89 04 8b	 mov	 WORD PTR [r11+r9*4], ax
$LN5@gen_codes:

; 215  :     }
; 216  :     /* Check that the bit counts in bl_count are consistent. The last code
; 217  :      * must be all ones.
; 218  :      */
; 219  :     Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,
; 220  :             "inconsistent bit counts");
; 221  :     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
; 222  : 
; 223  :     for (n = 0;  n <= max_code; n++) {

  0010e	49 ff c1	 inc	 r9
  00111	4d 3b ca	 cmp	 r9, r10
  00114	7e cc		 jle	 SHORT $LL7@gen_codes
$LN6@gen_codes:

; 228  : 
; 229  :         Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
; 230  :             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1));
; 231  :     }
; 232  : }

  00116	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011a	c3		 ret	 0
gen_codes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT tr_static_init
_TEXT	SEGMENT
tr_static_init PROC					; COMDAT

; 296  : #if defined(GEN_TREES_H) || !defined(STDC)
; 297  :     static int static_init_done = 0;
; 298  :     int n;        /* iterates over tree elements */
; 299  :     int bits;     /* bit counter */
; 300  :     int length;   /* length value */
; 301  :     int code;     /* code value */
; 302  :     int dist;     /* distance index */
; 303  :     ush bl_count[MAX_BITS+1];
; 304  :     /* number of codes at each bit length for an optimal tree */
; 305  : 
; 306  :     if (static_init_done) return;
; 307  : 
; 308  :     /* For some embedded targets, global variables are not initialized: */
; 309  : #ifdef NO_INIT_GLOBAL_POINTERS
; 310  :     static_l_desc.static_tree = static_ltree;
; 311  :     static_l_desc.extra_bits = extra_lbits;
; 312  :     static_d_desc.static_tree = static_dtree;
; 313  :     static_d_desc.extra_bits = extra_dbits;
; 314  :     static_bl_desc.extra_bits = extra_blbits;
; 315  : #endif
; 316  : 
; 317  :     /* Initialize the mapping length (0..255) -> length code (0..28) */
; 318  :     length = 0;
; 319  :     for (code = 0; code < LENGTH_CODES-1; code++) {
; 320  :         base_length[code] = length;
; 321  :         for (n = 0; n < (1 << extra_lbits[code]); n++) {
; 322  :             _length_code[length++] = (uch)code;
; 323  :         }
; 324  :     }
; 325  :     Assert (length == 256, "tr_static_init: length != 256");
; 326  :     /* Note that the length 255 (match length 258) can be represented
; 327  :      * in two different ways: code 284 + 5 bits or code 285, so we
; 328  :      * overwrite length_code[255] to use the best encoding:
; 329  :      */
; 330  :     _length_code[length - 1] = (uch)code;
; 331  : 
; 332  :     /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
; 333  :     dist = 0;
; 334  :     for (code = 0 ; code < 16; code++) {
; 335  :         base_dist[code] = dist;
; 336  :         for (n = 0; n < (1 << extra_dbits[code]); n++) {
; 337  :             _dist_code[dist++] = (uch)code;
; 338  :         }
; 339  :     }
; 340  :     Assert (dist == 256, "tr_static_init: dist != 256");
; 341  :     dist >>= 7; /* from now on, all distances are divided by 128 */
; 342  :     for ( ; code < D_CODES; code++) {
; 343  :         base_dist[code] = dist << 7;
; 344  :         for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
; 345  :             _dist_code[256 + dist++] = (uch)code;
; 346  :         }
; 347  :     }
; 348  :     Assert (dist == 256, "tr_static_init: 256 + dist != 512");
; 349  : 
; 350  :     /* Construct the codes of the static literal tree */
; 351  :     for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
; 352  :     n = 0;
; 353  :     while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
; 354  :     while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
; 355  :     while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
; 356  :     while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
; 357  :     /* Codes 286 and 287 do not exist, but we must include them in the
; 358  :      * tree construction to get a canonical Huffman tree (longest code
; 359  :      * all ones)
; 360  :      */
; 361  :     gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
; 362  : 
; 363  :     /* The static distance tree is trivial: */
; 364  :     for (n = 0; n < D_CODES; n++) {
; 365  :         static_dtree[n].Len = 5;
; 366  :         static_dtree[n].Code = bi_reverse((unsigned)n, 5);
; 367  :     }
; 368  :     static_init_done = 1;
; 369  : 
; 370  : #  ifdef GEN_TREES_H
; 371  :     gen_trees_header();
; 372  : #  endif
; 373  : #endif /* defined(GEN_TREES_H) || !defined(STDC) */
; 374  : }

  00000	c2 00 00	 ret	 0
tr_static_init ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT init_block
_TEXT	SEGMENT
s$ = 8
init_block PROC						; COMDAT

; 440  : local void init_block(deflate_state *s) {

  00000	48 8d 81 bc 00
	00 00		 lea	 rax, QWORD PTR [rcx+188]
  00007	ba 1e 01 00 00	 mov	 edx, 286		; 0000011eH
  0000c	45 33 c0	 xor	 r8d, r8d
  0000f	90		 npad	 1
$LL4@init_block:

; 441  :     int n; /* iterates over tree elements */
; 442  : 
; 443  :     /* Initialize the trees. */
; 444  :     for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;

  00010	66 44 89 00	 mov	 WORD PTR [rax], r8w
  00014	48 8d 40 04	 lea	 rax, QWORD PTR [rax+4]
  00018	48 83 ea 01	 sub	 rdx, 1
  0001c	75 f2		 jne	 SHORT $LL4@init_block

; 445  :     for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;

  0001e	66 44 89 81 b0
	09 00 00	 mov	 WORD PTR [rcx+2480], r8w
  00026	66 44 89 81 b4
	09 00 00	 mov	 WORD PTR [rcx+2484], r8w
  0002e	66 44 89 81 b8
	09 00 00	 mov	 WORD PTR [rcx+2488], r8w
  00036	66 44 89 81 bc
	09 00 00	 mov	 WORD PTR [rcx+2492], r8w
  0003e	66 44 89 81 c0
	09 00 00	 mov	 WORD PTR [rcx+2496], r8w
  00046	66 44 89 81 c4
	09 00 00	 mov	 WORD PTR [rcx+2500], r8w
  0004e	66 44 89 81 c8
	09 00 00	 mov	 WORD PTR [rcx+2504], r8w
  00056	66 44 89 81 cc
	09 00 00	 mov	 WORD PTR [rcx+2508], r8w
  0005e	66 44 89 81 d0
	09 00 00	 mov	 WORD PTR [rcx+2512], r8w
  00066	66 44 89 81 d4
	09 00 00	 mov	 WORD PTR [rcx+2516], r8w
  0006e	66 44 89 81 d8
	09 00 00	 mov	 WORD PTR [rcx+2520], r8w
  00076	66 44 89 81 dc
	09 00 00	 mov	 WORD PTR [rcx+2524], r8w
  0007e	66 44 89 81 e0
	09 00 00	 mov	 WORD PTR [rcx+2528], r8w
  00086	66 44 89 81 e4
	09 00 00	 mov	 WORD PTR [rcx+2532], r8w
  0008e	66 44 89 81 e8
	09 00 00	 mov	 WORD PTR [rcx+2536], r8w
  00096	66 44 89 81 ec
	09 00 00	 mov	 WORD PTR [rcx+2540], r8w
  0009e	66 44 89 81 f0
	09 00 00	 mov	 WORD PTR [rcx+2544], r8w
  000a6	66 44 89 81 f4
	09 00 00	 mov	 WORD PTR [rcx+2548], r8w
  000ae	66 44 89 81 f8
	09 00 00	 mov	 WORD PTR [rcx+2552], r8w
  000b6	66 44 89 81 fc
	09 00 00	 mov	 WORD PTR [rcx+2556], r8w
  000be	66 44 89 81 00
	0a 00 00	 mov	 WORD PTR [rcx+2560], r8w
  000c6	66 44 89 81 04
	0a 00 00	 mov	 WORD PTR [rcx+2564], r8w
  000ce	66 44 89 81 08
	0a 00 00	 mov	 WORD PTR [rcx+2568], r8w
  000d6	66 44 89 81 0c
	0a 00 00	 mov	 WORD PTR [rcx+2572], r8w
  000de	66 44 89 81 10
	0a 00 00	 mov	 WORD PTR [rcx+2576], r8w
  000e6	66 44 89 81 14
	0a 00 00	 mov	 WORD PTR [rcx+2580], r8w
  000ee	66 44 89 81 18
	0a 00 00	 mov	 WORD PTR [rcx+2584], r8w
  000f6	66 44 89 81 1c
	0a 00 00	 mov	 WORD PTR [rcx+2588], r8w
  000fe	66 44 89 81 20
	0a 00 00	 mov	 WORD PTR [rcx+2592], r8w
  00106	66 44 89 81 24
	0a 00 00	 mov	 WORD PTR [rcx+2596], r8w

; 446  :     for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

  0010e	66 44 89 81 a4
	0a 00 00	 mov	 WORD PTR [rcx+2724], r8w
  00116	66 44 89 81 a8
	0a 00 00	 mov	 WORD PTR [rcx+2728], r8w
  0011e	66 44 89 81 ac
	0a 00 00	 mov	 WORD PTR [rcx+2732], r8w
  00126	66 44 89 81 b0
	0a 00 00	 mov	 WORD PTR [rcx+2736], r8w
  0012e	66 44 89 81 b4
	0a 00 00	 mov	 WORD PTR [rcx+2740], r8w
  00136	66 44 89 81 b8
	0a 00 00	 mov	 WORD PTR [rcx+2744], r8w
  0013e	66 44 89 81 bc
	0a 00 00	 mov	 WORD PTR [rcx+2748], r8w
  00146	66 44 89 81 c0
	0a 00 00	 mov	 WORD PTR [rcx+2752], r8w
  0014e	66 44 89 81 c4
	0a 00 00	 mov	 WORD PTR [rcx+2756], r8w
  00156	66 44 89 81 c8
	0a 00 00	 mov	 WORD PTR [rcx+2760], r8w
  0015e	66 44 89 81 cc
	0a 00 00	 mov	 WORD PTR [rcx+2764], r8w
  00166	66 44 89 81 d0
	0a 00 00	 mov	 WORD PTR [rcx+2768], r8w
  0016e	66 44 89 81 d4
	0a 00 00	 mov	 WORD PTR [rcx+2772], r8w
  00176	66 44 89 81 d8
	0a 00 00	 mov	 WORD PTR [rcx+2776], r8w
  0017e	66 44 89 81 dc
	0a 00 00	 mov	 WORD PTR [rcx+2780], r8w
  00186	66 44 89 81 e0
	0a 00 00	 mov	 WORD PTR [rcx+2784], r8w
  0018e	66 44 89 81 e4
	0a 00 00	 mov	 WORD PTR [rcx+2788], r8w
  00196	66 44 89 81 e8
	0a 00 00	 mov	 WORD PTR [rcx+2792], r8w
  0019e	66 44 89 81 ec
	0a 00 00	 mov	 WORD PTR [rcx+2796], r8w

; 447  : 
; 448  :     s->dyn_ltree[END_BLOCK].Freq = 1;

  001a6	66 c7 81 bc 04
	00 00 01 00	 mov	 WORD PTR [rcx+1212], 1

; 449  :     s->opt_len = s->static_len = 0L;

  001af	4c 89 81 fc 16
	00 00		 mov	 QWORD PTR [rcx+5884], r8

; 450  :     s->sym_next = s->matches = 0;

  001b6	44 89 81 04 17
	00 00		 mov	 DWORD PTR [rcx+5892], r8d
  001bd	44 89 81 f4 16
	00 00		 mov	 DWORD PTR [rcx+5876], r8d

; 451  : }

  001c4	c3		 ret	 0
init_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT pqdownheap
_TEXT	SEGMENT
s$ = 16
tree$ = 24
k$ = 32
pqdownheap PROC						; COMDAT

; 509  : local void pqdownheap(deflate_state *s, ct_data *tree, int k) {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi

; 510  :     int v = s->heap[k];
; 511  :     int j = k << 1;  /* left son of k */
; 512  :     while (j <= s->heap_len) {

  00006	8b 81 9c 14 00
	00		 mov	 eax, DWORD PTR [rcx+5276]
  0000c	4d 63 d8	 movsxd	 r11, r8d
  0000f	4a 63 bc 99 a8
	0b 00 00	 movsxd	 rdi, DWORD PTR [rcx+r11*4+2984]
  00017	47 8d 0c 1b	 lea	 r9d, DWORD PTR [r11+r11]
  0001b	44 3b c8	 cmp	 r9d, eax
  0001e	0f 8f ae 00 00
	00		 jg	 $LN17@pqdownheap
  00024	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
$LN26@pqdownheap:

; 513  :         /* Set j to the smallest of the two sons: */
; 514  :         if (j < s->heap_len &&

  00029	7d 37		 jge	 SHORT $LN4@pqdownheap
  0002b	49 63 c1	 movsxd	 rax, r9d
  0002e	4c 63 94 81 a8
	0b 00 00	 movsxd	 r10, DWORD PTR [rcx+rax*4+2984]
  00036	4c 63 84 81 ac
	0b 00 00	 movsxd	 r8, DWORD PTR [rcx+rax*4+2988]
  0003e	42 0f b7 04 82	 movzx	 eax, WORD PTR [rdx+r8*4]
  00043	66 42 3b 04 92	 cmp	 ax, WORD PTR [rdx+r10*4]
  00048	72 15		 jb	 SHORT $LN5@pqdownheap
  0004a	75 16		 jne	 SHORT $LN4@pqdownheap
  0004c	41 0f b6 84 0a
	a4 14 00 00	 movzx	 eax, BYTE PTR [r10+rcx+5284]
  00055	41 38 84 08 a4
	14 00 00	 cmp	 BYTE PTR [r8+rcx+5284], al
  0005d	77 03		 ja	 SHORT $LN4@pqdownheap
$LN5@pqdownheap:

; 515  :             smaller(tree, s->heap[j + 1], s->heap[j], s->depth)) {
; 516  :             j++;

  0005f	41 ff c1	 inc	 r9d
$LN4@pqdownheap:

; 517  :         }
; 518  :         /* Exit if v is smaller than both sons */
; 519  :         if (smaller(tree, v, s->heap[j], s->depth)) break;

  00062	49 63 c1	 movsxd	 rax, r9d
  00065	4c 63 94 81 a8
	0b 00 00	 movsxd	 r10, DWORD PTR [rcx+rax*4+2984]
  0006d	0f b7 04 ba	 movzx	 eax, WORD PTR [rdx+rdi*4]
  00071	66 42 3b 04 92	 cmp	 ax, WORD PTR [rdx+r10*4]
  00076	72 44		 jb	 SHORT $LN15@pqdownheap
  00078	75 12		 jne	 SHORT $LN6@pqdownheap
  0007a	41 0f b6 84 0a
	a4 14 00 00	 movzx	 eax, BYTE PTR [r10+rcx+5284]
  00083	38 84 0f a4 14
	00 00		 cmp	 BYTE PTR [rdi+rcx+5284], al
  0008a	76 30		 jbe	 SHORT $LN15@pqdownheap
$LN6@pqdownheap:

; 520  : 
; 521  :         /* Exchange v with the smallest son */
; 522  :         s->heap[k] = s->heap[j];  k = j;

  0008c	49 63 c3	 movsxd	 rax, r11d
  0008f	4d 63 d9	 movsxd	 r11, r9d

; 523  : 
; 524  :         /* And continue down the tree, setting j to the left son of k */
; 525  :         j <<= 1;

  00092	45 03 c9	 add	 r9d, r9d
  00095	44 89 94 81 a8
	0b 00 00	 mov	 DWORD PTR [rcx+rax*4+2984], r10d
  0009d	8b 81 9c 14 00
	00		 mov	 eax, DWORD PTR [rcx+5276]
  000a3	44 3b c8	 cmp	 r9d, eax
  000a6	7e 81		 jle	 SHORT $LN26@pqdownheap

; 526  :     }
; 527  :     s->heap[k] = v;

  000a8	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  000ad	42 89 bc 99 a8
	0b 00 00	 mov	 DWORD PTR [rcx+r11*4+2984], edi

; 528  : }

  000b5	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
$LN15@pqdownheap:
  000bc	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]

; 526  :     }
; 527  :     s->heap[k] = v;

  000c1	49 63 c3	 movsxd	 rax, r11d
  000c4	89 bc 81 a8 0b
	00 00		 mov	 DWORD PTR [rcx+rax*4+2984], edi

; 528  : }

  000cb	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  000d0	5f		 pop	 rdi
  000d1	c3		 ret	 0
$LN17@pqdownheap:
  000d2	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
  000d7	42 89 bc 99 a8
	0b 00 00	 mov	 DWORD PTR [rcx+r11*4+2984], edi
  000df	5f		 pop	 rdi
  000e0	c3		 ret	 0
pqdownheap ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT gen_bitlen
_TEXT	SEGMENT
s$ = 64
h$1$ = 64
tv847 = 64
desc$ = 72
tv1252 = 72
gen_bitlen PROC						; COMDAT

; 540  : local void gen_bitlen(deflate_state *s, tree_desc *desc) {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 57		 push	 r15
  00009	48 83 ec 10	 sub	 rsp, 16

; 541  :     ct_data *tree        = desc->dyn_tree;
; 542  :     int max_code         = desc->max_code;
; 543  :     const ct_data *stree = desc->stat_desc->static_tree;

  0000d	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]

; 544  :     const intf *extra    = desc->stat_desc->extra_bits;
; 545  :     int base             = desc->stat_desc->extra_base;
; 546  :     int max_length       = desc->stat_desc->max_length;
; 547  :     int h;              /* heap index */
; 548  :     int n, m;           /* iterate over the tree elements */
; 549  :     int bits;           /* bit length */
; 550  :     int xbits;          /* extra bits */
; 551  :     ush f;              /* frequency */
; 552  :     int overflow = 0;   /* number of elements with bit length too large */

  00011	45 33 c9	 xor	 r9d, r9d
  00014	48 8b 32	 mov	 rsi, QWORD PTR [rdx]

; 553  : 
; 554  :     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
; 555  : 
; 556  :     /* In a first pass, compute the optimal bit lengths (which may
; 557  :      * overflow in the case of the bit length tree).
; 558  :      */
; 559  :     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
; 560  : 
; 561  :     for (h = s->heap_max + 1; h < HEAP_SIZE; h++) {

  00017	41 bb 3d 02 00
	00		 mov	 r11d, 573		; 0000023dH
  0001d	8b 7a 08	 mov	 edi, DWORD PTR [rdx+8]
  00020	45 8b d1	 mov	 r10d, r9d
  00023	4c 8b 38	 mov	 r15, QWORD PTR [rax]
  00026	4c 8b 68 08	 mov	 r13, QWORD PTR [rax+8]
  0002a	44 8b 60 10	 mov	 r12d, DWORD PTR [rax+16]
  0002e	4c 63 40 18	 movsxd	 r8, DWORD PTR [rax+24]
  00032	4c 89 89 88 0b
	00 00		 mov	 QWORD PTR [rcx+2952], r9
  00039	4c 89 89 90 0b
	00 00		 mov	 QWORD PTR [rcx+2960], r9
  00040	4c 89 89 98 0b
	00 00		 mov	 QWORD PTR [rcx+2968], r9
  00047	4c 89 89 a0 0b
	00 00		 mov	 QWORD PTR [rcx+2976], r9
  0004e	48 63 81 a0 14
	00 00		 movsxd	 rax, DWORD PTR [rcx+5280]
  00055	48 63 94 81 a8
	0b 00 00	 movsxd	 rdx, DWORD PTR [rcx+rax*4+2984]
  0005d	66 44 89 4c 96
	02		 mov	 WORD PTR [rsi+rdx*4+2], r9w
  00063	8b 91 a0 14 00
	00		 mov	 edx, DWORD PTR [rcx+5280]
  00069	ff c2		 inc	 edx
  0006b	48 63 c2	 movsxd	 rax, edx
  0006e	49 3b c3	 cmp	 rax, r11
  00071	0f 8d 90 01 00
	00		 jge	 $LN14@gen_bitlen
  00077	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0007c	4c 2b d8	 sub	 r11, rax
  0007f	48 89 6c 24 08	 mov	 QWORD PTR [rsp+8], rbp
  00084	41 03 d3	 add	 edx, r11d
  00087	4c 89 34 24	 mov	 QWORD PTR [rsp], r14
  0008b	4c 8d b1 a8 0b
	00 00		 lea	 r14, QWORD PTR [rcx+2984]
  00092	4d 8d 34 86	 lea	 r14, QWORD PTR [r14+rax*4]
  00096	89 54 24 40	 mov	 DWORD PTR h$1$[rsp], edx
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL7@gen_bitlen:

; 562  :         n = s->heap[h];

  000a0	4d 63 0e	 movsxd	 r9, DWORD PTR [r14]

; 563  :         bits = tree[tree[n].Dad].Len + 1;
; 564  :         if (bits > max_length) bits = max_length, overflow++;
; 565  :         tree[n].Len = (ush)bits;

  000a3	41 8b d8	 mov	 ebx, r8d
  000a6	42 0f b7 44 8e
	02		 movzx	 eax, WORD PTR [rsi+r9*4+2]
  000ac	4a 8d 2c 8d 00
	00 00 00	 lea	 rbp, QWORD PTR [r9*4]
  000b4	0f b7 54 86 02	 movzx	 edx, WORD PTR [rsi+rax*4+2]
  000b9	41 8d 42 01	 lea	 eax, DWORD PTR [r10+1]
  000bd	ff c2		 inc	 edx
  000bf	41 3b d0	 cmp	 edx, r8d
  000c2	0f 4e da	 cmovle	 ebx, edx
  000c5	41 0f 4e c2	 cmovle	 eax, r10d
  000c9	66 89 5c 2e 02	 mov	 WORD PTR [rsi+rbp+2], bx
  000ce	44 8b d0	 mov	 r10d, eax

; 566  :         /* We overwrite tree[n].Dad which is no longer needed */
; 567  : 
; 568  :         if (n > max_code) continue; /* not a leaf node */

  000d1	44 3b cf	 cmp	 r9d, edi
  000d4	7f 46		 jg	 SHORT $LN5@gen_bitlen

; 569  : 
; 570  :         s->bl_count[bits]++;

  000d6	48 63 c3	 movsxd	 rax, ebx

; 571  :         xbits = 0;

  000d9	33 d2		 xor	 edx, edx
  000db	66 ff 84 41 88
	0b 00 00	 inc	 WORD PTR [rcx+rax*2+2952]

; 572  :         if (n >= base) xbits = extra[n - base];

  000e3	45 3b cc	 cmp	 r9d, r12d
  000e6	7c 0b		 jl	 SHORT $LN20@gen_bitlen
  000e8	45 2b cc	 sub	 r9d, r12d
  000eb	49 63 c1	 movsxd	 rax, r9d
  000ee	41 8b 54 85 00	 mov	 edx, DWORD PTR [r13+rax*4]
$LN20@gen_bitlen:

; 573  :         f = tree[n].Freq;
; 574  :         s->opt_len += (ulg)f * (unsigned)(bits + xbits);

  000f3	44 0f b7 0c 2e	 movzx	 r9d, WORD PTR [rsi+rbp]
  000f8	8d 04 13	 lea	 eax, DWORD PTR [rbx+rdx]
  000fb	41 0f af c1	 imul	 eax, r9d
  000ff	01 81 fc 16 00
	00		 add	 DWORD PTR [rcx+5884], eax

; 575  :         if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);

  00105	4d 85 ff	 test	 r15, r15
  00108	74 12		 je	 SHORT $LN5@gen_bitlen
  0010a	41 0f b7 44 2f
	02		 movzx	 eax, WORD PTR [r15+rbp+2]
  00110	03 c2		 add	 eax, edx
  00112	41 0f af c1	 imul	 eax, r9d
  00116	01 81 00 17 00
	00		 add	 DWORD PTR [rcx+5888], eax
$LN5@gen_bitlen:

; 553  : 
; 554  :     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
; 555  : 
; 556  :     /* In a first pass, compute the optimal bit lengths (which may
; 557  :      * overflow in the case of the bit length tree).
; 558  :      */
; 559  :     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
; 560  : 
; 561  :     for (h = s->heap_max + 1; h < HEAP_SIZE; h++) {

  0011c	49 83 c6 04	 add	 r14, 4
  00120	49 83 eb 01	 sub	 r11, 1
  00124	0f 85 76 ff ff
	ff		 jne	 $LL7@gen_bitlen
  0012a	4c 8b 34 24	 mov	 r14, QWORD PTR [rsp]
  0012e	48 8b 6c 24 08	 mov	 rbp, QWORD PTR [rsp+8]

; 576  :     }
; 577  :     if (overflow == 0) return;

  00133	45 85 d2	 test	 r10d, r10d
  00136	0f 84 c6 00 00
	00		 je	 $LN84@gen_bitlen
  0013c	4e 8d 0c 41	 lea	 r9, QWORD PTR [rcx+r8*2]
  00140	bb ff ff 00 00	 mov	 ebx, 65535		; 0000ffffH
  00145	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL10@gen_bitlen:

; 578  : 
; 579  :     Tracev((stderr,"\nbit length overflow\n"));
; 580  :     /* This happens for example on obj2 and pic of the Calgary corpus */
; 581  : 
; 582  :     /* Find the first bit length which could increase: */
; 583  :     do {
; 584  :         bits = max_length - 1;
; 585  :         while (s->bl_count[bits] == 0) bits--;

  00150	66 42 83 bc 41
	86 0b 00 00 00	 cmp	 WORD PTR [rcx+r8*2+2950], 0
  0015a	41 8d 50 ff	 lea	 edx, DWORD PTR [r8-1]
  0015e	75 10		 jne	 SHORT $LN12@gen_bitlen
$LL11@gen_bitlen:
  00160	48 63 c2	 movsxd	 rax, edx
  00163	ff ca		 dec	 edx
  00165	66 83 bc 41 86
	0b 00 00 00	 cmp	 WORD PTR [rcx+rax*2+2950], 0
  0016e	74 f0		 je	 SHORT $LL11@gen_bitlen
$LN12@gen_bitlen:

; 586  :         s->bl_count[bits]--;        /* move one leaf down the tree */

  00170	48 63 c2	 movsxd	 rax, edx

; 587  :         s->bl_count[bits + 1] += 2; /* move one overflow item as its brother */
; 588  :         s->bl_count[max_length]--;
; 589  :         /* The brother of the overflow item also moves one step up,
; 590  :          * but this does not affect bl_count[max_length]
; 591  :          */
; 592  :         overflow -= 2;

  00173	41 83 ea 02	 sub	 r10d, 2
  00177	66 01 9c 41 88
	0b 00 00	 add	 WORD PTR [rcx+rax*2+2952], bx
  0017f	66 83 84 41 8a
	0b 00 00 02	 add	 WORD PTR [rcx+rax*2+2954], 2
  00188	66 41 01 99 88
	0b 00 00	 add	 WORD PTR [r9+2952], bx

; 593  :     } while (overflow > 0);

  00190	45 85 d2	 test	 r10d, r10d
  00193	7f bb		 jg	 SHORT $LL10@gen_bitlen

; 594  : 
; 595  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 596  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 597  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 598  :      * from 'ar' written by Haruhiko Okumura.)
; 599  :      */
; 600  :     for (bits = max_length; bits != 0; bits--) {

  00195	45 85 c0	 test	 r8d, r8d
  00198	74 68		 je	 SHORT $LN84@gen_bitlen
  0019a	48 63 5c 24 40	 movsxd	 rbx, DWORD PTR h$1$[rsp]
  0019f	90		 npad	 1
$LL15@gen_bitlen:

; 601  :         n = s->bl_count[bits];

  001a0	49 63 c0	 movsxd	 rax, r8d
  001a3	44 0f b7 8c 41
	88 0b 00 00	 movzx	 r9d, WORD PTR [rcx+rax*2+2952]

; 602  :         while (n != 0) {

  001ac	45 85 c9	 test	 r9d, r9d
  001af	74 4b		 je	 SHORT $LN13@gen_bitlen

; 601  :         n = s->bl_count[bits];

  001b1	4c 8d 99 a8 0b
	00 00		 lea	 r11, QWORD PTR [rcx+2984]
  001b8	4d 8d 1c 9b	 lea	 r11, QWORD PTR [r11+rbx*4]
  001bc	0f 1f 40 00	 npad	 4
$LL16@gen_bitlen:

; 603  :             m = s->heap[--h];

  001c0	49 63 43 fc	 movsxd	 rax, DWORD PTR [r11-4]
  001c4	4d 8d 5b fc	 lea	 r11, QWORD PTR [r11-4]
  001c8	48 ff cb	 dec	 rbx

; 604  :             if (m > max_code) continue;

  001cb	3b c7		 cmp	 eax, edi
  001cd	7f 28		 jg	 SHORT $LN36@gen_bitlen

; 605  :             if ((unsigned) tree[m].Len != (unsigned) bits) {

  001cf	4c 8d 14 86	 lea	 r10, QWORD PTR [rsi+rax*4]
  001d3	0f b7 44 86 02	 movzx	 eax, WORD PTR [rsi+rax*4+2]
  001d8	41 3b c0	 cmp	 eax, r8d
  001db	74 17		 je	 SHORT $LN24@gen_bitlen

; 606  :                 Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
; 607  :                 s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;

  001dd	41 8b d0	 mov	 edx, r8d
  001e0	2b d0		 sub	 edx, eax
  001e2	41 0f b7 02	 movzx	 eax, WORD PTR [r10]
  001e6	0f af d0	 imul	 edx, eax
  001e9	01 91 fc 16 00
	00		 add	 DWORD PTR [rcx+5884], edx

; 608  :                 tree[m].Len = (ush)bits;

  001ef	66 45 89 42 02	 mov	 WORD PTR [r10+2], r8w
$LN24@gen_bitlen:

; 609  :             }
; 610  :             n--;

  001f4	41 ff c9	 dec	 r9d
$LN36@gen_bitlen:

; 602  :         while (n != 0) {

  001f7	45 85 c9	 test	 r9d, r9d
  001fa	75 c4		 jne	 SHORT $LL16@gen_bitlen
$LN13@gen_bitlen:

; 594  : 
; 595  :     /* Now recompute all bit lengths, scanning in increasing frequency.
; 596  :      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
; 597  :      * lengths instead of fixing only the wrong ones. This idea is taken
; 598  :      * from 'ar' written by Haruhiko Okumura.)
; 599  :      */
; 600  :     for (bits = max_length; bits != 0; bits--) {

  001fc	41 83 e8 01	 sub	 r8d, 1
  00200	75 9e		 jne	 SHORT $LL15@gen_bitlen
$LN84@gen_bitlen:
  00202	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
$LN14@gen_bitlen:

; 611  :         }
; 612  :     }
; 613  : }

  00207	48 83 c4 10	 add	 rsp, 16
  0020b	41 5f		 pop	 r15
  0020d	41 5d		 pop	 r13
  0020f	41 5c		 pop	 r12
  00211	5f		 pop	 rdi
  00212	5e		 pop	 rsi
  00213	c3		 ret	 0
gen_bitlen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT build_tree
_TEXT	SEGMENT
s$ = 64
desc$ = 72
build_tree PROC						; COMDAT

; 627  : local void build_tree(deflate_state *s, tree_desc *desc) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 56		 push	 r14
  00018	41 57		 push	 r15
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 628  :     ct_data *tree         = desc->dyn_tree;
; 629  :     const ct_data *stree  = desc->stat_desc->static_tree;

  0001e	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]

; 630  :     int elems             = desc->stat_desc->elems;
; 631  :     int n, m;          /* iterate over heap elements */
; 632  :     int max_code = -1; /* largest code with non zero frequency */
; 633  :     int node;          /* new node being created */
; 634  : 
; 635  :     /* Construct the initial heap, with least frequent element in
; 636  :      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n + 1].
; 637  :      * heap[0] is not used.
; 638  :      */
; 639  :     s->heap_len = 0, s->heap_max = HEAP_SIZE;

  00022	45 33 ff	 xor	 r15d, r15d
  00025	48 8b 32	 mov	 rsi, QWORD PTR [rdx]
  00028	4c 8b f2	 mov	 r14, rdx
  0002b	bf ff ff ff ff	 mov	 edi, -1
  00030	45 8b cf	 mov	 r9d, r15d
  00033	48 63 68 14	 movsxd	 rbp, DWORD PTR [rax+20]
  00037	48 8b 18	 mov	 rbx, QWORD PTR [rax]
  0003a	44 89 b9 9c 14
	00 00		 mov	 DWORD PTR [rcx+5276], r15d
  00041	c7 81 a0 14 00
	00 3d 02 00 00	 mov	 DWORD PTR [rcx+5280], 573 ; 0000023dH

; 640  : 
; 641  :     for (n = 0; n < elems; n++) {

  0004b	85 ed		 test	 ebp, ebp
  0004d	7e 40		 jle	 SHORT $LN22@build_tree
  0004f	45 8b c7	 mov	 r8d, r15d
$LL4@build_tree:

; 642  :         if (tree[n].Freq != 0) {

  00052	66 46 39 3c 86	 cmp	 WORD PTR [rsi+r8*4], r15w
  00057	74 25		 je	 SHORT $LN13@build_tree

; 643  :             s->heap[++(s->heap_len)] = max_code = n;

  00059	48 63 91 9c 14
	00 00		 movsxd	 rdx, DWORD PTR [rcx+5276]
  00060	41 8b f9	 mov	 edi, r9d
  00063	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  00066	89 81 9c 14 00
	00		 mov	 DWORD PTR [rcx+5276], eax
  0006c	44 89 8c 91 ac
	0b 00 00	 mov	 DWORD PTR [rcx+rdx*4+2988], r9d

; 644  :             s->depth[n] = 0;

  00074	46 88 bc 01 a4
	14 00 00	 mov	 BYTE PTR [rcx+r8+5284], r15b

; 645  :         } else {

  0007c	eb 06		 jmp	 SHORT $LN2@build_tree
$LN13@build_tree:

; 646  :             tree[n].Len = 0;

  0007e	66 46 89 7c 86
	02		 mov	 WORD PTR [rsi+r8*4+2], r15w
$LN2@build_tree:

; 640  : 
; 641  :     for (n = 0; n < elems; n++) {

  00084	41 ff c1	 inc	 r9d
  00087	49 ff c0	 inc	 r8
  0008a	4c 3b c5	 cmp	 r8, rbp
  0008d	7c c3		 jl	 SHORT $LL4@build_tree
$LN22@build_tree:

; 647  :         }
; 648  :     }
; 649  : 
; 650  :     /* The pkzip format requires that at least one distance code exists,
; 651  :      * and that at least one bit should be sent even if there is only one
; 652  :      * possible code. So to avoid special checks later on we force at least
; 653  :      * two codes of non zero frequency.
; 654  :      */
; 655  :     while (s->heap_len < 2) {

  0008f	44 8b 89 9c 14
	00 00		 mov	 r9d, DWORD PTR [rcx+5276]
  00096	41 bc 01 00 00
	00		 mov	 r12d, 1
  0009c	41 83 f9 02	 cmp	 r9d, 2
  000a0	7d 79		 jge	 SHORT $LN6@build_tree
  000a2	4c 63 df	 movsxd	 r11, edi
  000a5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL5@build_tree:

; 656  :         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);

  000b0	83 ff 02	 cmp	 edi, 2
  000b3	4d 8d 43 01	 lea	 r8, QWORD PTR [r11+1]
  000b7	49 8b c0	 mov	 rax, r8
  000ba	8d 57 01	 lea	 edx, DWORD PTR [rdi+1]
  000bd	49 0f 4d c3	 cmovge	 rax, r11
  000c1	4d 0f 4d c7	 cmovge	 r8, r15
  000c5	4c 8b d8	 mov	 r11, rax
  000c8	44 8b d2	 mov	 r10d, edx
  000cb	41 0f 4d d7	 cmovge	 edx, r15d
  000cf	41 8d 41 01	 lea	 eax, DWORD PTR [r9+1]
  000d3	89 81 9c 14 00
	00		 mov	 DWORD PTR [rcx+5276], eax
  000d9	44 0f 4d d7	 cmovge	 r10d, edi
  000dd	49 63 c1	 movsxd	 rax, r9d
  000e0	89 94 81 ac 0b
	00 00		 mov	 DWORD PTR [rcx+rax*4+2988], edx

; 657  :         tree[node].Freq = 1;

  000e7	66 46 89 24 86	 mov	 WORD PTR [rsi+r8*4], r12w

; 658  :         s->depth[node] = 0;

  000ec	45 88 bc 08 a4
	14 00 00	 mov	 BYTE PTR [r8+rcx+5284], r15b

; 659  :         s->opt_len--; if (stree) s->static_len -= stree[node].Len;

  000f4	ff 89 fc 16 00
	00		 dec	 DWORD PTR [rcx+5884]
  000fa	48 85 db	 test	 rbx, rbx
  000fd	74 0c		 je	 SHORT $LN15@build_tree
  000ff	42 0f b7 44 83
	02		 movzx	 eax, WORD PTR [rbx+r8*4+2]
  00105	29 81 00 17 00
	00		 sub	 DWORD PTR [rcx+5888], eax
$LN15@build_tree:

; 647  :         }
; 648  :     }
; 649  : 
; 650  :     /* The pkzip format requires that at least one distance code exists,
; 651  :      * and that at least one bit should be sent even if there is only one
; 652  :      * possible code. So to avoid special checks later on we force at least
; 653  :      * two codes of non zero frequency.
; 654  :      */
; 655  :     while (s->heap_len < 2) {

  0010b	44 8b 89 9c 14
	00 00		 mov	 r9d, DWORD PTR [rcx+5276]
  00112	41 8b fa	 mov	 edi, r10d
  00115	41 83 f9 02	 cmp	 r9d, 2
  00119	7c 95		 jl	 SHORT $LL5@build_tree
$LN6@build_tree:

; 660  :         /* node is 0 or 1 so it does not have extra bits */
; 661  :     }
; 662  :     desc->max_code = max_code;

  0011b	41 89 7e 08	 mov	 DWORD PTR [r14+8], edi

; 663  : 
; 664  :     /* The elements heap[heap_len/2 + 1 .. heap_len] are leaves of the tree,
; 665  :      * establish sub-heaps of increasing lengths:
; 666  :      */
; 667  :     for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

  0011f	44 8b 81 9c 14
	00 00		 mov	 r8d, DWORD PTR [rcx+5276]
  00126	41 8b c0	 mov	 eax, r8d
  00129	99		 cdq
  0012a	2b c2		 sub	 eax, edx
  0012c	d1 f8		 sar	 eax, 1
  0012e	8b d8		 mov	 ebx, eax
  00130	41 3b c4	 cmp	 eax, r12d
  00133	7c 1b		 jl	 SHORT $LL12@build_tree
$LL9@build_tree:
  00135	44 8b c3	 mov	 r8d, ebx
  00138	48 8b d6	 mov	 rdx, rsi
  0013b	e8 00 00 00 00	 call	 pqdownheap
  00140	ff cb		 dec	 ebx
  00142	41 3b dc	 cmp	 ebx, r12d
  00145	7d ee		 jge	 SHORT $LL9@build_tree
  00147	44 8b 81 9c 14
	00 00		 mov	 r8d, DWORD PTR [rcx+5276]
  0014e	66 90		 npad	 2
$LL12@build_tree:

; 668  : 
; 669  :     /* Construct the Huffman tree by repeatedly combining the least two
; 670  :      * frequent nodes.
; 671  :      */
; 672  :     node = elems;              /* next internal node of the tree */
; 673  :     do {
; 674  :         pqremove(s, tree, n);  /* n = node of least frequency */

  00150	48 63 99 ac 0b
	00 00		 movsxd	 rbx, DWORD PTR [rcx+2988]
  00157	49 63 c0	 movsxd	 rax, r8d
  0015a	8b 94 81 a8 0b
	00 00		 mov	 edx, DWORD PTR [rcx+rax*4+2984]
  00161	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00165	89 91 ac 0b 00
	00		 mov	 DWORD PTR [rcx+2988], edx
  0016b	45 8b c4	 mov	 r8d, r12d
  0016e	48 8b d6	 mov	 rdx, rsi
  00171	89 81 9c 14 00
	00		 mov	 DWORD PTR [rcx+5276], eax
  00177	e8 00 00 00 00	 call	 pqdownheap

; 675  :         m = s->heap[SMALLEST]; /* m = node of next least frequency */
; 676  : 
; 677  :         s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */

  0017c	48 63 91 a0 14
	00 00		 movsxd	 rdx, DWORD PTR [rcx+5280]
  00183	4c 63 81 ac 0b
	00 00		 movsxd	 r8, DWORD PTR [rcx+2988]

; 678  :         s->heap[--(s->heap_max)] = m;
; 679  : 
; 680  :         /* Create a new node father of n and m */
; 681  :         tree[node].Freq = tree[n].Freq + tree[m].Freq;

  0018a	4d 8b c8	 mov	 r9, r8
  0018d	4c 63 d5	 movsxd	 r10, ebp
  00190	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  00193	89 81 a0 14 00
	00		 mov	 DWORD PTR [rcx+5280], eax
  00199	89 9c 91 a4 0b
	00 00		 mov	 DWORD PTR [rcx+rdx*4+2980], ebx
  001a0	48 63 91 a0 14
	00 00		 movsxd	 rdx, DWORD PTR [rcx+5280]
  001a7	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  001aa	89 81 a0 14 00
	00		 mov	 DWORD PTR [rcx+5280], eax
  001b0	44 89 84 91 a4
	0b 00 00	 mov	 DWORD PTR [rcx+rdx*4+2980], r8d

; 682  :         s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
; 683  :                                 s->depth[n] : s->depth[m]) + 1);
; 684  :         tree[n].Dad = tree[m].Dad = (ush)node;
; 685  : #ifdef DUMP_BL_TREE
; 686  :         if (tree == s->bl_tree) {
; 687  :             fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
; 688  :                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
; 689  :         }
; 690  : #endif
; 691  :         /* and insert the new node in the heap */
; 692  :         s->heap[SMALLEST] = node++;
; 693  :         pqdownheap(s, tree, SMALLEST);

  001b8	48 8b d6	 mov	 rdx, rsi
  001bb	42 0f b7 04 86	 movzx	 eax, WORD PTR [rsi+r8*4]
  001c0	66 03 04 9e	 add	 ax, WORD PTR [rsi+rbx*4]
  001c4	66 42 89 04 96	 mov	 WORD PTR [rsi+r10*4], ax
  001c9	44 0f b6 84 0b
	a4 14 00 00	 movzx	 r8d, BYTE PTR [rbx+rcx+5284]
  001d2	41 0f b6 84 09
	a4 14 00 00	 movzx	 eax, BYTE PTR [r9+rcx+5284]
  001db	44 3a c0	 cmp	 r8b, al
  001de	44 0f 42 c0	 cmovb	 r8d, eax
  001e2	41 fe c0	 inc	 r8b
  001e5	45 88 84 0a a4
	14 00 00	 mov	 BYTE PTR [r10+rcx+5284], r8b
  001ed	45 8b c4	 mov	 r8d, r12d
  001f0	66 42 89 6c 8e
	02		 mov	 WORD PTR [rsi+r9*4+2], bp
  001f6	66 89 6c 9e 02	 mov	 WORD PTR [rsi+rbx*4+2], bp
  001fb	89 a9 ac 0b 00
	00		 mov	 DWORD PTR [rcx+2988], ebp
  00201	ff c5		 inc	 ebp
  00203	e8 00 00 00 00	 call	 pqdownheap

; 694  : 
; 695  :     } while (s->heap_len >= 2);

  00208	44 8b 81 9c 14
	00 00		 mov	 r8d, DWORD PTR [rcx+5276]
  0020f	41 83 f8 02	 cmp	 r8d, 2
  00213	0f 8d 37 ff ff
	ff		 jge	 $LL12@build_tree

; 696  : 
; 697  :     s->heap[--(s->heap_max)] = s->heap[SMALLEST];

  00219	4c 63 81 a0 14
	00 00		 movsxd	 r8, DWORD PTR [rcx+5280]

; 698  : 
; 699  :     /* At this point, the fields freq and dad are set. We can now
; 700  :      * generate the bit lengths.
; 701  :      */
; 702  :     gen_bitlen(s, (tree_desc *)desc);

  00220	49 8b d6	 mov	 rdx, r14
  00223	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00227	89 81 a0 14 00
	00		 mov	 DWORD PTR [rcx+5280], eax
  0022d	8b 81 ac 0b 00
	00		 mov	 eax, DWORD PTR [rcx+2988]
  00233	42 89 84 81 a4
	0b 00 00	 mov	 DWORD PTR [rcx+r8*4+2980], eax
  0023b	e8 00 00 00 00	 call	 gen_bitlen

; 703  : 
; 704  :     /* The field len is now set, we can generate the bit codes */
; 705  :     gen_codes ((ct_data *)tree, max_code, s->bl_count);

  00240	4c 8d 81 88 0b
	00 00		 lea	 r8, QWORD PTR [rcx+2952]
  00247	8b d7		 mov	 edx, edi
  00249	48 8b ce	 mov	 rcx, rsi

; 706  : }

  0024c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00251	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00256	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0025b	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00260	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00264	41 5f		 pop	 r15
  00266	41 5e		 pop	 r14
  00268	41 5c		 pop	 r12

; 703  : 
; 704  :     /* The field len is now set, we can generate the bit codes */
; 705  :     gen_codes ((ct_data *)tree, max_code, s->bl_count);

  0026a	e9 00 00 00 00	 jmp	 gen_codes
build_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT scan_tree
_TEXT	SEGMENT
s$ = 16
tree$ = 24
max_code$ = 32
scan_tree PROC						; COMDAT

; 712  : local void scan_tree(deflate_state *s, ct_data *tree, int max_code) {

  00000	40 57		 push	 rdi

; 713  :     int n;                     /* iterates over all tree elements */
; 714  :     int prevlen = -1;          /* last emitted length */
; 715  :     int curlen;                /* length of current code */
; 716  :     int nextlen = tree[0].Len; /* length of next code */

  00002	44 0f b7 52 02	 movzx	 r10d, WORD PTR [rdx+2]

; 717  :     int count = 0;             /* repeat count of the current code */

  00007	45 33 c9	 xor	 r9d, r9d

; 718  :     int max_count = 7;         /* max repeat count */
; 719  :     int min_count = 4;         /* min repeat count */
; 720  : 
; 721  :     if (nextlen == 0) max_count = 138, min_count = 3;
; 722  :     tree[max_code + 1].Len = (ush)0xffff; /* guard */

  0000a	4d 63 c0	 movsxd	 r8, r8d
  0000d	4c 8b da	 mov	 r11, rdx
  00010	bf ff ff ff ff	 mov	 edi, -1
  00015	66 42 c7 44 82
	06 ff ff	 mov	 WORD PTR [rdx+r8*4+6], 65535 ; 0000ffffH

; 723  : 
; 724  :     for (n = 0; n <= max_code; n++) {

  0001d	4d 85 c0	 test	 r8, r8
  00020	0f 88 f6 00 00
	00		 js	 $LN3@scan_tree
  00026	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  0002b	66 45 85 d2	 test	 r10w, r10w
  0002f	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00034	ba 8a 00 00 00	 mov	 edx, 138		; 0000008aH
  00039	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0003e	49 8d 68 01	 lea	 rbp, QWORD PTR [r8+1]
  00042	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00047	49 8d 73 06	 lea	 rsi, QWORD PTR [r11+6]
  0004b	41 be 07 00 00
	00		 mov	 r14d, 7
  00051	41 0f 45 d6	 cmovne	 edx, r14d
  00055	33 c0		 xor	 eax, eax

; 725  :         curlen = nextlen; nextlen = tree[n + 1].Len;
; 726  :         if (++count < max_count && curlen == nextlen) {

  00057	66 45 85 d2	 test	 r10w, r10w
  0005b	0f 95 c0	 setne	 al
  0005e	83 c0 03	 add	 eax, 3
  00061	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL4@scan_tree:
  00070	41 ff c1	 inc	 r9d
  00073	45 8b da	 mov	 r11d, r10d
  00076	45 8b c2	 mov	 r8d, r10d
  00079	41 8b da	 mov	 ebx, r10d
  0007c	44 0f b7 16	 movzx	 r10d, WORD PTR [rsi]
  00080	44 3b ca	 cmp	 r9d, edx
  00083	7d 05		 jge	 SHORT $LN6@scan_tree
  00085	41 3b da	 cmp	 ebx, r10d
  00088	74 70		 je	 SHORT $LN2@scan_tree
$LN6@scan_tree:

; 727  :             continue;
; 728  :         } else if (count < min_count) {

  0008a	44 3b c8	 cmp	 r9d, eax
  0008d	7d 0b		 jge	 SHORT $LN8@scan_tree

; 729  :             s->bl_tree[curlen].Freq += (ush)count;

  0008f	66 46 01 8c 99
	a4 0a 00 00	 add	 WORD PTR [rcx+r11*4+2724], r9w
  00098	eb 31		 jmp	 SHORT $LN14@scan_tree
$LN8@scan_tree:

; 730  :         } else if (curlen != 0) {

  0009a	45 85 c0	 test	 r8d, r8d
  0009d	74 16		 je	 SHORT $LN10@scan_tree

; 731  :             if (curlen != prevlen) s->bl_tree[curlen].Freq++;

  0009f	3b df		 cmp	 ebx, edi
  000a1	74 09		 je	 SHORT $LN25@scan_tree
  000a3	66 42 ff 84 99
	a4 0a 00 00	 inc	 WORD PTR [rcx+r11*4+2724]
$LN25@scan_tree:

; 732  :             s->bl_tree[REP_3_6].Freq++;

  000ac	66 ff 81 e4 0a
	00 00		 inc	 WORD PTR [rcx+2788]
  000b3	eb 16		 jmp	 SHORT $LN14@scan_tree
$LN10@scan_tree:

; 733  :         } else if (count <= 10) {

  000b5	41 83 f9 0a	 cmp	 r9d, 10
  000b9	7f 09		 jg	 SHORT $LN13@scan_tree

; 734  :             s->bl_tree[REPZ_3_10].Freq++;

  000bb	66 ff 81 e8 0a
	00 00		 inc	 WORD PTR [rcx+2792]

; 735  :         } else {

  000c2	eb 07		 jmp	 SHORT $LN14@scan_tree
$LN13@scan_tree:

; 736  :             s->bl_tree[REPZ_11_138].Freq++;

  000c4	66 ff 81 ec 0a
	00 00		 inc	 WORD PTR [rcx+2796]
$LN14@scan_tree:

; 737  :         }
; 738  :         count = 0; prevlen = curlen;

  000cb	45 33 c9	 xor	 r9d, r9d
  000ce	8b fb		 mov	 edi, ebx

; 739  :         if (nextlen == 0) {

  000d0	45 85 d2	 test	 r10d, r10d
  000d3	75 0c		 jne	 SHORT $LN15@scan_tree

; 740  :             max_count = 138, min_count = 3;

  000d5	ba 8a 00 00 00	 mov	 edx, 138		; 0000008aH
  000da	b8 03 00 00 00	 mov	 eax, 3
  000df	eb 19		 jmp	 SHORT $LN2@scan_tree
$LN15@scan_tree:

; 741  :         } else if (curlen == nextlen) {

  000e1	45 3b c2	 cmp	 r8d, r10d
  000e4	75 0c		 jne	 SHORT $LN17@scan_tree

; 742  :             max_count = 6, min_count = 3;

  000e6	ba 06 00 00 00	 mov	 edx, 6
  000eb	b8 03 00 00 00	 mov	 eax, 3

; 743  :         } else {

  000f0	eb 08		 jmp	 SHORT $LN2@scan_tree
$LN17@scan_tree:

; 744  :             max_count = 7, min_count = 4;

  000f2	41 8b d6	 mov	 edx, r14d
  000f5	b8 04 00 00 00	 mov	 eax, 4
$LN2@scan_tree:

; 723  : 
; 724  :     for (n = 0; n <= max_code; n++) {

  000fa	48 83 c6 04	 add	 rsi, 4
  000fe	48 83 ed 01	 sub	 rbp, 1
  00102	0f 85 68 ff ff
	ff		 jne	 $LL4@scan_tree
  00108	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  0010d	48 8b 74 24 20	 mov	 rsi, QWORD PTR [rsp+32]
  00112	48 8b 6c 24 18	 mov	 rbp, QWORD PTR [rsp+24]
  00117	48 8b 5c 24 10	 mov	 rbx, QWORD PTR [rsp+16]
$LN3@scan_tree:

; 745  :         }
; 746  :     }
; 747  : }

  0011c	5f		 pop	 rdi
  0011d	c3		 ret	 0
scan_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT send_tree
_TEXT	SEGMENT
s$ = 48
tree$ = 56
max_code$ = 64
send_tree PROC						; COMDAT

; 759  :     int max_count = 7;         /* max repeat count */
; 760  :     int min_count = 4;         /* min repeat count */
; 761  : 
; 762  :     /* tree[max_code + 1].Len = -1; */  /* guard already set */
; 763  :     if (nextlen == 0) max_count = 138, min_count = 3;
; 764  : 
; 765  :     for (n = 0; n <= max_code; n++) {

  00000	45 85 c0	 test	 r8d, r8d
  00003	0f 88 1a 05 00
	00		 js	 $LN67@send_tree
  00009	56		 push	 rsi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 754  :     int n;                     /* iterates over all tree elements */
; 755  :     int prevlen = -1;          /* last emitted length */
; 756  :     int curlen;                /* length of current code */
; 757  :     int nextlen = tree[0].Len; /* length of next code */

  0000e	0f b7 72 02	 movzx	 esi, WORD PTR [rdx+2]

; 758  :     int count = 0;             /* repeat count of the current code */

  00012	45 33 c9	 xor	 r9d, r9d

; 759  :     int max_count = 7;         /* max repeat count */
; 760  :     int min_count = 4;         /* min repeat count */
; 761  : 
; 762  :     /* tree[max_code + 1].Len = -1; */  /* guard already set */
; 763  :     if (nextlen == 0) max_count = 138, min_count = 3;
; 764  : 
; 765  :     for (n = 0; n <= max_code; n++) {

  00015	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0001a	85 f6		 test	 esi, esi
  0001c	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00021	48 8b c1	 mov	 rax, rcx
  00024	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00029	41 ba ff ff ff
	ff		 mov	 r10d, -1
  0002f	4c 89 64 24 18	 mov	 QWORD PTR [rsp+24], r12
  00034	4c 89 6c 24 10	 mov	 QWORD PTR [rsp+16], r13
  00039	41 bd 07 00 00
	00		 mov	 r13d, 7
  0003f	4d 63 d8	 movsxd	 r11, r8d
  00042	41 b8 8a 00 00
	00		 mov	 r8d, 138		; 0000008aH
  00048	45 0f 45 c5	 cmovne	 r8d, r13d
  0004c	4c 89 74 24 08	 mov	 QWORD PTR [rsp+8], r14
  00051	33 c9		 xor	 ecx, ecx
  00053	4c 89 3c 24	 mov	 QWORD PTR [rsp], r15
  00057	85 f6		 test	 esi, esi
  00059	4c 8d 7a 06	 lea	 r15, QWORD PTR [rdx+6]
  0005d	4d 8d 63 01	 lea	 r12, QWORD PTR [r11+1]
  00061	0f 95 c1	 setne	 cl
  00064	83 c1 03	 add	 ecx, 3
  00067	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@send_tree:

; 766  :         curlen = nextlen; nextlen = tree[n + 1].Len;

  00070	41 8b f9	 mov	 edi, r9d
  00073	8b d6		 mov	 edx, esi

; 767  :         if (++count < max_count && curlen == nextlen) {

  00075	41 ff c1	 inc	 r9d
  00078	8b ee		 mov	 ebp, esi
  0007a	44 8b f6	 mov	 r14d, esi
  0007d	41 0f b7 37	 movzx	 esi, WORD PTR [r15]
  00081	45 3b c8	 cmp	 r9d, r8d
  00084	7d 09		 jge	 SHORT $LN9@send_tree
  00086	44 3b f6	 cmp	 r14d, esi
  00089	0f 84 5f 04 00
	00		 je	 $LN2@send_tree
$LN9@send_tree:

; 768  :             continue;
; 769  :         } else if (count < min_count) {

  0008f	44 3b c9	 cmp	 r9d, ecx
  00092	0f 8d ab 00 00
	00		 jge	 $LN11@send_tree
  00098	48 8d 1c 90	 lea	 rbx, QWORD PTR [rax+rdx*4]
  0009c	48 8d 3c 90	 lea	 rdi, QWORD PTR [rax+rdx*4]
$LL7@send_tree:

; 770  :             do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

  000a0	44 8b 80 10 17
	00 00		 mov	 r8d, DWORD PTR [rax+5904]
  000a7	41 8b c8	 mov	 ecx, r8d
  000aa	44 0f b7 97 a4
	0a 00 00	 movzx	 r10d, WORD PTR [rdi+2724]
  000b2	44 0f b7 9b a6
	0a 00 00	 movzx	 r11d, WORD PTR [rbx+2726]
  000ba	41 0f b7 d2	 movzx	 edx, r10w
  000be	66 d3 e2	 shl	 dx, cl
  000c1	b9 10 00 00 00	 mov	 ecx, 16
  000c6	66 0b 90 0c 17
	00 00		 or	 dx, WORD PTR [rax+5900]
  000cd	41 2b cb	 sub	 ecx, r11d
  000d0	44 3b c1	 cmp	 r8d, ecx
  000d3	7e 49		 jle	 SHORT $LN13@send_tree
  000d5	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000d9	44 0f b7 c2	 movzx	 r8d, dx
  000dd	66 89 90 0c 17
	00 00		 mov	 WORD PTR [rax+5900], dx
  000e4	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  000e7	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  000eb	ff 40 28	 inc	 DWORD PTR [rax+40]
  000ee	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  000f2	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000f6	0f b6 88 0d 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5901]
  000fd	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  00101	b9 10 00 00 00	 mov	 ecx, 16
  00106	8b 90 10 17 00
	00		 mov	 edx, DWORD PTR [rax+5904]
  0010c	2a ca		 sub	 cl, dl
  0010e	ff 40 28	 inc	 DWORD PTR [rax+40]
  00111	44 8d 42 f0	 lea	 r8d, DWORD PTR [rdx-16]
  00115	45 03 c3	 add	 r8d, r11d
  00118	66 41 d3 ea	 shr	 r10w, cl
  0011c	eb 07		 jmp	 SHORT $LN5@send_tree
$LN13@send_tree:
  0011e	45 03 c3	 add	 r8d, r11d
  00121	44 0f b7 d2	 movzx	 r10d, dx
$LN5@send_tree:
  00125	66 44 89 90 0c
	17 00 00	 mov	 WORD PTR [rax+5900], r10w
  0012d	44 89 80 10 17
	00 00		 mov	 DWORD PTR [rax+5904], r8d
  00134	41 83 e9 01	 sub	 r9d, 1
  00138	0f 85 62 ff ff
	ff		 jne	 $LL7@send_tree

; 771  : 
; 772  :         } else if (curlen != 0) {

  0013e	e9 7b 03 00 00	 jmp	 $LN33@send_tree
$LN11@send_tree:
  00143	85 ed		 test	 ebp, ebp
  00145	0f 84 78 01 00
	00		 je	 $LN15@send_tree

; 773  :             if (curlen != prevlen) {

  0014b	45 3b f2	 cmp	 r14d, r10d
  0014e	4c 8d 98 10 17
	00 00		 lea	 r11, QWORD PTR [rax+5904]
  00155	4c 8d 90 0c 17
	00 00		 lea	 r10, QWORD PTR [rax+5900]
  0015c	0f 84 80 00 00
	00		 je	 $LN47@send_tree

; 774  :                 send_code(s, curlen, s->bl_tree); count--;

  00162	0f b7 9c 90 a6
	0a 00 00	 movzx	 ebx, WORD PTR [rax+rdx*4+2726]
  0016a	44 0f b7 8c 90
	a4 0a 00 00	 movzx	 r9d, WORD PTR [rax+rdx*4+2724]
  00173	45 8b 03	 mov	 r8d, DWORD PTR [r11]
  00176	41 0f b7 d1	 movzx	 edx, r9w
  0017a	41 8b c8	 mov	 ecx, r8d
  0017d	66 d3 e2	 shl	 dx, cl
  00180	b9 10 00 00 00	 mov	 ecx, 16
  00185	66 41 0b 12	 or	 dx, WORD PTR [r10]
  00189	2b cb		 sub	 ecx, ebx
  0018b	44 3b c1	 cmp	 r8d, ecx
  0018e	7e 41		 jle	 SHORT $LN18@send_tree
  00190	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00194	44 0f b7 c2	 movzx	 r8d, dx
  00198	66 41 89 12	 mov	 WORD PTR [r10], dx
  0019c	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  0019f	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  001a3	ff 40 28	 inc	 DWORD PTR [rax+40]
  001a6	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  001aa	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  001ae	41 0f b6 4a 01	 movzx	 ecx, BYTE PTR [r10+1]
  001b3	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  001b7	b9 10 00 00 00	 mov	 ecx, 16
  001bc	41 8b 13	 mov	 edx, DWORD PTR [r11]
  001bf	2a ca		 sub	 cl, dl
  001c1	ff 40 28	 inc	 DWORD PTR [rax+40]
  001c4	44 8d 42 f0	 lea	 r8d, DWORD PTR [rdx-16]
  001c8	44 03 c3	 add	 r8d, ebx
  001cb	66 41 d3 e9	 shr	 r9w, cl
  001cf	eb 07		 jmp	 SHORT $LN19@send_tree
$LN18@send_tree:
  001d1	44 03 c3	 add	 r8d, ebx
  001d4	44 0f b7 ca	 movzx	 r9d, dx
$LN19@send_tree:
  001d8	66 45 89 0a	 mov	 WORD PTR [r10], r9w
  001dc	44 8b cf	 mov	 r9d, edi
  001df	45 89 03	 mov	 DWORD PTR [r11], r8d
$LN47@send_tree:

; 775  :             }
; 776  :             Assert(count >= 3 && count <= 6, " 3_6?");
; 777  :             send_code(s, REP_3_6, s->bl_tree); send_bits(s, count - 3, 2);

  001e2	45 8b 03	 mov	 r8d, DWORD PTR [r11]
  001e5	41 8b c8	 mov	 ecx, r8d
  001e8	0f b7 b8 e4 0a
	00 00		 movzx	 edi, WORD PTR [rax+2788]
  001ef	0f b7 98 e6 0a
	00 00		 movzx	 ebx, WORD PTR [rax+2790]
  001f6	0f b7 d7	 movzx	 edx, di
  001f9	66 d3 e2	 shl	 dx, cl
  001fc	b9 10 00 00 00	 mov	 ecx, 16
  00201	66 41 0b 12	 or	 dx, WORD PTR [r10]
  00205	2b cb		 sub	 ecx, ebx
  00207	44 3b c1	 cmp	 r8d, ecx
  0020a	7e 3e		 jle	 SHORT $LN20@send_tree
  0020c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00210	44 0f b7 c2	 movzx	 r8d, dx
  00214	66 41 89 12	 mov	 WORD PTR [r10], dx
  00218	83 c3 f0	 add	 ebx, -16
  0021b	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  0021e	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  00222	ff 40 28	 inc	 DWORD PTR [rax+40]
  00225	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  00229	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0022d	41 0f b6 4a 01	 movzx	 ecx, BYTE PTR [r10+1]
  00232	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  00236	b9 10 00 00 00	 mov	 ecx, 16
  0023b	41 8b 13	 mov	 edx, DWORD PTR [r11]
  0023e	03 da		 add	 ebx, edx
  00240	ff 40 28	 inc	 DWORD PTR [rax+40]
  00243	2a ca		 sub	 cl, dl
  00245	66 d3 ef	 shr	 di, cl
  00248	eb 06		 jmp	 SHORT $LN68@send_tree
$LN20@send_tree:
  0024a	41 03 d8	 add	 ebx, r8d
  0024d	0f b7 fa	 movzx	 edi, dx
$LN68@send_tree:
  00250	49 8b cb	 mov	 rcx, r11
  00253	66 41 83 e9 03	 sub	 r9w, 3
  00258	45 0f b7 c1	 movzx	 r8d, r9w
  0025c	89 19		 mov	 DWORD PTR [rcx], ebx
  0025e	8b cb		 mov	 ecx, ebx
  00260	66 41 d3 e0	 shl	 r8w, cl
  00264	66 44 0b c7	 or	 r8w, di
  00268	83 fb 0e	 cmp	 ebx, 14
  0026b	7e 43		 jle	 SHORT $LN22@send_tree
  0026d	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00270	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00274	66 45 89 02	 mov	 WORD PTR [r10], r8w
  00278	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  0027c	ff 40 28	 inc	 DWORD PTR [rax+40]
  0027f	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  00283	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00287	41 0f b6 4a 01	 movzx	 ecx, BYTE PTR [r10+1]
  0028c	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  00290	41 8b 13	 mov	 edx, DWORD PTR [r11]
  00293	ff 40 28	 inc	 DWORD PTR [rax+40]
  00296	8d 4a f2	 lea	 ecx, DWORD PTR [rdx-14]
  00299	41 89 0b	 mov	 DWORD PTR [r11], ecx
  0029c	b9 10 00 00 00	 mov	 ecx, 16
  002a1	2a ca		 sub	 cl, dl
  002a3	66 41 d3 e9	 shr	 r9w, cl
  002a7	66 45 89 0a	 mov	 WORD PTR [r10], r9w
  002ab	e9 0e 02 00 00	 jmp	 $LN33@send_tree
$LN22@send_tree:
  002b0	8d 4b 02	 lea	 ecx, DWORD PTR [rbx+2]
  002b3	45 0f b7 c8	 movzx	 r9d, r8w
  002b7	41 89 0b	 mov	 DWORD PTR [r11], ecx
  002ba	66 45 89 02	 mov	 WORD PTR [r10], r8w
  002be	e9 fb 01 00 00	 jmp	 $LN33@send_tree
$LN15@send_tree:

; 778  : 
; 779  :         } else if (count <= 10) {

  002c3	44 8b 80 10 17
	00 00		 mov	 r8d, DWORD PTR [rax+5904]
  002ca	41 8b c8	 mov	 ecx, r8d
  002cd	4c 8d 90 0c 17
	00 00		 lea	 r10, QWORD PTR [rax+5900]
  002d4	41 83 f9 0a	 cmp	 r9d, 10
  002d8	0f 8f f9 00 00
	00		 jg	 $LN24@send_tree

; 780  :             send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count - 3, 3);

  002de	44 0f b7 98 e8
	0a 00 00	 movzx	 r11d, WORD PTR [rax+2792]
  002e6	0f b7 98 ea 0a
	00 00		 movzx	 ebx, WORD PTR [rax+2794]
  002ed	41 0f b7 d3	 movzx	 edx, r11w
  002f1	66 d3 e2	 shl	 dx, cl
  002f4	b9 10 00 00 00	 mov	 ecx, 16
  002f9	66 41 0b 12	 or	 dx, WORD PTR [r10]
  002fd	2b cb		 sub	 ecx, ebx
  002ff	44 3b c1	 cmp	 r8d, ecx
  00302	7e 42		 jle	 SHORT $LN26@send_tree
  00304	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00308	44 0f b7 c2	 movzx	 r8d, dx
  0030c	66 41 89 12	 mov	 WORD PTR [r10], dx
  00310	83 c3 f0	 add	 ebx, -16
  00313	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00316	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  0031a	ff 40 28	 inc	 DWORD PTR [rax+40]
  0031d	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  00321	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00325	41 0f b6 4a 01	 movzx	 ecx, BYTE PTR [r10+1]
  0032a	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  0032e	b9 10 00 00 00	 mov	 ecx, 16
  00333	8b 90 10 17 00
	00		 mov	 edx, DWORD PTR [rax+5904]
  00339	03 da		 add	 ebx, edx
  0033b	ff 40 28	 inc	 DWORD PTR [rax+40]
  0033e	2a ca		 sub	 cl, dl
  00340	66 41 d3 eb	 shr	 r11w, cl
  00344	eb 07		 jmp	 SHORT $LN69@send_tree
$LN26@send_tree:
  00346	41 03 d8	 add	 ebx, r8d
  00349	44 0f b7 da	 movzx	 r11d, dx
$LN69@send_tree:
  0034d	66 41 83 e9 03	 sub	 r9w, 3
  00352	48 8b c8	 mov	 rcx, rax
  00355	8b cb		 mov	 ecx, ebx
  00357	45 0f b7 c1	 movzx	 r8d, r9w
  0035b	66 41 d3 e0	 shl	 r8w, cl
  0035f	ba 0c 17 00 00	 mov	 edx, 5900		; 0000170cH
  00364	66 45 0b c3	 or	 r8w, r11w
  00368	66 44 89 1c 10	 mov	 WORD PTR [rax+rdx], r11w
  0036d	89 98 10 17 00
	00		 mov	 DWORD PTR [rax+5904], ebx
  00373	83 fb 0d	 cmp	 ebx, 13
  00376	7e 49		 jle	 SHORT $LN28@send_tree
  00378	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  0037b	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0037f	66 45 89 02	 mov	 WORD PTR [r10], r8w
  00383	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  00387	ff 40 28	 inc	 DWORD PTR [rax+40]
  0038a	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  0038e	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00392	41 0f b6 4a 01	 movzx	 ecx, BYTE PTR [r10+1]
  00397	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  0039b	8b 90 10 17 00
	00		 mov	 edx, DWORD PTR [rax+5904]
  003a1	ff 40 28	 inc	 DWORD PTR [rax+40]
  003a4	8d 4a f3	 lea	 ecx, DWORD PTR [rdx-13]
  003a7	89 88 10 17 00
	00		 mov	 DWORD PTR [rax+5904], ecx
  003ad	b9 10 00 00 00	 mov	 ecx, 16
  003b2	2a ca		 sub	 cl, dl
  003b4	66 41 d3 e9	 shr	 r9w, cl

; 781  : 
; 782  :         } else {

  003b8	66 45 89 0a	 mov	 WORD PTR [r10], r9w
  003bc	e9 fd 00 00 00	 jmp	 $LN33@send_tree
$LN28@send_tree:

; 780  :             send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count - 3, 3);

  003c1	8d 4b 03	 lea	 ecx, DWORD PTR [rbx+3]
  003c4	45 0f b7 c8	 movzx	 r9d, r8w
  003c8	89 88 10 17 00
	00		 mov	 DWORD PTR [rax+5904], ecx

; 781  : 
; 782  :         } else {

  003ce	66 45 89 02	 mov	 WORD PTR [r10], r8w
  003d2	e9 e7 00 00 00	 jmp	 $LN33@send_tree
$LN24@send_tree:

; 783  :             send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count - 11, 7);

  003d7	44 0f b7 98 ec
	0a 00 00	 movzx	 r11d, WORD PTR [rax+2796]
  003df	0f b7 98 ee 0a
	00 00		 movzx	 ebx, WORD PTR [rax+2798]
  003e6	41 0f b7 d3	 movzx	 edx, r11w
  003ea	66 d3 e2	 shl	 dx, cl
  003ed	b9 10 00 00 00	 mov	 ecx, 16
  003f2	66 41 0b 12	 or	 dx, WORD PTR [r10]
  003f6	2b cb		 sub	 ecx, ebx
  003f8	44 3b c1	 cmp	 r8d, ecx
  003fb	7e 44		 jle	 SHORT $LN30@send_tree
  003fd	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00401	44 0f b7 c2	 movzx	 r8d, dx
  00405	66 41 89 12	 mov	 WORD PTR [r10], dx
  00409	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  0040c	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  00410	ff 40 28	 inc	 DWORD PTR [rax+40]
  00413	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  00417	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0041b	41 0f b6 4a 01	 movzx	 ecx, BYTE PTR [r10+1]
  00420	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  00424	b9 10 00 00 00	 mov	 ecx, 16
  00429	8b 90 10 17 00
	00		 mov	 edx, DWORD PTR [rax+5904]
  0042f	2a ca		 sub	 cl, dl
  00431	ff 40 28	 inc	 DWORD PTR [rax+40]
  00434	44 8d 42 f0	 lea	 r8d, DWORD PTR [rdx-16]
  00438	44 03 c3	 add	 r8d, ebx
  0043b	66 41 d3 eb	 shr	 r11w, cl
  0043f	eb 07		 jmp	 SHORT $LN70@send_tree
$LN30@send_tree:
  00441	44 03 c3	 add	 r8d, ebx
  00444	44 0f b7 da	 movzx	 r11d, dx
$LN70@send_tree:
  00448	66 41 83 e9 0b	 sub	 r9w, 11
  0044d	48 8b c8	 mov	 rcx, rax
  00450	41 8b c8	 mov	 ecx, r8d
  00453	41 0f b7 d9	 movzx	 ebx, r9w
  00457	66 d3 e3	 shl	 bx, cl
  0045a	ba 0c 17 00 00	 mov	 edx, 5900		; 0000170cH
  0045f	66 41 0b db	 or	 bx, r11w
  00463	66 44 89 1c 10	 mov	 WORD PTR [rax+rdx], r11w
  00468	44 89 80 10 17
	00 00		 mov	 DWORD PTR [rax+5904], r8d
  0046f	66 41 89 1a	 mov	 WORD PTR [r10], bx
  00473	41 83 f8 09	 cmp	 r8d, 9
  00477	7e 3b		 jle	 SHORT $LN32@send_tree
  00479	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  0047c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00480	88 1c 0a	 mov	 BYTE PTR [rdx+rcx], bl
  00483	ff 40 28	 inc	 DWORD PTR [rax+40]
  00486	41 0f b6 4a 01	 movzx	 ecx, BYTE PTR [r10+1]
  0048b	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  0048f	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00493	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  00497	b9 10 00 00 00	 mov	 ecx, 16
  0049c	8b 90 10 17 00
	00		 mov	 edx, DWORD PTR [rax+5904]
  004a2	2a ca		 sub	 cl, dl
  004a4	ff 40 28	 inc	 DWORD PTR [rax+40]
  004a7	66 41 d3 e9	 shr	 r9w, cl
  004ab	66 45 89 0a	 mov	 WORD PTR [r10], r9w
  004af	8d 4a f7	 lea	 ecx, DWORD PTR [rdx-9]
  004b2	eb 04		 jmp	 SHORT $LN71@send_tree
$LN32@send_tree:
  004b4	41 8d 48 07	 lea	 ecx, DWORD PTR [r8+7]
$LN71@send_tree:

; 784  :         }
; 785  :         count = 0; prevlen = curlen;

  004b8	89 88 10 17 00
	00		 mov	 DWORD PTR [rax+5904], ecx
$LN33@send_tree:
  004be	45 33 c9	 xor	 r9d, r9d
  004c1	45 8b d6	 mov	 r10d, r14d

; 786  :         if (nextlen == 0) {

  004c4	85 f6		 test	 esi, esi
  004c6	75 0d		 jne	 SHORT $LN34@send_tree

; 787  :             max_count = 138, min_count = 3;

  004c8	b9 03 00 00 00	 mov	 ecx, 3
  004cd	41 b8 8a 00 00
	00		 mov	 r8d, 138		; 0000008aH
  004d3	eb 19		 jmp	 SHORT $LN2@send_tree
$LN34@send_tree:

; 788  :         } else if (curlen == nextlen) {

  004d5	3b ee		 cmp	 ebp, esi
  004d7	75 0d		 jne	 SHORT $LN36@send_tree

; 789  :             max_count = 6, min_count = 3;

  004d9	b9 03 00 00 00	 mov	 ecx, 3
  004de	41 b8 06 00 00
	00		 mov	 r8d, 6

; 790  :         } else {

  004e4	eb 08		 jmp	 SHORT $LN2@send_tree
$LN36@send_tree:

; 791  :             max_count = 7, min_count = 4;

  004e6	45 8b c5	 mov	 r8d, r13d
  004e9	b9 04 00 00 00	 mov	 ecx, 4
$LN2@send_tree:

; 759  :     int max_count = 7;         /* max repeat count */
; 760  :     int min_count = 4;         /* min repeat count */
; 761  : 
; 762  :     /* tree[max_code + 1].Len = -1; */  /* guard already set */
; 763  :     if (nextlen == 0) max_count = 138, min_count = 3;
; 764  : 
; 765  :     for (n = 0; n <= max_code; n++) {

  004ee	49 83 c7 04	 add	 r15, 4
  004f2	49 83 ec 01	 sub	 r12, 1
  004f6	0f 85 74 fb ff
	ff		 jne	 $LL4@send_tree
  004fc	4c 8b 3c 24	 mov	 r15, QWORD PTR [rsp]
  00500	4c 8b 74 24 08	 mov	 r14, QWORD PTR [rsp+8]
  00505	4c 8b 6c 24 10	 mov	 r13, QWORD PTR [rsp+16]
  0050a	4c 8b 64 24 18	 mov	 r12, QWORD PTR [rsp+24]
  0050f	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00514	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00519	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 792  :         }
; 793  :     }
; 794  : }

  0051e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00522	5e		 pop	 rsi
$LN67@send_tree:
  00523	c3		 ret	 0
send_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT build_bl_tree
_TEXT	SEGMENT
s$ = 48
build_bl_tree PROC					; COMDAT

; 800  : local int build_bl_tree(deflate_state *s) {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 801  :     int max_blindex;  /* index of last bit length code of non zero freq */
; 802  : 
; 803  :     /* Determine the bit length frequencies for literal and distance trees */
; 804  :     scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);

  00006	44 8b 81 48 0b
	00 00		 mov	 r8d, DWORD PTR [rcx+2888]
  0000d	48 8d 91 bc 00
	00 00		 lea	 rdx, QWORD PTR [rcx+188]
  00014	48 8b d9	 mov	 rbx, rcx
  00017	e8 00 00 00 00	 call	 scan_tree

; 805  :     scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

  0001c	44 8b 81 60 0b
	00 00		 mov	 r8d, DWORD PTR [rcx+2912]
  00023	48 8d 91 b0 09
	00 00		 lea	 rdx, QWORD PTR [rcx+2480]
  0002a	e8 00 00 00 00	 call	 scan_tree

; 806  : 
; 807  :     /* Build the bit length tree: */
; 808  :     build_tree(s, (tree_desc *)(&(s->bl_desc)));

  0002f	48 8d 91 70 0b
	00 00		 lea	 rdx, QWORD PTR [rcx+2928]
  00036	e8 00 00 00 00	 call	 build_tree

; 809  :     /* opt_len now includes the length of the tree representations, except the
; 810  :      * lengths of the bit lengths codes and the 5 + 5 + 4 bits for the counts.
; 811  :      */
; 812  : 
; 813  :     /* Determine the number of bit length codes to send. The pkzip format
; 814  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 815  :      * 3 but the actual value used is 4.)
; 816  :      */
; 817  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

  0003b	ba 12 00 00 00	 mov	 edx, 18
  00040	48 8d 05 10 00
	00 00		 lea	 rax, OFFSET FLAT:bl_order+16
  00047	44 8b c2	 mov	 r8d, edx
  0004a	4c 2b c0	 sub	 r8, rax
  0004d	0f 1f 00	 npad	 3
$LL4@build_bl_t:

; 818  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  00050	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00054	66 83 bc 8b a6
	0a 00 00 00	 cmp	 WORD PTR [rbx+rcx*4+2726], 0
  0005d	75 4b		 jne	 SHORT $LN15@build_bl_t
  0005f	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00063	66 83 bc 8b a6
	0a 00 00 00	 cmp	 WORD PTR [rbx+rcx*4+2726], 0
  0006c	75 3a		 jne	 SHORT $LN12@build_bl_t
  0006e	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00071	66 83 bc 8b a6
	0a 00 00 00	 cmp	 WORD PTR [rbx+rcx*4+2726], 0
  0007a	75 27		 jne	 SHORT $LN13@build_bl_t
  0007c	0f b6 48 ff	 movzx	 ecx, BYTE PTR [rax-1]
  00080	66 83 bc 8b a6
	0a 00 00 00	 cmp	 WORD PTR [rbx+rcx*4+2726], 0
  00089	75 13		 jne	 SHORT $LN14@build_bl_t

; 809  :     /* opt_len now includes the length of the tree representations, except the
; 810  :      * lengths of the bit lengths codes and the 5 + 5 + 4 bits for the counts.
; 811  :      */
; 812  : 
; 813  :     /* Determine the number of bit length codes to send. The pkzip format
; 814  :      * requires that at least 4 bit length codes be sent. (appnote.txt says
; 815  :      * 3 but the actual value used is 4.)
; 816  :      */
; 817  :     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {

  0008b	48 83 e8 04	 sub	 rax, 4
  0008f	83 ea 04	 sub	 edx, 4
  00092	49 8d 0c 00	 lea	 rcx, QWORD PTR [r8+rax]
  00096	48 83 f9 03	 cmp	 rcx, 3
  0009a	7d b4		 jge	 SHORT $LL4@build_bl_t
  0009c	eb 0c		 jmp	 SHORT $LN15@build_bl_t
$LN14@build_bl_t:

; 818  :         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;

  0009e	83 ea 03	 sub	 edx, 3
  000a1	eb 07		 jmp	 SHORT $LN15@build_bl_t
$LN13@build_bl_t:
  000a3	83 ea 02	 sub	 edx, 2
  000a6	eb 02		 jmp	 SHORT $LN15@build_bl_t
$LN12@build_bl_t:
  000a8	ff ca		 dec	 edx
$LN15@build_bl_t:

; 819  :     }
; 820  :     /* Update opt_len to include the bit length tree and counts */
; 821  :     s->opt_len += 3*((ulg)max_blindex + 1) + 5 + 5 + 4;

  000aa	8d 0c 55 11 00
	00 00		 lea	 ecx, DWORD PTR [rdx*2+17]

; 822  :     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
; 823  :             s->opt_len, s->static_len));
; 824  : 
; 825  :     return max_blindex;

  000b1	8b c2		 mov	 eax, edx
  000b3	03 ca		 add	 ecx, edx
  000b5	01 8b fc 16 00
	00		 add	 DWORD PTR [rbx+5884], ecx

; 826  : }

  000bb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bf	5b		 pop	 rbx
  000c0	c3		 ret	 0
build_bl_tree ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT send_all_trees
_TEXT	SEGMENT
s$ = 48
lcodes$ = 56
dcodes$ = 64
blcodes$ = 72
send_all_trees PROC					; COMDAT

; 834  :                           int blcodes) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	45 8b d0	 mov	 r10d, r8d
  0001d	41 8b f1	 mov	 esi, r9d

; 835  :     int rank;                    /* index in bl_order */
; 836  : 
; 837  :     Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
; 838  :     Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
; 839  :             "too many codes");
; 840  :     Tracev((stderr, "\nbl counts: "));
; 841  :     send_bits(s, lcodes - 257, 5);  /* not +255 as stated in appnote.txt */

  00020	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  00025	48 8b d9	 mov	 rbx, rcx
  00028	8b 89 10 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5904]
  0002e	44 0f b7 c2	 movzx	 r8d, dx
  00032	66 44 2b c0	 sub	 r8w, ax
  00036	44 8b f2	 mov	 r14d, edx
  00039	41 0f b7 c0	 movzx	 eax, r8w
  0003d	66 d3 e0	 shl	 ax, cl
  00040	66 0b 83 0c 17
	00 00		 or	 ax, WORD PTR [rbx+5900]
  00047	83 f9 0b	 cmp	 ecx, 11
  0004a	7e 41		 jle	 SHORT $LN5@send_all_t
  0004c	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0004f	0f b7 d0	 movzx	 edx, ax
  00052	66 89 83 0c 17
	00 00		 mov	 WORD PTR [rbx+5900], ax
  00059	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0005d	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00060	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00063	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00066	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0006a	0f b6 83 0d 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5901]
  00071	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00074	b9 10 00 00 00	 mov	 ecx, 16
  00079	8b 83 10 17 00
	00		 mov	 eax, DWORD PTR [rbx+5904]
  0007f	2a c8		 sub	 cl, al
  00081	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00084	66 41 d3 e8	 shr	 r8w, cl
  00088	8d 50 f5	 lea	 edx, DWORD PTR [rax-11]
  0008b	eb 07		 jmp	 SHORT $LN24@send_all_t
$LN5@send_all_t:
  0008d	8d 51 05	 lea	 edx, DWORD PTR [rcx+5]
  00090	44 0f b7 c0	 movzx	 r8d, ax
$LN24@send_all_t:

; 842  :     send_bits(s, dcodes - 1,   5);

  00094	89 93 10 17 00
	00		 mov	 DWORD PTR [rbx+5904], edx
  0009a	41 8d 6a ff	 lea	 ebp, DWORD PTR [r10-1]
  0009e	8b ca		 mov	 ecx, edx
  000a0	83 fa 0b	 cmp	 edx, 11
  000a3	7e 4d		 jle	 SHORT $LN7@send_all_t
  000a5	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000a9	0f b7 d5	 movzx	 edx, bp
  000ac	66 d3 e2	 shl	 dx, cl
  000af	44 0f b7 d5	 movzx	 r10d, bp
  000b3	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  000b6	66 41 0b d0	 or	 dx, r8w
  000ba	66 89 93 0c 17
	00 00		 mov	 WORD PTR [rbx+5900], dx
  000c1	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  000c4	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000c7	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  000ca	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  000ce	0f b6 83 0d 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5901]
  000d5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000d8	b9 10 00 00 00	 mov	 ecx, 16
  000dd	8b 83 10 17 00
	00		 mov	 eax, DWORD PTR [rbx+5904]
  000e3	2a c8		 sub	 cl, al
  000e5	ff 43 28	 inc	 DWORD PTR [rbx+40]
  000e8	66 41 d3 ea	 shr	 r10w, cl
  000ec	44 8d 58 f5	 lea	 r11d, DWORD PTR [rax-11]
  000f0	eb 10		 jmp	 SHORT $LN25@send_all_t
$LN7@send_all_t:
  000f2	66 41 ff ca	 dec	 r10w
  000f6	44 8d 5a 05	 lea	 r11d, DWORD PTR [rdx+5]
  000fa	66 41 d3 e2	 shl	 r10w, cl
  000fe	66 45 0b d0	 or	 r10w, r8w
$LN25@send_all_t:

; 843  :     send_bits(s, blcodes - 4,  4);  /* not -3 as stated in appnote.txt */

  00102	44 8d 46 fc	 lea	 r8d, DWORD PTR [rsi-4]
  00106	44 89 9b 10 17
	00 00		 mov	 DWORD PTR [rbx+5904], r11d
  0010d	41 0f b7 d0	 movzx	 edx, r8w
  00111	41 8b cb	 mov	 ecx, r11d
  00114	66 d3 e2	 shl	 dx, cl
  00117	66 41 0b d2	 or	 dx, r10w
  0011b	41 83 fb 0c	 cmp	 r11d, 12
  0011f	7e 3e		 jle	 SHORT $LN9@send_all_t
  00121	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00124	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00128	66 89 93 0c 17
	00 00		 mov	 WORD PTR [rbx+5900], dx
  0012f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00132	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00135	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  00138	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0013c	0f b6 83 0d 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5901]
  00143	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00146	b9 10 00 00 00	 mov	 ecx, 16
  0014b	8b 93 10 17 00
	00		 mov	 edx, DWORD PTR [rbx+5904]
  00151	2a ca		 sub	 cl, dl
  00153	ff 43 28	 inc	 DWORD PTR [rbx+40]
  00156	66 41 d3 e8	 shr	 r8w, cl
  0015a	8d 42 f4	 lea	 eax, DWORD PTR [rdx-12]
  0015d	eb 08		 jmp	 SHORT $LN26@send_all_t
$LN9@send_all_t:
  0015f	41 8d 43 04	 lea	 eax, DWORD PTR [r11+4]
  00163	44 0f b7 c2	 movzx	 r8d, dx
$LN26@send_all_t:

; 844  :     for (rank = 0; rank < blcodes; rank++) {

  00167	89 83 10 17 00
	00		 mov	 DWORD PTR [rbx+5904], eax
  0016d	66 44 89 83 0c
	17 00 00	 mov	 WORD PTR [rbx+5900], r8w
  00175	85 f6		 test	 esi, esi
  00177	0f 8e a9 00 00
	00		 jle	 $LN3@send_all_t
  0017d	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:bl_order
  00184	4c 8b de	 mov	 r11, rsi
  00187	41 0f b7 d0	 movzx	 edx, r8w
  0018b	0f 1f 44 00 00	 npad	 5
$LL4@send_all_t:

; 845  :         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
; 846  :         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);

  00190	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00194	8b 8b 10 17 00
	00		 mov	 ecx, DWORD PTR [rbx+5904]
  0019a	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  0019e	83 f9 0d	 cmp	 ecx, 13
  001a1	7e 53		 jle	 SHORT $LN11@send_all_t
  001a3	44 0f b7 80 a6
	0a 00 00	 movzx	 r8d, WORD PTR [rax+2726]
  001ab	41 0f b7 c0	 movzx	 eax, r8w
  001af	66 d3 e0	 shl	 ax, cl
  001b2	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  001b5	66 0b c2	 or	 ax, dx
  001b8	0f b7 d0	 movzx	 edx, ax
  001bb	66 89 83 0c 17
	00 00		 mov	 WORD PTR [rbx+5900], ax
  001c2	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  001c6	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  001c9	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001cc	8b 53 28	 mov	 edx, DWORD PTR [rbx+40]
  001cf	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  001d3	0f b6 83 0d 17
	00 00		 movzx	 eax, BYTE PTR [rbx+5901]
  001da	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001dd	b9 10 00 00 00	 mov	 ecx, 16
  001e2	8b 93 10 17 00
	00		 mov	 edx, DWORD PTR [rbx+5904]
  001e8	2a ca		 sub	 cl, dl
  001ea	ff 43 28	 inc	 DWORD PTR [rbx+40]
  001ed	66 41 d3 e8	 shr	 r8w, cl
  001f1	8d 42 f3	 lea	 eax, DWORD PTR [rdx-13]
  001f4	eb 11		 jmp	 SHORT $LN27@send_all_t
$LN11@send_all_t:
  001f6	0f b7 80 a6 0a
	00 00		 movzx	 eax, WORD PTR [rax+2726]
  001fd	66 d3 e0	 shl	 ax, cl
  00200	66 44 0b c0	 or	 r8w, ax
  00204	8d 41 03	 lea	 eax, DWORD PTR [rcx+3]
$LN27@send_all_t:

; 844  :     for (rank = 0; rank < blcodes; rank++) {

  00207	49 ff c2	 inc	 r10
  0020a	89 83 10 17 00
	00		 mov	 DWORD PTR [rbx+5904], eax
  00210	66 44 89 83 0c
	17 00 00	 mov	 WORD PTR [rbx+5900], r8w
  00218	41 0f b7 d0	 movzx	 edx, r8w
  0021c	49 83 eb 01	 sub	 r11, 1
  00220	0f 85 6a ff ff
	ff		 jne	 $LL4@send_all_t
$LN3@send_all_t:

; 847  :     }
; 848  :     Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
; 849  : 
; 850  :     send_tree(s, (ct_data *)s->dyn_ltree, lcodes - 1);  /* literal tree */

  00226	45 8d 46 ff	 lea	 r8d, DWORD PTR [r14-1]
  0022a	48 8b cb	 mov	 rcx, rbx
  0022d	48 8d 93 bc 00
	00 00		 lea	 rdx, QWORD PTR [rbx+188]
  00234	e8 00 00 00 00	 call	 send_tree

; 851  :     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
; 852  : 
; 853  :     send_tree(s, (ct_data *)s->dyn_dtree, dcodes - 1);  /* distance tree */

  00239	48 8d 93 b0 09
	00 00		 lea	 rdx, QWORD PTR [rbx+2480]
  00240	44 8b c5	 mov	 r8d, ebp
  00243	48 8b cb	 mov	 rcx, rbx

; 854  :     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
; 855  : }

  00246	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0024b	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00250	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00255	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0025a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0025e	41 5e		 pop	 r14

; 851  :     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
; 852  : 
; 853  :     send_tree(s, (ct_data *)s->dyn_dtree, dcodes - 1);  /* distance tree */

  00260	e9 00 00 00 00	 jmp	 send_tree
send_all_trees ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT compress_block
_TEXT	SEGMENT
tv1555 = 0
tv1554 = 8
s$ = 96
tv1613 = 96
ltree$ = 104
dtree$ = 112
tv1556 = 120
compress_block PROC					; COMDAT

; 901  :                           const ct_data *dtree) {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00012	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12

; 902  :     unsigned dist;      /* distance of matched string */
; 903  :     int lc;             /* match length or unmatched char (if dist == 0) */
; 904  :     unsigned sx = 0;    /* running index in symbol buffers */
; 905  :     unsigned code;      /* the code to send */
; 906  :     int extra;          /* number of extra bits to send */
; 907  : 
; 908  :     if (s->sym_next != 0) do {

  00017	4c 8d 99 10 17
	00 00		 lea	 r11, QWORD PTR [rcx+5904]
  0001e	45 33 e4	 xor	 r12d, r12d
  00021	4c 8d 51 28	 lea	 r10, QWORD PTR [rcx+40]
  00025	48 8d 59 10	 lea	 rbx, QWORD PTR [rcx+16]
  00029	48 8b f2	 mov	 rsi, rdx
  0002c	48 8b c1	 mov	 rax, rcx
  0002f	bd 10 00 00 00	 mov	 ebp, 16
  00034	44 39 a1 f4 16
	00 00		 cmp	 DWORD PTR [rcx+5876], r12d
  0003b	0f 84 47 03 00
	00		 je	 $LN30@compress_b
  00041	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00046	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:__ImageBase
  0004d	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00052	4c 89 7c 24 18	 mov	 QWORD PTR [rsp+24], r15
  00057	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL4@compress_b:

; 909  : #ifdef LIT_MEM
; 910  :         dist = s->d_buf[sx];
; 911  :         lc = s->l_buf[sx++];
; 912  : #else
; 913  :         dist = s->sym_buf[sx++] & 0xff;

  00060	4c 8b 80 e8 16
	00 00		 mov	 r8, QWORD PTR [rax+5864]
  00067	4d 8b ea	 mov	 r13, r10
  0006a	48 89 5c 24 60	 mov	 QWORD PTR tv1613[rsp], rbx
  0006f	47 0f b6 0c 04	 movzx	 r9d, BYTE PTR [r12+r8]
  00074	41 ff c4	 inc	 r12d

; 914  :         dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;

  00077	43 0f b6 14 04	 movzx	 edx, BYTE PTR [r12+r8]
  0007c	41 ff c4	 inc	 r12d
  0007f	c1 e2 08	 shl	 edx, 8

; 915  :         lc = s->sym_buf[sx++];

  00082	47 0f b6 34 04	 movzx	 r14d, BYTE PTR [r12+r8]
  00087	41 ff c4	 inc	 r12d

; 916  : #endif
; 917  :         if (dist == 0) {

  0008a	45 8b 03	 mov	 r8d, DWORD PTR [r11]
  0008d	44 03 ca	 add	 r9d, edx
  00090	0f 85 88 00 00
	00		 jne	 $LN6@compress_b

; 918  :             send_code(s, lc, ltree); /* send a literal byte */

  00096	46 0f b7 0c b6	 movzx	 r9d, WORD PTR [rsi+r14*4]
  0009b	41 8b c8	 mov	 ecx, r8d
  0009e	46 0f b7 54 b6
	02		 movzx	 r10d, WORD PTR [rsi+r14*4+2]
  000a4	41 0f b7 d1	 movzx	 edx, r9w
  000a8	66 d3 e2	 shl	 dx, cl
  000ab	8b cd		 mov	 ecx, ebp
  000ad	66 0b 90 0c 17
	00 00		 or	 dx, WORD PTR [rax+5900]
  000b4	41 2b ca	 sub	 ecx, r10d
  000b7	44 3b c1	 cmp	 r8d, ecx
  000ba	7e 43		 jle	 SHORT $LN8@compress_b
  000bc	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000c0	44 0f b7 c2	 movzx	 r8d, dx
  000c4	66 89 90 0c 17
	00 00		 mov	 WORD PTR [rax+5900], dx
  000cb	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  000ce	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  000d2	ff 40 28	 inc	 DWORD PTR [rax+40]
  000d5	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  000d9	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000dd	0f b6 88 0d 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5901]
  000e4	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  000e8	8b cd		 mov	 ecx, ebp
  000ea	41 8b 13	 mov	 edx, DWORD PTR [r11]
  000ed	2a ca		 sub	 cl, dl
  000ef	ff 40 28	 inc	 DWORD PTR [rax+40]
  000f2	44 8d 42 f0	 lea	 r8d, DWORD PTR [rdx-16]
  000f6	45 03 c2	 add	 r8d, r10d
  000f9	66 41 d3 e9	 shr	 r9w, cl
  000fd	eb 07		 jmp	 SHORT $LN9@compress_b
$LN8@compress_b:
  000ff	45 03 c2	 add	 r8d, r10d
  00102	44 0f b7 ca	 movzx	 r9d, dx
$LN9@compress_b:

; 919  :             Tracecv(isgraph(lc), (stderr," '%c' ", lc));
; 920  :         } else {

  00106	66 44 89 88 0c
	17 00 00	 mov	 WORD PTR [rax+5900], r9w
  0010e	4c 8d 50 28	 lea	 r10, QWORD PTR [rax+40]
  00112	45 89 03	 mov	 DWORD PTR [r11], r8d
  00115	48 8d 58 10	 lea	 rbx, QWORD PTR [rax+16]
  00119	e9 4e 02 00 00	 jmp	 $LN2@compress_b
$LN6@compress_b:

; 921  :             /* Here, lc is the match length - MIN_MATCH */
; 922  :             code = _length_code[lc];

  0011e	45 0f b6 bc 3e
	00 00 00 00	 movzx	 r15d, BYTE PTR _length_code[r14+rdi]

; 923  :             send_code(s, code + LITERALS + 1, ltree);   /* send length code */

  00127	41 8d 8f 01 01
	00 00		 lea	 ecx, DWORD PTR [r15+257]
  0012e	0f b7 7c 8e 02	 movzx	 edi, WORD PTR [rsi+rcx*4+2]
  00133	0f b7 34 8e	 movzx	 esi, WORD PTR [rsi+rcx*4]
  00137	41 8b c8	 mov	 ecx, r8d
  0013a	0f b7 d6	 movzx	 edx, si
  0013d	66 d3 e2	 shl	 dx, cl
  00140	8b cd		 mov	 ecx, ebp
  00142	66 0b 90 0c 17
	00 00		 or	 dx, WORD PTR [rax+5900]
  00149	2b cf		 sub	 ecx, edi
  0014b	44 3b c1	 cmp	 r8d, ecx
  0014e	7e 3f		 jle	 SHORT $LN10@compress_b
  00150	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00153	44 0f b7 c2	 movzx	 r8d, dx
  00157	66 89 90 0c 17
	00 00		 mov	 WORD PTR [rax+5900], dx
  0015e	41 8b 12	 mov	 edx, DWORD PTR [r10]
  00161	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  00165	41 ff 02	 inc	 DWORD PTR [r10]
  00168	45 8b 02	 mov	 r8d, DWORD PTR [r10]
  0016b	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  0016e	0f b6 88 0d 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5901]
  00175	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  00179	8b cd		 mov	 ecx, ebp
  0017b	41 8b 13	 mov	 edx, DWORD PTR [r11]
  0017e	2a ca		 sub	 cl, dl
  00180	41 ff 02	 inc	 DWORD PTR [r10]
  00183	44 8d 42 f0	 lea	 r8d, DWORD PTR [rdx-16]
  00187	44 03 c7	 add	 r8d, edi
  0018a	66 d3 ee	 shr	 si, cl
  0018d	eb 06		 jmp	 SHORT $LN11@compress_b
$LN10@compress_b:
  0018f	44 03 c7	 add	 r8d, edi
  00192	0f b7 f2	 movzx	 esi, dx
$LN11@compress_b:

; 924  :             extra = extra_lbits[code];

  00195	49 8b cf	 mov	 rcx, r15
  00198	66 89 b0 0c 17
	00 00		 mov	 WORD PTR [rax+5900], si
  0019f	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:__ImageBase
  001a6	45 89 03	 mov	 DWORD PTR [r11], r8d
  001a9	41 8b bc 8f 00
	00 00 00	 mov	 edi, DWORD PTR extra_lbits[r15+rcx*4]

; 925  :             if (extra != 0) {

  001b1	85 ff		 test	 edi, edi
  001b3	74 66		 je	 SHORT $LN14@compress_b

; 926  :                 lc -= base_length[code];

  001b5	66 45 2b b4 8f
	00 00 00 00	 sub	 r14w, WORD PTR base_length[r15+rcx*4]

; 927  :                 send_bits(s, lc, extra);       /* send the extra length bits */

  001be	41 8b c8	 mov	 ecx, r8d
  001c1	41 0f b7 d6	 movzx	 edx, r14w
  001c5	66 d3 e2	 shl	 dx, cl
  001c8	8b cd		 mov	 ecx, ebp
  001ca	66 0b f2	 or	 si, dx
  001cd	2b cf		 sub	 ecx, edi
  001cf	66 89 b0 0c 17
	00 00		 mov	 WORD PTR [rax+5900], si
  001d6	44 3b c1	 cmp	 r8d, ecx
  001d9	7e 3a		 jle	 SHORT $LN13@compress_b
  001db	41 8b 12	 mov	 edx, DWORD PTR [r10]
  001de	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  001e1	40 88 34 0a	 mov	 BYTE PTR [rdx+rcx], sil
  001e5	41 0f b7 f6	 movzx	 esi, r14w
  001e9	41 ff 02	 inc	 DWORD PTR [r10]
  001ec	45 8b 02	 mov	 r8d, DWORD PTR [r10]
  001ef	0f b6 88 0d 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5901]
  001f6	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  001f9	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  001fd	8b cd		 mov	 ecx, ebp
  001ff	41 8b 13	 mov	 edx, DWORD PTR [r11]
  00202	2a ca		 sub	 cl, dl
  00204	41 ff 02	 inc	 DWORD PTR [r10]
  00207	66 d3 ee	 shr	 si, cl
  0020a	66 89 b0 0c 17
	00 00		 mov	 WORD PTR [rax+5900], si
  00211	44 8d 42 f0	 lea	 r8d, DWORD PTR [rdx-16]
$LN13@compress_b:

; 928  :             }
; 929  :             dist--; /* dist is now the match distance - 1 */

  00215	44 03 c7	 add	 r8d, edi
  00218	45 89 03	 mov	 DWORD PTR [r11], r8d
$LN14@compress_b:
  0021b	41 ff c9	 dec	 r9d

; 930  :             code = d_code(dist);

  0021e	41 8b c9	 mov	 ecx, r9d
  00221	41 81 f9 00 01
	00 00		 cmp	 r9d, 256		; 00000100H
  00228	72 09		 jb	 SHORT $LN24@compress_b
  0022a	c1 e9 07	 shr	 ecx, 7
  0022d	81 c1 00 01 00
	00		 add	 ecx, 256		; 00000100H
$LN24@compress_b:

; 931  :             Assert (code < D_CODES, "bad d_code");
; 932  : 
; 933  :             send_code(s, code, dtree);       /* send the distance code */

  00233	8b d1		 mov	 edx, ecx
  00235	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dtree$[rsp]
  0023a	42 0f b6 94 3a
	00 00 00 00	 movzx	 edx, BYTE PTR _dist_code[rdx+r15]
  00243	4c 8d 3c 95 00
	00 00 00	 lea	 r15, QWORD PTR [rdx*4]
  0024b	8b d5		 mov	 edx, ebp
  0024d	45 0f b7 74 0f
	02		 movzx	 r14d, WORD PTR [r15+rcx+2]
  00253	41 0f b7 3c 0f	 movzx	 edi, WORD PTR [r15+rcx]
  00258	41 2b d6	 sub	 edx, r14d
  0025b	41 8b c8	 mov	 ecx, r8d
  0025e	44 3b c2	 cmp	 r8d, edx
  00261	7e 48		 jle	 SHORT $LN15@compress_b
  00263	41 8b 12	 mov	 edx, DWORD PTR [r10]
  00266	44 0f b7 c7	 movzx	 r8d, di
  0026a	66 41 d3 e0	 shl	 r8w, cl
  0026e	41 83 c6 f0	 add	 r14d, -16
  00272	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00275	66 44 0b c6	 or	 r8w, si
  00279	66 44 89 80 0c
	17 00 00	 mov	 WORD PTR [rax+5900], r8w
  00281	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  00285	41 ff 02	 inc	 DWORD PTR [r10]
  00288	45 8b 02	 mov	 r8d, DWORD PTR [r10]
  0028b	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  0028e	0f b6 88 0d 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5901]
  00295	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  00299	8b cd		 mov	 ecx, ebp
  0029b	41 8b 13	 mov	 edx, DWORD PTR [r11]
  0029e	44 03 f2	 add	 r14d, edx
  002a1	41 ff 02	 inc	 DWORD PTR [r10]
  002a4	2a ca		 sub	 cl, dl
  002a6	66 d3 ef	 shr	 di, cl
  002a9	eb 11		 jmp	 SHORT $LN16@compress_b
$LN15@compress_b:
  002ab	45 03 f0	 add	 r14d, r8d
  002ae	66 d3 e7	 shl	 di, cl
  002b1	66 0b fe	 or	 di, si
  002b4	4c 8d 50 28	 lea	 r10, QWORD PTR [rax+40]
  002b8	48 8d 58 10	 lea	 rbx, QWORD PTR [rax+16]
$LN16@compress_b:

; 934  :             extra = extra_dbits[code];

  002bc	66 89 b8 0c 17
	00 00		 mov	 WORD PTR [rax+5900], di
  002c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  002ca	45 89 33	 mov	 DWORD PTR [r11], r14d
  002cd	41 8b b4 0f 00
	00 00 00	 mov	 esi, DWORD PTR extra_dbits[r15+rcx]

; 935  :             if (extra != 0) {

  002d5	85 f6		 test	 esi, esi
  002d7	0f 84 83 00 00
	00		 je	 $LN31@compress_b

; 936  :                 dist -= (unsigned)base_dist[code];

  002dd	66 45 2b 8c 0f
	00 00 00 00	 sub	 r9w, WORD PTR base_dist[r15+rcx]

; 937  :                 send_bits(s, dist, extra);   /* send the extra distance bits */

  002e6	41 8b ce	 mov	 ecx, r14d
  002e9	45 0f b7 c1	 movzx	 r8d, r9w
  002ed	66 41 d3 e0	 shl	 r8w, cl
  002f1	8b cd		 mov	 ecx, ebp
  002f3	66 44 0b c7	 or	 r8w, di
  002f7	2b ce		 sub	 ecx, esi
  002f9	66 44 89 80 0c
	17 00 00	 mov	 WORD PTR [rax+5900], r8w
  00301	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:__ImageBase
  00308	44 3b f1	 cmp	 r14d, ecx
  0030b	7e 4a		 jle	 SHORT $LN18@compress_b
  0030d	41 8b 55 00	 mov	 edx, DWORD PTR [r13]
  00311	4d 8b d5	 mov	 r10, r13
  00314	48 8b 5c 24 60	 mov	 rbx, QWORD PTR tv1613[rsp]
  00319	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0031c	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  00320	41 ff 45 00	 inc	 DWORD PTR [r13]
  00324	0f b6 88 0d 17
	00 00		 movzx	 ecx, BYTE PTR [rax+5901]
  0032b	45 8b 45 00	 mov	 r8d, DWORD PTR [r13]
  0032f	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00332	41 88 0c 10	 mov	 BYTE PTR [r8+rdx], cl
  00336	8b cd		 mov	 ecx, ebp
  00338	41 8b 13	 mov	 edx, DWORD PTR [r11]
  0033b	2a ca		 sub	 cl, dl
  0033d	41 ff 45 00	 inc	 DWORD PTR [r13]
  00341	66 41 d3 e9	 shr	 r9w, cl
  00345	66 44 89 88 0c
	17 00 00	 mov	 WORD PTR [rax+5900], r9w
  0034d	8d 4a f0	 lea	 ecx, DWORD PTR [rdx-16]
  00350	03 ce		 add	 ecx, esi
  00352	41 89 0b	 mov	 DWORD PTR [r11], ecx
  00355	eb 10		 jmp	 SHORT $LN43@compress_b
$LN18@compress_b:
  00357	41 8d 0c 36	 lea	 ecx, DWORD PTR [r14+rsi]
  0035b	41 89 0b	 mov	 DWORD PTR [r11], ecx
  0035e	eb 07		 jmp	 SHORT $LN43@compress_b
$LN31@compress_b:

; 935  :             if (extra != 0) {

  00360	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:__ImageBase
$LN43@compress_b:

; 938  :             }
; 939  :         } /* literal or match pair ? */
; 940  : 
; 941  :         /* Check for no overlay of pending_buf on needed symbols */
; 942  : #ifdef LIT_MEM
; 943  :         Assert(s->pending < 2 * (s->lit_bufsize + sx), "pendingBuf overflow");
; 944  : #else
; 945  :         Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");
; 946  : #endif
; 947  : 
; 948  :     } while (sx < s->sym_next);

  00367	48 8b 74 24 68	 mov	 rsi, QWORD PTR ltree$[rsp]
$LN2@compress_b:
  0036c	44 3b a0 f4 16
	00 00		 cmp	 r12d, DWORD PTR [rax+5876]
  00373	0f 82 e7 fc ff
	ff		 jb	 $LL4@compress_b
  00379	4c 8b 7c 24 18	 mov	 r15, QWORD PTR [rsp+24]
  0037e	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  00383	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]
$LN30@compress_b:

; 949  : 
; 950  :     send_code(s, END_BLOCK, ltree);

  00388	45 8b 03	 mov	 r8d, DWORD PTR [r11]
  0038b	41 8b c8	 mov	 ecx, r8d
  0038e	0f b7 b6 02 04
	00 00		 movzx	 esi, WORD PTR [rsi+1026]
  00395	48 8b 7c 24 68	 mov	 rdi, QWORD PTR ltree$[rsp]
  0039a	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]
  0039f	0f b7 bf 00 04
	00 00		 movzx	 edi, WORD PTR [rdi+1024]
  003a6	0f b7 d7	 movzx	 edx, di
  003a9	66 d3 e2	 shl	 dx, cl
  003ac	8b cd		 mov	 ecx, ebp
  003ae	66 0b 90 0c 17
	00 00		 or	 dx, WORD PTR [rax+5900]
  003b5	2b ce		 sub	 ecx, esi
  003b7	66 89 90 0c 17
	00 00		 mov	 WORD PTR [rax+5900], dx
  003be	44 3b c1	 cmp	 r8d, ecx
  003c1	7e 4c		 jle	 SHORT $LN20@compress_b
  003c3	45 8b 02	 mov	 r8d, DWORD PTR [r10]
  003c6	44 0f b7 ca	 movzx	 r9d, dx
  003ca	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  003cd	45 88 0c 10	 mov	 BYTE PTR [r8+rdx], r9b
  003d1	41 ff 02	 inc	 DWORD PTR [r10]
  003d4	45 8b 0a	 mov	 r9d, DWORD PTR [r10]
  003d7	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
  003da	0f b6 90 0d 17
	00 00		 movzx	 edx, BYTE PTR [rax+5901]
  003e1	43 88 14 01	 mov	 BYTE PTR [r9+r8], dl
  003e5	41 8b 13	 mov	 edx, DWORD PTR [r11]
  003e8	40 2a ea	 sub	 bpl, dl
  003eb	41 ff 02	 inc	 DWORD PTR [r10]
  003ee	40 0f b6 cd	 movzx	 ecx, bpl
  003f2	44 8d 42 f0	 lea	 r8d, DWORD PTR [rdx-16]
  003f6	44 03 c6	 add	 r8d, esi
  003f9	66 d3 ef	 shr	 di, cl

; 951  : }

  003fc	66 89 b8 0c 17
	00 00		 mov	 WORD PTR [rax+5900], di
  00403	45 89 03	 mov	 DWORD PTR [r11], r8d
  00406	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0040a	5f		 pop	 rdi
  0040b	5e		 pop	 rsi
  0040c	5d		 pop	 rbp
  0040d	5b		 pop	 rbx
  0040e	c3		 ret	 0
$LN20@compress_b:

; 949  : 
; 950  :     send_code(s, END_BLOCK, ltree);

  0040f	41 8d 0c 30	 lea	 ecx, DWORD PTR [r8+rsi]

; 951  : }

  00413	41 89 0b	 mov	 DWORD PTR [r11], ecx
  00416	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0041a	5f		 pop	 rdi
  0041b	5e		 pop	 rsi
  0041c	5d		 pop	 rbp
  0041d	5b		 pop	 rbx
  0041e	c3		 ret	 0
compress_block ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\trees.c
;	COMDAT detect_data_type
_TEXT	SEGMENT
s$ = 8
detect_data_type PROC					; COMDAT

; 966  : local int detect_data_type(deflate_state *s) {

  00000	4c 8b c9	 mov	 r9, rcx

; 967  :     /* block_mask is the bit mask of block-listed bytes
; 968  :      * set bits 0..6, 14..25, and 28..31
; 969  :      * 0xf3ffc07f = binary 11110011111111111100000001111111
; 970  :      */
; 971  :     unsigned long block_mask = 0xf3ffc07fUL;

  00003	48 8d 81 bc 00
	00 00		 lea	 rax, QWORD PTR [rcx+188]
  0000a	33 d2		 xor	 edx, edx
  0000c	41 b8 7f c0 ff
	f3		 mov	 r8d, -201342849		; f3ffc07fH
$LL4@detect_dat:

; 976  :         if ((block_mask & 1) && (s->dyn_ltree[n].Freq != 0))

  00012	41 f6 c0 01	 test	 r8b, 1
  00016	74 06		 je	 SHORT $LN2@detect_dat
  00018	66 83 38 00	 cmp	 WORD PTR [rax], 0
  0001c	75 50		 jne	 SHORT $LN15@detect_dat
$LN2@detect_dat:

; 972  :     int n;
; 973  : 
; 974  :     /* Check for non-textual ("block-listed") bytes. */
; 975  :     for (n = 0; n <= 31; n++, block_mask >>= 1)

  0001e	48 ff c2	 inc	 rdx
  00021	41 d1 e8	 shr	 r8d, 1
  00024	48 83 c0 04	 add	 rax, 4
  00028	48 83 fa 1f	 cmp	 rdx, 31
  0002c	7e e4		 jle	 SHORT $LL4@detect_dat

; 977  :             return Z_BINARY;
; 978  : 
; 979  :     /* Check for textual ("allow-listed") bytes. */
; 980  :     if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
; 981  :             || s->dyn_ltree[13].Freq != 0)

  0002e	66 83 b9 e0 00
	00 00 00	 cmp	 WORD PTR [rcx+224], 0
  00036	75 39		 jne	 SHORT $LN10@detect_dat
  00038	66 83 b9 e4 00
	00 00 00	 cmp	 WORD PTR [rcx+228], 0
  00040	75 2f		 jne	 SHORT $LN10@detect_dat
  00042	66 83 b9 f0 00
	00 00 00	 cmp	 WORD PTR [rcx+240], 0
  0004a	75 25		 jne	 SHORT $LN10@detect_dat
  0004c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00051	49 8d 81 3c 01
	00 00		 lea	 rax, QWORD PTR [r9+316]
$LL7@detect_dat:

; 984  :         if (s->dyn_ltree[n].Freq != 0)

  00058	66 83 38 00	 cmp	 WORD PTR [rax], 0
  0005c	75 13		 jne	 SHORT $LN10@detect_dat

; 983  :     for (n = 32; n < LITERALS; n++)

  0005e	48 ff c1	 inc	 rcx
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 81 f9 00 01
	00 00		 cmp	 rcx, 256		; 00000100H
  0006c	7c ea		 jl	 SHORT $LL7@detect_dat
$LN15@detect_dat:

; 985  :             return Z_TEXT;
; 986  : 
; 987  :     /* There are no "block-listed" or "allow-listed" bytes:
; 988  :      * this stream either is empty or has tolerated ("gray-listed") bytes only.
; 989  :      */
; 990  :     return Z_BINARY;
; 991  : }

  0006e	33 c0		 xor	 eax, eax
  00070	c3		 ret	 0
$LN10@detect_dat:

; 982  :         return Z_TEXT;

  00071	b8 01 00 00 00	 mov	 eax, 1

; 985  :             return Z_TEXT;
; 986  : 
; 987  :     /* There are no "block-listed" or "allow-listed" bytes:
; 988  :      * this stream either is empty or has tolerated ("gray-listed") bytes only.
; 989  :      */
; 990  :     return Z_BINARY;
; 991  : }

  00076	c3		 ret	 0
detect_data_type ENDP
_TEXT	ENDS
END
