; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35209.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check@	; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check@ DB 'incorrect length check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@ DB 'unknown header flags '
	DB	'set', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method@ DB 'unknown compression '
	DB	'method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check@ DB 'incorrect header check', 00H ; `string'
	ORG $+10
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateCodesUsed
PUBLIC	inflateMark
PUBLIC	inflateValidate
PUBLIC	inflateUndermine
PUBLIC	inflateCopy
PUBLIC	inflateSyncPoint
PUBLIC	inflateSync
PUBLIC	inflateGetHeader
PUBLIC	inflateSetDictionary
PUBLIC	inflateGetDictionary
PUBLIC	inflatePrime
PUBLIC	inflateInit_
PUBLIC	inflateReset2
PUBLIC	inflateResetKeep
PUBLIC	inflateEnd
PUBLIC	inflate
PUBLIC	inflateInit2_
PUBLIC	inflateReset
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCodesUsed DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$inflateCodesUsed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateMark DD imagerel $LN9
	DD	imagerel $LN9+108
	DD	imagerel $unwind$inflateMark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateValidate DD imagerel $LN10
	DD	imagerel $LN10+62
	DD	imagerel $unwind$inflateValidate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateUndermine DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$inflateUndermine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN28
	DD	imagerel $LN28+52
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateCopy DD imagerel $LN28+52
	DD	imagerel $LN28+97
	DD	imagerel $chain$2$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateCopy DD imagerel $LN28+97
	DD	imagerel $LN28+173
	DD	imagerel $chain$4$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateCopy DD imagerel $LN28+173
	DD	imagerel $LN28+195
	DD	imagerel $chain$5$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$inflateCopy DD imagerel $LN28+195
	DD	imagerel $LN28+427
	DD	imagerel $chain$7$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$inflateCopy DD imagerel $LN28+427
	DD	imagerel $LN28+439
	DD	imagerel $chain$8$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSyncPoint DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$inflateSyncPoint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN34
	DD	imagerel $LN34+33
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateSync DD imagerel $LN34+33
	DD	imagerel $LN34+80
	DD	imagerel $chain$1$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateSync DD imagerel $LN34+80
	DD	imagerel $LN34+244
	DD	imagerel $chain$4$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateSync DD imagerel $LN34+244
	DD	imagerel $LN34+310
	DD	imagerel $chain$5$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflateSync DD imagerel $LN34+310
	DD	imagerel $LN34+331
	DD	imagerel $chain$6$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+101
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetHeader DD imagerel $LN8
	DD	imagerel $LN8+51
	DD	imagerel $unwind$inflateGetHeader
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN19
	DD	imagerel $LN19+184
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetDictionary DD imagerel $LN11
	DD	imagerel $LN11+132
	DD	imagerel $unwind$inflateGetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+274
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflatePrime DD imagerel $LN11
	DD	imagerel $LN11+102
	DD	imagerel $unwind$inflatePrime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN22
	DD	imagerel $LN22+155
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateResetKeep DD imagerel $LN6
	DD	imagerel $LN6+145
	DD	imagerel $unwind$inflateResetKeep
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN9
	DD	imagerel $LN9+102
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN1201
	DD	imagerel $LN1201+6168
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN22
	DD	imagerel $LN22+69
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateInit2_ DD imagerel $LN22+69
	DD	imagerel $LN22+177
	DD	imagerel $chain$1$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateInit2_ DD imagerel $LN22+177
	DD	imagerel $LN22+233
	DD	imagerel $chain$3$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateInit2_ DD imagerel $LN22+233
	DD	imagerel $LN22+249
	DD	imagerel $chain$4$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset DD imagerel $LN5
	DD	imagerel $LN5+45
	DD	imagerel $unwind$inflateReset
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateInit2_ DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+69
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateInit2_ DD 040021H
	DD	077400H
	DD	065400H
	DD	imagerel $LN22
	DD	imagerel $LN22+69
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateInit2_ DD 040c21H
	DD	07740cH
	DD	065405H
	DD	imagerel $LN22
	DD	imagerel $LN22+69
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 0a1801H
	DD	0123418H
	DD	0f0149218H
	DD	0d010e012H
	DD	0700cc00eH
	DD	0500a600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 062b01H
	DD	07742bH
	DD	066426H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateResetKeep DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflatePrime DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 0a6a01H
	DD	0af46aH
	DD	097462H
	DD	0b340dH
	DD	0e009320dH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetDictionary DD 062e01H
	DD	06342eH
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetHeader DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflateSync DD 021H
	DD	imagerel $LN34+80
	DD	imagerel $LN34+244
	DD	imagerel $chain$4$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateSync DD 020521H
	DD	04e405H
	DD	imagerel $LN34+80
	DD	imagerel $LN34+244
	DD	imagerel $chain$4$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateSync DD 060c21H
	DD	08340cH
	DD	057400H
	DD	0a5400H
	DD	imagerel $LN34
	DD	imagerel $LN34+33
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateSync DD 040e21H
	DD	05740eH
	DD	0a5405H
	DD	imagerel $LN34
	DD	imagerel $LN34+33
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSyncPoint DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$inflateCopy DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+52
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$inflateCopy DD 0a0021H
	DD	04f400H
	DD	0be400H
	DD	0ac400H
	DD	096400H
	DD	083400H
	DD	imagerel $LN28
	DD	imagerel $LN28+52
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateCopy DD 021H
	DD	imagerel $LN28+52
	DD	imagerel $LN28+97
	DD	imagerel $chain$2$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateCopy DD 040a21H
	DD	0be40aH
	DD	0ac405H
	DD	imagerel $LN28+52
	DD	imagerel $LN28+97
	DD	imagerel $chain$2$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateCopy DD 061321H
	DD	04f413H
	DD	09640aH
	DD	083405H
	DD	imagerel $LN28
	DD	imagerel $LN28+52
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 030701H
	DD	070034207H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateUndermine DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateValidate DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateMark DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCodesUsed DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateReset
_TEXT	SEGMENT
strm$ = 48
inflateReset PROC					; COMDAT

; 130  : int ZEXPORT inflateReset(z_streamp strm) {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 131  :     struct inflate_state FAR *state;
; 132  : 
; 133  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateRes
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 139  : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateRes:

; 134  :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 135  :     state->wsize = 0;

  0001b	33 d2		 xor	 edx, edx
  0001d	48 89 50 34	 mov	 QWORD PTR [rax+52], rdx

; 136  :     state->whave = 0;
; 137  :     state->wnext = 0;

  00021	89 50 3c	 mov	 DWORD PTR [rax+60], edx

; 139  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 138  :     return inflateResetKeep(strm);

  00028	e9 00 00 00 00	 jmp	 inflateResetKeep
inflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateInit2_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
version$ = 64
stream_size$ = 72
inflateInit2_ PROC					; COMDAT

; 179  :                           const char *version, int stream_size) {

$LN22:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b f2		 mov	 esi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 180  :     int ret;
; 181  :     struct inflate_state FAR *state;
; 182  : 
; 183  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  0000f	4d 85 c0	 test	 r8, r8
  00012	0f 84 d1 00 00
	00		 je	 $LN3@inflateIni
  00018	41 80 38 31	 cmp	 BYTE PTR [r8], 49	; 00000031H
  0001c	0f 85 c7 00 00
	00		 jne	 $LN3@inflateIni
  00022	41 83 f9 58	 cmp	 r9d, 88			; 00000058H
  00026	0f 85 bd 00 00
	00		 jne	 $LN3@inflateIni

; 184  :         stream_size != (int)(sizeof(z_stream)))
; 185  :         return Z_VERSION_ERROR;
; 186  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002c	48 85 c9	 test	 rcx, rcx
  0002f	75 10		 jne	 SHORT $LN4@inflateIni
  00031	b8 fe ff ff ff	 mov	 eax, -2

; 216  : }

  00036	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5e		 pop	 rsi
  00040	c3		 ret	 0
$LN4@inflateIni:

; 187  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 188  :     if (strm->zalloc == (alloc_func)0) {

  00041	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00045	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0004a	33 ed		 xor	 ebp, ebp
  0004c	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00051	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp
  00055	48 85 c0	 test	 rax, rax
  00058	75 13		 jne	 SHORT $LN10@inflateIni

; 189  : #ifdef Z_SOLO
; 190  :         return Z_STREAM_ERROR;
; 191  : #else
; 192  :         strm->zalloc = zcalloc;

  0005a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 193  :         strm->opaque = (voidpf)0;

  00061	48 89 69 40	 mov	 QWORD PTR [rcx+64], rbp
  00065	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
  00069	8b cd		 mov	 ecx, ebp
  0006b	eb 04		 jmp	 SHORT $LN5@inflateIni
$LN10@inflateIni:
  0006d	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
$LN5@inflateIni:

; 194  : #endif
; 195  :     }
; 196  :     if (strm->zfree == (free_func)0)

  00071	48 39 6b 38	 cmp	 QWORD PTR [rbx+56], rbp
  00075	75 0b		 jne	 SHORT $LN6@inflateIni

; 197  : #ifdef Z_SOLO
; 198  :         return Z_STREAM_ERROR;
; 199  : #else
; 200  :         strm->zfree = zcfree;

  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:zcfree
  0007e	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
$LN6@inflateIni:

; 201  : #endif
; 202  :     state = (struct inflate_state FAR *)

  00082	ba 01 00 00 00	 mov	 edx, 1
  00087	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  0008d	ff d0		 call	 rax
  0008f	48 8b f8	 mov	 rdi, rax

; 203  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 204  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00092	48 85 c0	 test	 rax, rax
  00095	75 1a		 jne	 SHORT $LN7@inflateIni
  00097	b8 fc ff ff ff	 mov	 eax, -4
$LN20@inflateIni:
  0009c	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  000a1	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 216  : }

  000a6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ab	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000af	5e		 pop	 rsi
  000b0	c3		 ret	 0
$LN7@inflateIni:

; 205  :     Tracev((stderr, "inflate: allocated\n"));
; 206  :     strm->state = (struct internal_state FAR *)state;

  000b1	48 89 7b 28	 mov	 QWORD PTR [rbx+40], rdi

; 207  :     state->strm = strm;
; 208  :     state->window = Z_NULL;
; 209  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 210  :     ret = inflateReset2(strm, windowBits);

  000b5	8b d6		 mov	 edx, esi
  000b7	48 8b cb	 mov	 rcx, rbx
  000ba	48 89 18	 mov	 QWORD PTR [rax], rbx
  000bd	48 89 68 40	 mov	 QWORD PTR [rax+64], rbp
  000c1	c7 40 08 34 3f
	00 00		 mov	 DWORD PTR [rax+8], 16180 ; 00003f34H
  000c8	e8 00 00 00 00	 call	 inflateReset2
  000cd	8b f0		 mov	 esi, eax

; 211  :     if (ret != Z_OK) {

  000cf	85 c0		 test	 eax, eax
  000d1	74 12		 je	 SHORT $LN8@inflateIni

; 212  :         ZFREE(strm, state);

  000d3	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  000d7	48 8b d7	 mov	 rdx, rdi
  000da	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000de	41 ff d0	 call	 r8

; 213  :         strm->state = Z_NULL;

  000e1	48 89 6b 28	 mov	 QWORD PTR [rbx+40], rbp
$LN8@inflateIni:

; 214  :     }
; 215  :     return ret;

  000e5	8b c6		 mov	 eax, esi
  000e7	eb b3		 jmp	 SHORT $LN20@inflateIni
$LN3@inflateIni:

; 216  : }

  000e9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ee	b8 fa ff ff ff	 mov	 eax, -6
  000f3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f7	5e		 pop	 rsi
  000f8	c3		 ret	 0
inflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflate
_TEXT	SEGMENT
left$1$ = 48
hbuf$ = 52
here$ = 56
last$ = 56
in$1$ = 60
put$1$ = 64
$T1 = 72
strm$ = 144
flush$ = 152
out$1$ = 160
ret$1$ = 168
inflate	PROC						; COMDAT

; 590  : int ZEXPORT inflate(z_streamp strm, int flush) {

$LN1201:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	55		 push	 rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00018	8b fa		 mov	 edi, edx
  0001a	4c 8b e1	 mov	 r12, rcx

; 591  :     struct inflate_state FAR *state;
; 592  :     z_const unsigned char FAR *next;    /* next input */
; 593  :     unsigned char FAR *put;     /* next output */
; 594  :     unsigned have, left;        /* available input and output */
; 595  :     unsigned long hold;         /* bit buffer */
; 596  :     unsigned bits;              /* bits in bit buffer */
; 597  :     unsigned in, out;           /* save starting available input and output */
; 598  :     unsigned copy;              /* number of stored or match bytes to copy */
; 599  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 600  :     code here;                  /* current decoding table entry */
; 601  :     code last;                  /* parent table entry */
; 602  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 603  :     int ret;                    /* return code */
; 604  : #ifdef GUNZIP
; 605  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 606  : #endif
; 607  :     static const unsigned short order[19] = /* permutation of code lengths */
; 608  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 609  : 
; 610  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  0001d	e8 00 00 00 00	 call	 inflateStateCheck
  00022	85 c0		 test	 eax, eax
  00024	0f 85 4e 17 00
	00		 jne	 $LN333@inflate
  0002a	48 83 79 10 00	 cmp	 QWORD PTR [rcx+16], 0
  0002f	48 8d 41 10	 lea	 rax, QWORD PTR [rcx+16]
  00033	0f 84 3f 17 00
	00		 je	 $LN333@inflate
  00039	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0003d	75 10		 jne	 SHORT $LN789@inflate
  0003f	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00043	0f 85 2f 17 00
	00		 jne	 $LN333@inflate
  00049	48 8d 51 10	 lea	 rdx, QWORD PTR [rcx+16]
  0004d	eb 03		 jmp	 SHORT $LN694@inflate
$LN789@inflate:
  0004f	48 8b d0	 mov	 rdx, rax
$LN694@inflate:

; 613  : 
; 614  :     state = (struct inflate_state FAR *)strm->state;

  00052	4c 8b 69 28	 mov	 r13, QWORD PTR [rcx+40]

; 615  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00056	48 89 44 24 48	 mov	 QWORD PTR $T1[rsp], rax
  0005b	41 8b 4d 08	 mov	 ecx, DWORD PTR [r13+8]
  0005f	81 f9 3f 3f 00
	00		 cmp	 ecx, 16191		; 00003f3fH
  00065	75 12		 jne	 SHORT $LN4@inflate
  00067	41 c7 45 08 40
	3f 00 00	 mov	 DWORD PTR [r13+8], 16192 ; 00003f40H
  0006f	b9 40 3f 00 00	 mov	 ecx, 16192		; 00003f40H
  00074	48 89 54 24 48	 mov	 QWORD PTR $T1[rsp], rdx
$LN4@inflate:

; 616  :     LOAD();

  00079	45 8b 54 24 18	 mov	 r10d, DWORD PTR [r12+24]

; 617  :     in = have;
; 618  :     out = left;
; 619  :     ret = Z_OK;

  0007e	45 33 ff	 xor	 r15d, r15d
  00081	4c 8b 08	 mov	 r9, QWORD PTR [rax]

; 620  :     for (;;)
; 621  :         switch (state->mode) {

  00084	81 c1 cc c0 ff
	ff		 add	 ecx, -16180		; ffffffffffffc0ccH
  0008a	41 8b 74 24 08	 mov	 esi, DWORD PTR [r12+8]
  0008f	45 8b c2	 mov	 r8d, r10d
  00092	49 8b 2c 24	 mov	 rbp, QWORD PTR [r12]
  00096	45 8b 75 48	 mov	 r14d, DWORD PTR [r13+72]
  0009a	41 8b 5d 4c	 mov	 ebx, DWORD PTR [r13+76]
  0009e	4c 89 4c 24 40	 mov	 QWORD PTR put$1$[rsp], r9
  000a3	44 89 54 24 30	 mov	 DWORD PTR left$1$[rsp], r10d
  000a8	89 74 24 3c	 mov	 DWORD PTR in$1$[rsp], esi
  000ac	44 89 94 24 a0
	00 00 00	 mov	 DWORD PTR out$1$[rsp], r10d
  000b4	44 89 bc 24 a8
	00 00 00	 mov	 DWORD PTR ret$1$[rsp], r15d
  000bc	83 f9 1f	 cmp	 ecx, 31
  000bf	0f 87 b3 16 00
	00		 ja	 $LN333@inflate
$LN1197@inflate:
  000c5	48 63 c1	 movsxd	 rax, ecx
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  000cf	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method@
  000d6	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN881@inflate[rdx+rax*4]
  000dd	48 03 ca	 add	 rcx, rdx
  000e0	ff e1		 jmp	 rcx
$LN335@inflate:

; 622  :         case HEAD:
; 623  :             if (state->wrap == 0) {

  000e2	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  000e7	75 0d		 jne	 SHORT $LN12@inflate

; 624  :                 state->mode = TYPEDO;

  000e9	41 c7 45 08 40
	3f 00 00	 mov	 DWORD PTR [r13+8], 16192 ; 00003f40H

; 625  :                 break;

  000f1	e9 8f 06 00 00	 jmp	 $LN5@inflate
$LN12@inflate:

; 626  :             }
; 627  :             NEEDBITS(16);

  000f6	83 fb 10	 cmp	 ebx, 16
  000f9	73 25		 jae	 SHORT $LN10@inflate
  000fb	0f 1f 44 00 00	 npad	 5
$LL13@inflate:
  00100	85 f6		 test	 esi, esi
  00102	0f 84 e7 07 00
	00		 je	 $LN999@inflate
  00108	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  0010c	8b cb		 mov	 ecx, ebx
  0010e	d3 e0		 shl	 eax, cl
  00110	ff ce		 dec	 esi
  00112	44 03 f0	 add	 r14d, eax
  00115	48 ff c5	 inc	 rbp
  00118	83 c3 08	 add	 ebx, 8
  0011b	83 fb 10	 cmp	 ebx, 16
  0011e	72 e0		 jb	 SHORT $LL13@inflate
$LN10@inflate:

; 628  : #ifdef GUNZIP
; 629  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00120	41 f6 45 10 02	 test	 BYTE PTR [r13+16], 2
  00125	74 58		 je	 SHORT $LN338@inflate
  00127	41 81 fe 1f 8b
	00 00		 cmp	 r14d, 35615		; 00008b1fH
  0012e	75 4f		 jne	 SHORT $LN338@inflate

; 630  :                 if (state->wbits == 0)

  00130	41 83 7d 30 00	 cmp	 DWORD PTR [r13+48], 0
  00135	75 08		 jne	 SHORT $LN339@inflate

; 631  :                     state->wbits = 15;

  00137	41 c7 45 30 0f
	00 00 00	 mov	 DWORD PTR [r13+48], 15
$LN339@inflate:

; 632  :                 state->check = crc32(0L, Z_NULL, 0);

  0013f	45 33 c0	 xor	 r8d, r8d
  00142	33 d2		 xor	 edx, edx
  00144	33 c9		 xor	 ecx, ecx
  00146	e8 00 00 00 00	 call	 crc32

; 633  :                 CRC2(state->check, hold);

  0014b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00151	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00155	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0015a	66 c7 44 24 34
	1f 8b		 mov	 WORD PTR hbuf$[rsp], 35615 ; 00008b1fH
  00161	8b c8		 mov	 ecx, eax
  00163	e8 00 00 00 00	 call	 crc32
  00168	41 89 45 20	 mov	 DWORD PTR [r13+32], eax

; 634  :                 INITBITS();

  0016c	45 8b f7	 mov	 r14d, r15d
  0016f	41 8b df	 mov	 ebx, r15d

; 635  :                 state->mode = FLAGS;

  00172	41 c7 45 08 35
	3f 00 00	 mov	 DWORD PTR [r13+8], 16181 ; 00003f35H

; 636  :                 break;

  0017a	e9 fc 05 00 00	 jmp	 $LN1196@inflate
$LN338@inflate:

; 637  :             }
; 638  :             if (state->head != Z_NULL)

  0017f	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00183	48 85 c0	 test	 rax, rax
  00186	74 07		 je	 SHORT $LN340@inflate

; 639  :                 state->head->done = -1;

  00188	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN340@inflate:

; 640  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  0018f	41 f6 45 10 01	 test	 BYTE PTR [r13+16], 1
  00194	0f 84 cc 00 00
	00		 je	 $LN342@inflate
  0019a	41 8b c6	 mov	 eax, r14d
  0019d	41 0f b6 ce	 movzx	 ecx, r14b
  001a1	c1 e8 08	 shr	 eax, 8
  001a4	c1 e1 08	 shl	 ecx, 8
  001a7	03 c8		 add	 ecx, eax
  001a9	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  001ae	f7 e1		 mul	 ecx
  001b0	8b c1		 mov	 eax, ecx
  001b2	2b c2		 sub	 eax, edx
  001b4	d1 e8		 shr	 eax, 1
  001b6	03 c2		 add	 eax, edx
  001b8	c1 e8 04	 shr	 eax, 4
  001bb	6b c0 1f	 imul	 eax, eax, 31
  001be	3b c8		 cmp	 ecx, eax
  001c0	0f 85 a0 00 00
	00		 jne	 $LN342@inflate

; 648  :             }
; 649  :             if (BITS(4) != Z_DEFLATED) {

  001c6	41 8b c6	 mov	 eax, r14d
  001c9	24 0f		 and	 al, 15
  001cb	3c 08		 cmp	 al, 8
  001cd	74 12		 je	 SHORT $LN26@inflate

; 650  :                 strm->msg = (z_const char *)"unknown compression method";

  001cf	4d 89 5c 24 20	 mov	 QWORD PTR [r12+32], r11

; 651  :                 state->mode = BAD;

  001d4	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 652  :                 break;

  001dc	e9 a4 05 00 00	 jmp	 $LN5@inflate
$LN26@inflate:

; 653  :             }
; 654  :             DROPBITS(4);
; 655  :             len = BITS(4) + 8;
; 656  :             if (state->wbits == 0)

  001e1	41 8b 45 30	 mov	 eax, DWORD PTR [r13+48]
  001e5	83 c3 fc	 add	 ebx, -4			; fffffffcH
  001e8	41 c1 ee 04	 shr	 r14d, 4
  001ec	41 8b ce	 mov	 ecx, r14d
  001ef	83 e1 0f	 and	 ecx, 15
  001f2	83 c1 08	 add	 ecx, 8
  001f5	85 c0		 test	 eax, eax
  001f7	75 06		 jne	 SHORT $LN344@inflate

; 657  :                 state->wbits = len;

  001f9	41 89 4d 30	 mov	 DWORD PTR [r13+48], ecx
  001fd	8b c1		 mov	 eax, ecx
$LN344@inflate:

; 658  :             if (len > 15 || len > state->wbits) {

  001ff	83 f9 0f	 cmp	 ecx, 15
  00202	77 49		 ja	 SHORT $LN346@inflate
  00204	3b c8		 cmp	 ecx, eax
  00206	77 45		 ja	 SHORT $LN346@inflate

; 662  :             }
; 663  :             state->dmax = 1U << len;

  00208	b8 01 00 00 00	 mov	 eax, 1

; 664  :             state->flags = 0;               /* indicate zlib header */

  0020d	45 89 7d 18	 mov	 DWORD PTR [r13+24], r15d
  00211	d3 e0		 shl	 eax, cl

; 665  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 666  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00213	45 33 c0	 xor	 r8d, r8d
  00216	33 c9		 xor	 ecx, ecx
  00218	41 89 45 1c	 mov	 DWORD PTR [r13+28], eax
  0021c	33 d2		 xor	 edx, edx
  0021e	e8 00 00 00 00	 call	 adler32

; 667  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00223	41 c1 ee 08	 shr	 r14d, 8

; 668  :             INITBITS();

  00227	41 8b df	 mov	 ebx, r15d
  0022a	41 f7 d6	 not	 r14d
  0022d	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00231	41 83 e6 02	 and	 r14d, 2
  00235	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
  0023a	41 81 ce 3d 3f
	00 00		 or	 r14d, 16189		; 00003f3dH
  00241	45 89 75 08	 mov	 DWORD PTR [r13+8], r14d
  00245	45 8b f7	 mov	 r14d, r15d

; 669  :             break;

  00248	e9 2e 05 00 00	 jmp	 $LN1196@inflate
$LN346@inflate:

; 659  :                 strm->msg = (z_const char *)"invalid window size";

  0024d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size@
  00254	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 660  :                 state->mode = BAD;

  00259	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 661  :                 break;

  00261	e9 1f 05 00 00	 jmp	 $LN5@inflate
$LN342@inflate:

; 641  : #else
; 642  :             if (
; 643  : #endif
; 644  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 645  :                 strm->msg = (z_const char *)"incorrect header check";

  00266	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check@
  0026d	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 646  :                 state->mode = BAD;

  00272	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 647  :                 break;

  0027a	e9 06 05 00 00	 jmp	 $LN5@inflate
$LN32@inflate:

; 670  : #ifdef GUNZIP
; 671  :         case FLAGS:
; 672  :             NEEDBITS(16);

  0027f	83 fb 10	 cmp	 ebx, 16
  00282	73 20		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00284	85 f6		 test	 esi, esi
  00286	0f 84 63 06 00
	00		 je	 $LN999@inflate
  0028c	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00290	8b cb		 mov	 ecx, ebx
  00292	d3 e0		 shl	 eax, cl
  00294	ff ce		 dec	 esi
  00296	44 03 f0	 add	 r14d, eax
  00299	48 ff c5	 inc	 rbp
  0029c	83 c3 08	 add	 ebx, 8
  0029f	83 fb 10	 cmp	 ebx, 16
  002a2	72 e0		 jb	 SHORT $LL33@inflate
$LN30@inflate:

; 673  :             state->flags = (int)(hold);

  002a4	45 89 75 18	 mov	 DWORD PTR [r13+24], r14d

; 674  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  002a8	41 80 fe 08	 cmp	 r14b, 8
  002ac	74 12		 je	 SHORT $LN349@inflate

; 675  :                 strm->msg = (z_const char *)"unknown compression method";

  002ae	4d 89 5c 24 20	 mov	 QWORD PTR [r12+32], r11

; 676  :                 state->mode = BAD;

  002b3	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 677  :                 break;

  002bb	e9 c5 04 00 00	 jmp	 $LN5@inflate
$LN349@inflate:

; 678  :             }
; 679  :             if (state->flags & 0xe000) {

  002c0	41 f7 c6 00 e0
	00 00		 test	 r14d, 57344		; 0000e000H
  002c7	74 19		 je	 SHORT $LN350@inflate

; 680  :                 strm->msg = (z_const char *)"unknown header flags set";

  002c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set@
  002d0	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 681  :                 state->mode = BAD;

  002d5	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 682  :                 break;

  002dd	e9 a3 04 00 00	 jmp	 $LN5@inflate
$LN350@inflate:

; 683  :             }
; 684  :             if (state->head != Z_NULL)

  002e2	49 8b 4d 28	 mov	 rcx, QWORD PTR [r13+40]
  002e6	48 85 c9	 test	 rcx, rcx
  002e9	74 0b		 je	 SHORT $LN790@inflate

; 685  :                 state->head->text = (int)((hold >> 8) & 1);

  002eb	41 8b c6	 mov	 eax, r14d
  002ee	c1 e8 08	 shr	 eax, 8
  002f1	83 e0 01	 and	 eax, 1
  002f4	89 01		 mov	 DWORD PTR [rcx], eax
$LN790@inflate:

; 686  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002f6	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  002fe	74 2d		 je	 SHORT $LN39@inflate
  00300	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00305	74 26		 je	 SHORT $LN39@inflate

; 687  :                 CRC2(state->check, hold);

  00307	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0030b	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00310	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  00315	41 b8 02 00 00
	00		 mov	 r8d, 2
  0031b	41 c1 ee 08	 shr	 r14d, 8
  0031f	44 88 74 24 35	 mov	 BYTE PTR hbuf$[rsp+1], r14b
  00324	e8 00 00 00 00	 call	 crc32
  00329	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN39@inflate:

; 688  :             INITBITS();

  0032d	45 8b f7	 mov	 r14d, r15d

; 689  :             state->mode = TIME;

  00330	41 c7 45 08 36
	3f 00 00	 mov	 DWORD PTR [r13+8], 16182 ; 00003f36H
  00338	41 8b df	 mov	 ebx, r15d

; 690  :                 /* fallthrough */
; 691  :         case TIME:
; 692  :             NEEDBITS(32);

  0033b	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  0033d	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00340	73 20		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  00342	85 f6		 test	 esi, esi
  00344	0f 84 a5 05 00
	00		 je	 $LN999@inflate
  0034a	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  0034e	8b cb		 mov	 ecx, ebx
  00350	d3 e0		 shl	 eax, cl
  00352	ff ce		 dec	 esi
  00354	44 03 f0	 add	 r14d, eax
  00357	48 ff c5	 inc	 rbp
  0035a	83 c3 08	 add	 ebx, 8
  0035d	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00360	72 e0		 jb	 SHORT $LL47@inflate
$LN44@inflate:

; 693  :             if (state->head != Z_NULL)

  00362	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00366	48 85 c0	 test	 rax, rax
  00369	74 04		 je	 SHORT $LN355@inflate

; 694  :                 state->head->time = hold;

  0036b	44 89 70 04	 mov	 DWORD PTR [rax+4], r14d
$LN355@inflate:

; 695  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  0036f	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00377	74 41		 je	 SHORT $LN53@inflate
  00379	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  0037e	74 3a		 je	 SHORT $LN53@inflate

; 696  :                 CRC4(state->check, hold);

  00380	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  00384	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00389	41 8b c6	 mov	 eax, r14d
  0038c	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  00391	c1 e8 08	 shr	 eax, 8
  00394	41 b8 04 00 00
	00		 mov	 r8d, 4
  0039a	88 44 24 35	 mov	 BYTE PTR hbuf$[rsp+1], al
  0039e	41 8b c6	 mov	 eax, r14d
  003a1	c1 e8 10	 shr	 eax, 16
  003a4	41 c1 ee 18	 shr	 r14d, 24
  003a8	88 44 24 36	 mov	 BYTE PTR hbuf$[rsp+2], al
  003ac	44 88 74 24 37	 mov	 BYTE PTR hbuf$[rsp+3], r14b
  003b1	e8 00 00 00 00	 call	 crc32
  003b6	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN53@inflate:

; 697  :             INITBITS();

  003ba	45 8b f7	 mov	 r14d, r15d

; 698  :             state->mode = OS;

  003bd	41 c7 45 08 37
	3f 00 00	 mov	 DWORD PTR [r13+8], 16183 ; 00003f37H
  003c5	41 8b df	 mov	 ebx, r15d

; 699  :                 /* fallthrough */
; 700  :         case OS:
; 701  :             NEEDBITS(16);

  003c8	eb 06		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  003ca	83 fb 10	 cmp	 ebx, 16
  003cd	73 21		 jae	 SHORT $LN58@inflate
  003cf	90		 npad	 1
$LL61@inflate:
  003d0	85 f6		 test	 esi, esi
  003d2	0f 84 17 05 00
	00		 je	 $LN999@inflate
  003d8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  003dc	8b cb		 mov	 ecx, ebx
  003de	d3 e0		 shl	 eax, cl
  003e0	ff ce		 dec	 esi
  003e2	44 03 f0	 add	 r14d, eax
  003e5	48 ff c5	 inc	 rbp
  003e8	83 c3 08	 add	 ebx, 8
  003eb	83 fb 10	 cmp	 ebx, 16
  003ee	72 e0		 jb	 SHORT $LL61@inflate
$LN58@inflate:

; 702  :             if (state->head != Z_NULL) {

  003f0	49 8b 55 28	 mov	 rdx, QWORD PTR [r13+40]
  003f4	41 8b ce	 mov	 ecx, r14d
  003f7	c1 e9 08	 shr	 ecx, 8
  003fa	48 85 d2	 test	 rdx, rdx
  003fd	74 0e		 je	 SHORT $LN624@inflate

; 703  :                 state->head->xflags = (int)(hold & 0xff);

  003ff	41 0f b6 c6	 movzx	 eax, r14b
  00403	89 42 08	 mov	 DWORD PTR [rdx+8], eax

; 704  :                 state->head->os = (int)(hold >> 8);

  00406	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0040a	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN624@inflate:

; 705  :             }
; 706  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  0040d	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00415	74 28		 je	 SHORT $LN67@inflate
  00417	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  0041c	74 21		 je	 SHORT $LN67@inflate

; 707  :                 CRC2(state->check, hold);

  0041e	88 4c 24 35	 mov	 BYTE PTR hbuf$[rsp+1], cl
  00422	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00427	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0042b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00431	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  00436	e8 00 00 00 00	 call	 crc32
  0043b	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN67@inflate:

; 708  :             INITBITS();

  0043f	45 8b f7	 mov	 r14d, r15d

; 709  :             state->mode = EXLEN;

  00442	41 c7 45 08 38
	3f 00 00	 mov	 DWORD PTR [r13+8], 16184 ; 00003f38H
  0044a	41 8b df	 mov	 ebx, r15d
$LN361@inflate:

; 710  :                 /* fallthrough */
; 711  :         case EXLEN:
; 712  :             if (state->flags & 0x0400) {

  0044d	41 f7 45 18 00
	04 00 00	 test	 DWORD PTR [r13+24], 1024 ; 00000400H
  00455	74 79		 je	 SHORT $LN362@inflate

; 713  :                 NEEDBITS(16);

  00457	83 fb 10	 cmp	 ebx, 16
  0045a	73 24		 jae	 SHORT $LN72@inflate
  0045c	0f 1f 40 00	 npad	 4
$LL75@inflate:
  00460	85 f6		 test	 esi, esi
  00462	0f 84 87 04 00
	00		 je	 $LN999@inflate
  00468	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  0046c	8b cb		 mov	 ecx, ebx
  0046e	d3 e0		 shl	 eax, cl
  00470	ff ce		 dec	 esi
  00472	44 03 f0	 add	 r14d, eax
  00475	48 ff c5	 inc	 rbp
  00478	83 c3 08	 add	 ebx, 8
  0047b	83 fb 10	 cmp	 ebx, 16
  0047e	72 e0		 jb	 SHORT $LL75@inflate
$LN72@inflate:

; 714  :                 state->length = (unsigned)(hold);
; 715  :                 if (state->head != Z_NULL)

  00480	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00484	45 89 75 50	 mov	 DWORD PTR [r13+80], r14d
  00488	48 85 c0	 test	 rax, rax
  0048b	74 04		 je	 SHORT $LN365@inflate

; 716  :                     state->head->extra_len = (unsigned)hold;

  0048d	44 89 70 18	 mov	 DWORD PTR [rax+24], r14d
$LN365@inflate:

; 717  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00491	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  00499	74 2d		 je	 SHORT $LN81@inflate
  0049b	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  004a0	74 26		 je	 SHORT $LN81@inflate

; 718  :                     CRC2(state->check, hold);

  004a2	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  004a6	48 8d 54 24 34	 lea	 rdx, QWORD PTR hbuf$[rsp]
  004ab	44 88 74 24 34	 mov	 BYTE PTR hbuf$[rsp], r14b
  004b0	41 b8 02 00 00
	00		 mov	 r8d, 2
  004b6	41 c1 ee 08	 shr	 r14d, 8
  004ba	44 88 74 24 35	 mov	 BYTE PTR hbuf$[rsp+1], r14b
  004bf	e8 00 00 00 00	 call	 crc32
  004c4	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN81@inflate:

; 719  :                 INITBITS();

  004c8	45 8b f7	 mov	 r14d, r15d
  004cb	41 8b df	 mov	 ebx, r15d

; 720  :             }

  004ce	eb 0d		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 721  :             else if (state->head != Z_NULL)

  004d0	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  004d4	48 85 c0	 test	 rax, rax
  004d7	74 04		 je	 SHORT $LN367@inflate

; 722  :                 state->head->extra = Z_NULL;

  004d9	4c 89 78 10	 mov	 QWORD PTR [rax+16], r15
$LN367@inflate:

; 723  :             state->mode = EXTRA;

  004dd	41 c7 45 08 39
	3f 00 00	 mov	 DWORD PTR [r13+8], 16185 ; 00003f39H
$LN368@inflate:

; 724  :                 /* fallthrough */
; 725  :         case EXTRA:
; 726  :             if (state->flags & 0x0400) {

  004e5	41 f7 45 18 00
	04 00 00	 test	 DWORD PTR [r13+24], 1024 ; 00000400H
  004ed	0f 84 91 00 00
	00		 je	 $LN374@inflate

; 727  :                 copy = state->length;

  004f3	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]

; 728  :                 if (copy > have) copy = have;
; 729  :                 if (copy) {

  004f7	8b fe		 mov	 edi, esi
  004f9	3b c6		 cmp	 eax, esi
  004fb	0f 46 f8	 cmovbe	 edi, eax
  004fe	85 ff		 test	 edi, edi
  00500	74 7a		 je	 SHORT $LN371@inflate

; 730  :                     if (state->head != Z_NULL &&
; 731  :                         state->head->extra != Z_NULL &&

  00502	49 8b 4d 28	 mov	 rcx, QWORD PTR [r13+40]
  00506	48 85 c9	 test	 rcx, rcx
  00509	74 3c		 je	 SHORT $LN372@inflate
  0050b	4c 8b 51 10	 mov	 r10, QWORD PTR [rcx+16]
  0050f	4d 85 d2	 test	 r10, r10
  00512	74 33		 je	 SHORT $LN372@inflate
  00514	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]
  00518	44 8b 41 1c	 mov	 r8d, DWORD PTR [rcx+28]
  0051c	44 2b c8	 sub	 r9d, eax
  0051f	45 3b c8	 cmp	 r9d, r8d
  00522	73 23		 jae	 SHORT $LN372@inflate

; 732  :                         (len = state->head->extra_len - state->length) <
; 733  :                             state->head->extra_max) {
; 734  :                         zmemcpy(state->head->extra + len, next,

  00524	41 8b d0	 mov	 edx, r8d
  00527	42 8d 0c 0f	 lea	 ecx, DWORD PTR [rdi+r9]
  0052b	41 2b d1	 sub	 edx, r9d
  0052e	8b c7		 mov	 eax, edi
  00530	41 3b c8	 cmp	 ecx, r8d
  00533	41 8b c9	 mov	 ecx, r9d
  00536	0f 47 c2	 cmova	 eax, edx
  00539	49 03 ca	 add	 rcx, r10
  0053c	44 8b c0	 mov	 r8d, eax
  0053f	48 8b d5	 mov	 rdx, rbp
  00542	e8 00 00 00 00	 call	 memcpy
$LN372@inflate:

; 735  :                                 len + copy > state->head->extra_max ?
; 736  :                                 state->head->extra_max - len : copy);
; 737  :                     }
; 738  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  00547	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  0054f	74 1a		 je	 SHORT $LN373@inflate
  00551	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00556	74 13		 je	 SHORT $LN373@inflate

; 739  :                         state->check = crc32(state->check, next, copy);

  00558	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0055c	44 8b c7	 mov	 r8d, edi
  0055f	48 8b d5	 mov	 rdx, rbp
  00562	e8 00 00 00 00	 call	 crc32
  00567	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN373@inflate:

; 740  :                     have -= copy;
; 741  :                     next += copy;

  0056b	8b c7		 mov	 eax, edi
  0056d	2b f7		 sub	 esi, edi
  0056f	48 03 e8	 add	 rbp, rax

; 742  :                     state->length -= copy;

  00572	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]
  00576	2b c7		 sub	 eax, edi
  00578	41 89 45 50	 mov	 DWORD PTR [r13+80], eax
$LN371@inflate:

; 743  :                 }
; 744  :                 if (state->length) goto inf_leave;

  0057c	85 c0		 test	 eax, eax
  0057e	0f 85 6b 03 00
	00		 jne	 $LN999@inflate
$LN374@inflate:

; 745  :             }
; 746  :             state->length = 0;

  00584	45 89 7d 50	 mov	 DWORD PTR [r13+80], r15d

; 747  :             state->mode = NAME;

  00588	41 c7 45 08 3a
	3f 00 00	 mov	 DWORD PTR [r13+8], 16186 ; 00003f3aH
$LN375@inflate:

; 748  :                 /* fallthrough */
; 749  :         case NAME:
; 750  :             if (state->flags & 0x0800) {

  00590	41 f7 45 18 00
	08 00 00	 test	 DWORD PTR [r13+24], 2048 ; 00000800H
  00598	0f 84 80 00 00
	00		 je	 $LN376@inflate

; 751  :                 if (have == 0) goto inf_leave;

  0059e	85 f6		 test	 esi, esi
  005a0	0f 84 49 03 00
	00		 je	 $LN999@inflate

; 752  :                 copy = 0;

  005a6	41 8b ff	 mov	 edi, r15d
  005a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL88@inflate:

; 753  :                 do {
; 754  :                     len = (unsigned)(next[copy++]);

  005b0	8b c7		 mov	 eax, edi
  005b2	ff c7		 inc	 edi
  005b4	44 0f b6 3c 28	 movzx	 r15d, BYTE PTR [rax+rbp]

; 755  :                     if (state->head != Z_NULL &&
; 756  :                             state->head->name != Z_NULL &&

  005b9	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  005bd	48 85 c0	 test	 rax, rax
  005c0	74 1a		 je	 SHORT $LN86@inflate
  005c2	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  005c6	48 85 d2	 test	 rdx, rdx
  005c9	74 11		 je	 SHORT $LN86@inflate
  005cb	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]
  005cf	3b 48 28	 cmp	 ecx, DWORD PTR [rax+40]
  005d2	73 08		 jae	 SHORT $LN86@inflate

; 757  :                             state->length < state->head->name_max)
; 758  :                         state->head->name[state->length++] = (Bytef)len;

  005d4	44 88 3c 11	 mov	 BYTE PTR [rcx+rdx], r15b
  005d8	41 ff 45 50	 inc	 DWORD PTR [r13+80]
$LN86@inflate:

; 759  :                 } while (len && copy < have);

  005dc	45 84 ff	 test	 r15b, r15b
  005df	74 04		 je	 SHORT $LN380@inflate
  005e1	3b fe		 cmp	 edi, esi
  005e3	72 cb		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 760  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  005e5	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  005ed	74 1a		 je	 SHORT $LN381@inflate
  005ef	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  005f4	74 13		 je	 SHORT $LN381@inflate

; 761  :                     state->check = crc32(state->check, next, copy);

  005f6	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  005fa	44 8b c7	 mov	 r8d, edi
  005fd	48 8b d5	 mov	 rdx, rbp
  00600	e8 00 00 00 00	 call	 crc32
  00605	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN381@inflate:

; 762  :                 have -= copy;
; 763  :                 next += copy;

  00609	8b c7		 mov	 eax, edi
  0060b	2b f7		 sub	 esi, edi
  0060d	48 03 e8	 add	 rbp, rax

; 764  :                 if (len) goto inf_leave;

  00610	45 84 ff	 test	 r15b, r15b
  00613	0f 85 d6 02 00
	00		 jne	 $LN999@inflate

; 765  :             }

  00619	45 33 ff	 xor	 r15d, r15d
  0061c	eb 0d		 jmp	 SHORT $LN383@inflate
$LN376@inflate:

; 766  :             else if (state->head != Z_NULL)

  0061e	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00622	48 85 c0	 test	 rax, rax
  00625	74 04		 je	 SHORT $LN383@inflate

; 767  :                 state->head->name = Z_NULL;

  00627	4c 89 78 20	 mov	 QWORD PTR [rax+32], r15
$LN383@inflate:

; 768  :             state->length = 0;

  0062b	45 89 7d 50	 mov	 DWORD PTR [r13+80], r15d

; 769  :             state->mode = COMMENT;

  0062f	41 c7 45 08 3b
	3f 00 00	 mov	 DWORD PTR [r13+8], 16187 ; 00003f3bH
$LN384@inflate:

; 770  :                 /* fallthrough */
; 771  :         case COMMENT:
; 772  :             if (state->flags & 0x1000) {

  00637	41 f7 45 18 00
	10 00 00	 test	 DWORD PTR [r13+24], 4096 ; 00001000H
  0063f	74 7d		 je	 SHORT $LN385@inflate

; 773  :                 if (have == 0) goto inf_leave;

  00641	85 f6		 test	 esi, esi
  00643	0f 84 a6 02 00
	00		 je	 $LN999@inflate

; 774  :                 copy = 0;

  00649	41 8b ff	 mov	 edi, r15d
  0064c	0f 1f 40 00	 npad	 4
$LL91@inflate:

; 775  :                 do {
; 776  :                     len = (unsigned)(next[copy++]);

  00650	8b c7		 mov	 eax, edi
  00652	ff c7		 inc	 edi
  00654	44 0f b6 3c 28	 movzx	 r15d, BYTE PTR [rax+rbp]

; 777  :                     if (state->head != Z_NULL &&
; 778  :                             state->head->comment != Z_NULL &&

  00659	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  0065d	48 85 c0	 test	 rax, rax
  00660	74 1a		 je	 SHORT $LN89@inflate
  00662	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  00666	48 85 d2	 test	 rdx, rdx
  00669	74 11		 je	 SHORT $LN89@inflate
  0066b	41 8b 4d 50	 mov	 ecx, DWORD PTR [r13+80]
  0066f	3b 48 38	 cmp	 ecx, DWORD PTR [rax+56]
  00672	73 08		 jae	 SHORT $LN89@inflate

; 779  :                             state->length < state->head->comm_max)
; 780  :                         state->head->comment[state->length++] = (Bytef)len;

  00674	44 88 3c 11	 mov	 BYTE PTR [rcx+rdx], r15b
  00678	41 ff 45 50	 inc	 DWORD PTR [r13+80]
$LN89@inflate:

; 781  :                 } while (len && copy < have);

  0067c	45 84 ff	 test	 r15b, r15b
  0067f	74 04		 je	 SHORT $LN389@inflate
  00681	3b fe		 cmp	 edi, esi
  00683	72 cb		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 782  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00685	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  0068d	74 1a		 je	 SHORT $LN390@inflate
  0068f	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00694	74 13		 je	 SHORT $LN390@inflate

; 783  :                     state->check = crc32(state->check, next, copy);

  00696	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0069a	44 8b c7	 mov	 r8d, edi
  0069d	48 8b d5	 mov	 rdx, rbp
  006a0	e8 00 00 00 00	 call	 crc32
  006a5	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
$LN390@inflate:

; 784  :                 have -= copy;
; 785  :                 next += copy;

  006a9	8b c7		 mov	 eax, edi
  006ab	2b f7		 sub	 esi, edi
  006ad	48 03 e8	 add	 rbp, rax

; 786  :                 if (len) goto inf_leave;

  006b0	45 84 ff	 test	 r15b, r15b
  006b3	0f 85 36 02 00
	00		 jne	 $LN999@inflate

; 787  :             }

  006b9	45 33 ff	 xor	 r15d, r15d
  006bc	eb 0d		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 788  :             else if (state->head != Z_NULL)

  006be	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  006c2	48 85 c0	 test	 rax, rax
  006c5	74 04		 je	 SHORT $LN392@inflate

; 789  :                 state->head->comment = Z_NULL;

  006c7	4c 89 78 30	 mov	 QWORD PTR [rax+48], r15
$LN392@inflate:
  006cb	4c 8b 4c 24 40	 mov	 r9, QWORD PTR put$1$[rsp]
  006d0	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]

; 790  :             state->mode = HCRC;

  006d5	41 c7 45 08 3c
	3f 00 00	 mov	 DWORD PTR [r13+8], 16188 ; 00003f3cH
$LN393@inflate:

; 791  :                 /* fallthrough */
; 792  :         case HCRC:
; 793  :             if (state->flags & 0x0200) {

  006dd	41 f7 45 18 00
	02 00 00	 test	 DWORD PTR [r13+24], 512	; 00000200H
  006e5	74 56		 je	 SHORT $LN101@inflate

; 794  :                 NEEDBITS(16);

  006e7	83 fb 10	 cmp	 ebx, 16
  006ea	73 24		 jae	 SHORT $LN92@inflate
  006ec	0f 1f 40 00	 npad	 4
$LL95@inflate:
  006f0	85 f6		 test	 esi, esi
  006f2	0f 84 f7 01 00
	00		 je	 $LN999@inflate
  006f8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  006fc	8b cb		 mov	 ecx, ebx
  006fe	d3 e0		 shl	 eax, cl
  00700	ff ce		 dec	 esi
  00702	44 03 f0	 add	 r14d, eax
  00705	48 ff c5	 inc	 rbp
  00708	83 c3 08	 add	 ebx, 8
  0070b	83 fb 10	 cmp	 ebx, 16
  0070e	72 e0		 jb	 SHORT $LL95@inflate
$LN92@inflate:

; 795  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  00710	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  00715	74 20		 je	 SHORT $LN102@inflate
  00717	41 0f b7 45 20	 movzx	 eax, WORD PTR [r13+32]
  0071c	44 3b f0	 cmp	 r14d, eax
  0071f	74 16		 je	 SHORT $LN102@inflate

; 796  :                     strm->msg = (z_const char *)"header crc mismatch";

  00721	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch@
  00728	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 797  :                     state->mode = BAD;

  0072d	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 798  :                     break;

  00735	eb 4e		 jmp	 SHORT $LN5@inflate
$LN102@inflate:

; 799  :                 }
; 800  :                 INITBITS();

  00737	45 8b f7	 mov	 r14d, r15d
  0073a	41 8b df	 mov	 ebx, r15d
$LN101@inflate:

; 801  :             }
; 802  :             if (state->head != Z_NULL) {

  0073d	49 8b 4d 28	 mov	 rcx, QWORD PTR [r13+40]
  00741	48 85 c9	 test	 rcx, rcx
  00744	74 18		 je	 SHORT $LN397@inflate

; 803  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00746	41 8b 45 18	 mov	 eax, DWORD PTR [r13+24]
  0074a	c1 f8 09	 sar	 eax, 9
  0074d	83 e0 01	 and	 eax, 1
  00750	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 804  :                 state->head->done = 1;

  00753	49 8b 45 28	 mov	 rax, QWORD PTR [r13+40]
  00757	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN397@inflate:

; 805  :             }
; 806  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  0075e	45 33 c0	 xor	 r8d, r8d
  00761	33 d2		 xor	 edx, edx
  00763	33 c9		 xor	 ecx, ecx
  00765	e8 00 00 00 00	 call	 crc32
  0076a	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  0076e	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN1199@inflate:

; 620  :     for (;;)
; 621  :         switch (state->mode) {

  00773	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
$LN1196@inflate:
  0077b	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
$LN966@inflate:
  00780	4c 8b 4c 24 40	 mov	 r9, QWORD PTR put$1$[rsp]
$LN5@inflate:
  00785	41 8b 4d 08	 mov	 ecx, DWORD PTR [r13+8]
  00789	81 e9 34 3f 00
	00		 sub	 ecx, 16180		; 00003f34H
  0078f	83 f9 1f	 cmp	 ecx, 31
  00792	0f 87 e0 0f 00
	00		 ja	 $LN333@inflate
  00798	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR out$1$[rsp]
  007a0	45 33 ff	 xor	 r15d, r15d
  007a3	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR flush$[rsp]
  007aa	e9 16 f9 ff ff	 jmp	 $LN1197@inflate
$LN105@inflate:

; 807  :             state->mode = TYPE;
; 808  :             break;
; 809  : #endif
; 810  :         case DICTID:
; 811  :             NEEDBITS(32);

  007af	83 fb 20	 cmp	 ebx, 32			; 00000020H
  007b2	73 20		 jae	 SHORT $LN103@inflate
$LL106@inflate:
  007b4	85 f6		 test	 esi, esi
  007b6	0f 84 33 01 00
	00		 je	 $LN999@inflate
  007bc	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  007c0	8b cb		 mov	 ecx, ebx
  007c2	d3 e0		 shl	 eax, cl
  007c4	ff ce		 dec	 esi
  007c6	44 03 f0	 add	 r14d, eax
  007c9	48 ff c5	 inc	 rbp
  007cc	83 c3 08	 add	 ebx, 8
  007cf	83 fb 20	 cmp	 ebx, 32			; 00000020H
  007d2	72 e0		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 812  :             strm->adler = state->check = ZSWAP32(hold);

  007d4	41 0f ce	 bswap	 r14d
  007d7	45 89 75 20	 mov	 DWORD PTR [r13+32], r14d

; 813  :             INITBITS();

  007db	41 8b df	 mov	 ebx, r15d
  007de	45 89 74 24 4c	 mov	 DWORD PTR [r12+76], r14d
  007e3	45 8b f7	 mov	 r14d, r15d

; 814  :             state->mode = DICT;

  007e6	41 c7 45 08 3e
	3f 00 00	 mov	 DWORD PTR [r13+8], 16190 ; 00003f3eH
$LN400@inflate:

; 815  :                 /* fallthrough */
; 816  :         case DICT:
; 817  :             if (state->havedict == 0) {

  007ee	41 83 7d 14 00	 cmp	 DWORD PTR [r13+20], 0
  007f3	0f 84 40 0e 00
	00		 je	 $LN587@inflate

; 820  :             }
; 821  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  007f9	45 33 c0	 xor	 r8d, r8d
  007fc	33 d2		 xor	 edx, edx
  007fe	33 c9		 xor	 ecx, ecx
  00800	e8 00 00 00 00	 call	 adler32
  00805	4c 8b 4c 24 40	 mov	 r9, QWORD PTR put$1$[rsp]
  0080a	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
  0080f	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  00813	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax

; 822  :             state->mode = TYPE;

  00818	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH
$LN402@inflate:

; 823  :                 /* fallthrough */
; 824  :         case TYPE:
; 825  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  00820	8d 47 fb	 lea	 eax, DWORD PTR [rdi-5]
  00823	83 f8 01	 cmp	 eax, 1
  00826	0f 86 c3 00 00
	00		 jbe	 $LN999@inflate
$LN403@inflate:

; 826  :                 /* fallthrough */
; 827  :         case TYPEDO:
; 828  :             if (state->last) {

  0082c	41 83 7d 0c 00	 cmp	 DWORD PTR [r13+12], 0
  00831	74 17		 je	 SHORT $LN122@inflate

; 829  :                 BYTEBITS();

  00833	8b cb		 mov	 ecx, ebx

; 830  :                 state->mode = CHECK;

  00835	41 c7 45 08 4e
	3f 00 00	 mov	 DWORD PTR [r13+8], 16206 ; 00003f4eH
  0083d	83 e1 07	 and	 ecx, 7
  00840	41 d3 ee	 shr	 r14d, cl
  00843	2b d9		 sub	 ebx, ecx

; 831  :                 break;

  00845	e9 3b ff ff ff	 jmp	 $LN5@inflate
$LN122@inflate:

; 832  :             }
; 833  :             NEEDBITS(3);

  0084a	83 fb 03	 cmp	 ebx, 3
  0084d	73 21		 jae	 SHORT $LN120@inflate
  0084f	90		 npad	 1
$LL123@inflate:
  00850	85 f6		 test	 esi, esi
  00852	0f 84 97 00 00
	00		 je	 $LN999@inflate
  00858	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  0085c	8b cb		 mov	 ecx, ebx
  0085e	d3 e0		 shl	 eax, cl
  00860	ff ce		 dec	 esi
  00862	44 03 f0	 add	 r14d, eax
  00865	48 ff c5	 inc	 rbp
  00868	83 c3 08	 add	 ebx, 8
  0086b	83 fb 03	 cmp	 ebx, 3
  0086e	72 e0		 jb	 SHORT $LL123@inflate
$LN120@inflate:

; 834  :             state->last = BITS(1);

  00870	41 8b c6	 mov	 eax, r14d
  00873	83 e0 01	 and	 eax, 1
  00876	41 89 45 0c	 mov	 DWORD PTR [r13+12], eax

; 835  :             DROPBITS(1);
; 836  :             switch (BITS(2)) {

  0087a	41 8b c6	 mov	 eax, r14d
  0087d	d1 e8		 shr	 eax, 1
  0087f	83 e0 03	 and	 eax, 3
  00882	0f 84 01 01 00
	00		 je	 $LN408@inflate
  00888	83 e8 01	 sub	 eax, 1
  0088b	74 42		 je	 SHORT $LN409@inflate
  0088d	83 e8 01	 sub	 eax, 1
  00890	74 29		 je	 SHORT $LN411@inflate
  00892	83 f8 01	 cmp	 eax, 1
  00895	0f 85 f6 00 00
	00		 jne	 $LN138@inflate

; 849  :                     goto inf_leave;
; 850  :                 }
; 851  :                 break;
; 852  :             case 2:                             /* dynamic block */
; 853  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 854  :                         state->last ? " (last)" : ""));
; 855  :                 state->mode = TABLE;
; 856  :                 break;
; 857  :             case 3:
; 858  :                 strm->msg = (z_const char *)"invalid block type";

  0089b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type@

; 859  :                 state->mode = BAD;
; 860  :             }
; 861  :             DROPBITS(2);

  008a2	83 c3 fd	 add	 ebx, -3			; fffffffdH
  008a5	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  008aa	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  008b2	41 c1 ee 03	 shr	 r14d, 3

; 862  :             break;

  008b6	e9 ca fe ff ff	 jmp	 $LN5@inflate
$LN411@inflate:

; 859  :                 state->mode = BAD;
; 860  :             }
; 861  :             DROPBITS(2);

  008bb	83 c3 fd	 add	 ebx, -3			; fffffffdH
  008be	41 c7 45 08 44
	3f 00 00	 mov	 DWORD PTR [r13+8], 16196 ; 00003f44H
  008c6	41 c1 ee 03	 shr	 r14d, 3

; 862  :             break;

  008ca	e9 b6 fe ff ff	 jmp	 $LN5@inflate
$LN409@inflate:

; 841  :                 break;
; 842  :             case 1:                             /* fixed block */
; 843  :                 fixedtables(state);

  008cf	49 8b cd	 mov	 rcx, r13
  008d2	e8 00 00 00 00	 call	 fixedtables

; 844  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 845  :                         state->last ? " (last)" : ""));
; 846  :                 state->mode = LEN_;             /* decode codes */

  008d7	41 c7 45 08 47
	3f 00 00	 mov	 DWORD PTR [r13+8], 16199 ; 00003f47H

; 847  :                 if (flush == Z_TREES) {

  008df	83 ff 06	 cmp	 edi, 6
  008e2	0f 85 a9 00 00
	00		 jne	 $LN138@inflate

; 848  :                     DROPBITS(2);

  008e8	83 c3 fd	 add	 ebx, -3			; fffffffdH
  008eb	41 c1 ee 03	 shr	 r14d, 3
$LN999@inflate:

; 1227 :             goto inf_leave;
; 1228 :         case MEM:
; 1229 :             return Z_MEM_ERROR;
; 1230 :         case SYNC:
; 1231 :                 /* fallthrough */
; 1232 :         default:
; 1233 :             return Z_STREAM_ERROR;
; 1234 :         }
; 1235 : 
; 1236 :     /*
; 1237 :        Return from inflate(), updating the total counts and the check value.
; 1238 :        If there was no progress during the inflate() call, return a buffer
; 1239 :        error.  Call updatewindow() to create and/or update the window state.
; 1240 :        Note: a memory error from inflate() is non-recoverable.
; 1241 :      */
; 1242 :   inf_leave:
; 1243 :     RESTORE();

  008ef	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]
$LN1003@inflate:
  008f6	44 8b bc 24 a8
	00 00 00	 mov	 r15d, DWORD PTR ret$1$[rsp]
$LN1198@inflate:
  008fe	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR flush$[rsp]
$inf_leave$1202:
  00905	48 8b 44 24 40	 mov	 rax, QWORD PTR put$1$[rsp]
  0090a	49 89 44 24 10	 mov	 QWORD PTR [r12+16], rax
  0090f	8b 44 24 30	 mov	 eax, DWORD PTR left$1$[rsp]
  00913	41 89 44 24 18	 mov	 DWORD PTR [r12+24], eax
  00918	49 89 2c 24	 mov	 QWORD PTR [r12], rbp
  0091c	41 89 74 24 08	 mov	 DWORD PTR [r12+8], esi

; 1244 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  00921	41 83 7d 34 00	 cmp	 DWORD PTR [r13+52], 0
  00926	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  0092a	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  0092e	75 2a		 jne	 SHORT $LN503@inflate
  00930	41 3b 7c 24 18	 cmp	 edi, DWORD PTR [r12+24]
  00935	0f 84 6c 0d 00
	00		 je	 $LN504@inflate
  0093b	41 8b 45 08	 mov	 eax, DWORD PTR [r13+8]
  0093f	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  00944	0f 8d 5d 0d 00
	00		 jge	 $LN504@inflate
  0094a	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  0094f	7c 09		 jl	 SHORT $LN503@inflate
  00951	83 f9 04	 cmp	 ecx, 4
  00954	0f 84 4d 0d 00
	00		 je	 $LN504@inflate
$LN503@inflate:

; 1245 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1246 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  0095a	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]
  0095f	44 8b c7	 mov	 r8d, edi
  00962	45 2b 44 24 18	 sub	 r8d, DWORD PTR [r12+24]
  00967	49 8b cc	 mov	 rcx, r12
  0096a	e8 00 00 00 00	 call	 updatewindow
  0096f	85 c0		 test	 eax, eax
  00971	0f 84 30 0d 00
	00		 je	 $LN504@inflate

; 1247 :             state->mode = MEM;

  00977	41 c7 45 08 52
	3f 00 00	 mov	 DWORD PTR [r13+8], 16210 ; 00003f52H
$LN498@inflate:

; 1264 : }

  0097f	b8 fc ff ff ff	 mov	 eax, -4
  00984	e9 f4 0d 00 00	 jmp	 $LN1@inflate
$LN408@inflate:

; 837  :             case 0:                             /* stored block */
; 838  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 839  :                         state->last ? " (last)" : ""));
; 840  :                 state->mode = STORED;

  00989	41 c7 45 08 41
	3f 00 00	 mov	 DWORD PTR [r13+8], 16193 ; 00003f41H
$LN138@inflate:

; 859  :                 state->mode = BAD;
; 860  :             }
; 861  :             DROPBITS(2);

  00991	83 c3 fd	 add	 ebx, -3			; fffffffdH
  00994	41 c1 ee 03	 shr	 r14d, 3

; 862  :             break;

  00998	e9 e8 fd ff ff	 jmp	 $LN5@inflate
$LN141@inflate:

; 863  :         case STORED:
; 864  :             BYTEBITS();                         /* go to byte boundary */

  0099d	8b cb		 mov	 ecx, ebx
  0099f	83 e1 07	 and	 ecx, 7
  009a2	41 d3 ee	 shr	 r14d, cl
  009a5	2b d9		 sub	 ebx, ecx

; 865  :             NEEDBITS(32);

  009a7	83 fb 20	 cmp	 ebx, 32			; 00000020H
  009aa	73 24		 jae	 SHORT $LN142@inflate
  009ac	0f 1f 40 00	 npad	 4
$LL145@inflate:
  009b0	85 f6		 test	 esi, esi
  009b2	0f 84 37 ff ff
	ff		 je	 $LN999@inflate
  009b8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  009bc	8b cb		 mov	 ecx, ebx
  009be	d3 e0		 shl	 eax, cl
  009c0	ff ce		 dec	 esi
  009c2	44 03 f0	 add	 r14d, eax
  009c5	48 ff c5	 inc	 rbp
  009c8	83 c3 08	 add	 ebx, 8
  009cb	83 fb 20	 cmp	 ebx, 32			; 00000020H
  009ce	72 e0		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 866  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  009d0	41 8b c6	 mov	 eax, r14d
  009d3	41 0f b7 ce	 movzx	 ecx, r14w
  009d7	f7 d0		 not	 eax
  009d9	c1 e8 10	 shr	 eax, 16
  009dc	3b c8		 cmp	 ecx, eax
  009de	74 19		 je	 SHORT $LN415@inflate

; 867  :                 strm->msg = (z_const char *)"invalid stored block lengths";

  009e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths@
  009e7	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 868  :                 state->mode = BAD;

  009ec	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 869  :                 break;

  009f4	e9 8c fd ff ff	 jmp	 $LN5@inflate
$LN415@inflate:

; 870  :             }
; 871  :             state->length = (unsigned)hold & 0xffff;

  009f9	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 872  :             Tracev((stderr, "inflate:       stored length %u\n",
; 873  :                     state->length));
; 874  :             INITBITS();

  009fd	45 8b f7	 mov	 r14d, r15d

; 875  :             state->mode = COPY_;

  00a00	41 c7 45 08 42
	3f 00 00	 mov	 DWORD PTR [r13+8], 16194 ; 00003f42H
  00a08	41 8b df	 mov	 ebx, r15d

; 876  :             if (flush == Z_TREES) goto inf_leave;

  00a0b	83 ff 06	 cmp	 edi, 6
  00a0e	0f 84 db fe ff
	ff		 je	 $LN999@inflate
$LN416@inflate:

; 877  :                 /* fallthrough */
; 878  :         case COPY_:
; 879  :             state->mode = COPY;

  00a14	41 c7 45 08 43
	3f 00 00	 mov	 DWORD PTR [r13+8], 16195 ; 00003f43H
$LN418@inflate:

; 880  :                 /* fallthrough */
; 881  :         case COPY:
; 882  :             copy = state->length;

  00a1c	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]

; 883  :             if (copy) {

  00a20	85 c0		 test	 eax, eax
  00a22	74 53		 je	 SHORT $LN419@inflate

; 884  :                 if (copy > have) copy = have;
; 885  :                 if (copy > left) copy = left;

  00a24	3b c6		 cmp	 eax, esi
  00a26	44 8b fe	 mov	 r15d, esi
  00a29	44 0f 46 f8	 cmovbe	 r15d, eax
  00a2d	45 3b fa	 cmp	 r15d, r10d
  00a30	45 0f 47 fa	 cmova	 r15d, r10d

; 886  :                 if (copy == 0) goto inf_leave;

  00a34	45 85 ff	 test	 r15d, r15d
  00a37	0f 84 b2 fe ff
	ff		 je	 $LN999@inflate

; 887  :                 zmemcpy(put, next, copy);

  00a3d	45 8b c7	 mov	 r8d, r15d
  00a40	48 8b d5	 mov	 rdx, rbp
  00a43	49 8b c9	 mov	 rcx, r9
  00a46	41 8b ff	 mov	 edi, r15d
  00a49	e8 00 00 00 00	 call	 memcpy

; 888  :                 have -= copy;
; 889  :                 next += copy;
; 890  :                 left -= copy;

  00a4e	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
  00a53	41 2b f7	 sub	 esi, r15d

; 891  :                 put += copy;

  00a56	4c 8b 4c 24 40	 mov	 r9, QWORD PTR put$1$[rsp]
  00a5b	45 2b d7	 sub	 r10d, r15d
  00a5e	4c 03 cf	 add	 r9, rdi
  00a61	44 89 54 24 30	 mov	 DWORD PTR left$1$[rsp], r10d
  00a66	48 03 ef	 add	 rbp, rdi
  00a69	4c 89 4c 24 40	 mov	 QWORD PTR put$1$[rsp], r9

; 892  :                 state->length -= copy;

  00a6e	45 29 7d 50	 sub	 DWORD PTR [r13+80], r15d

; 893  :                 break;

  00a72	e9 0e fd ff ff	 jmp	 $LN5@inflate
$LN419@inflate:

; 894  :             }
; 895  :             Tracev((stderr, "inflate:       stored end\n"));
; 896  :             state->mode = TYPE;

  00a77	41 c7 45 08 3f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16191 ; 00003f3fH

; 897  :             break;

  00a7f	e9 01 fd ff ff	 jmp	 $LN5@inflate
$LN155@inflate:

; 898  :         case TABLE:
; 899  :             NEEDBITS(14);

  00a84	83 fb 0e	 cmp	 ebx, 14
  00a87	73 27		 jae	 SHORT $LN153@inflate
  00a89	0f 1f 80 00 00
	00 00		 npad	 7
$LL156@inflate:
  00a90	85 f6		 test	 esi, esi
  00a92	0f 84 57 fe ff
	ff		 je	 $LN999@inflate
  00a98	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00a9c	8b cb		 mov	 ecx, ebx
  00a9e	d3 e0		 shl	 eax, cl
  00aa0	ff ce		 dec	 esi
  00aa2	44 03 f0	 add	 r14d, eax
  00aa5	48 ff c5	 inc	 rbp
  00aa8	83 c3 08	 add	 ebx, 8
  00aab	83 fb 0e	 cmp	 ebx, 14
  00aae	72 e0		 jb	 SHORT $LL156@inflate
$LN153@inflate:

; 900  :             state->nlen = BITS(5) + 257;

  00ab0	41 8b ce	 mov	 ecx, r14d

; 901  :             DROPBITS(5);
; 902  :             state->ndist = BITS(5) + 1;
; 903  :             DROPBITS(5);
; 904  :             state->ncode = BITS(4) + 4;
; 905  :             DROPBITS(4);

  00ab3	83 c3 f2	 add	 ebx, -14		; fffffff2H
  00ab6	41 c1 ee 05	 shr	 r14d, 5
  00aba	83 e1 1f	 and	 ecx, 31
  00abd	41 8b d6	 mov	 edx, r14d
  00ac0	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00ac6	41 c1 ee 05	 shr	 r14d, 5
  00aca	83 e2 1f	 and	 edx, 31
  00acd	41 8b c6	 mov	 eax, r14d
  00ad0	41 89 4d 7c	 mov	 DWORD PTR [r13+124], ecx
  00ad4	83 e0 0f	 and	 eax, 15
  00ad7	41 c1 ee 04	 shr	 r14d, 4
  00adb	83 c0 04	 add	 eax, 4
  00ade	ff c2		 inc	 edx
  00ae0	41 89 95 80 00
	00 00		 mov	 DWORD PTR [r13+128], edx
  00ae7	41 89 45 78	 mov	 DWORD PTR [r13+120], eax

; 906  : #ifndef PKZIP_BUG_WORKAROUND
; 907  :             if (state->nlen > 286 || state->ndist > 30) {

  00aeb	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00af1	0f 87 28 01 00
	00		 ja	 $LN426@inflate
  00af7	83 fa 1e	 cmp	 edx, 30
  00afa	0f 87 1f 01 00
	00		 ja	 $LN426@inflate

; 911  :             }
; 912  : #endif
; 913  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 914  :             state->have = 0;

  00b00	45 89 bd 84 00
	00 00		 mov	 DWORD PTR [r13+132], r15d

; 915  :             state->mode = LENLENS;

  00b07	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00b0e	41 c7 45 08 45
	3f 00 00	 mov	 DWORD PTR [r13+8], 16197 ; 00003f45H
$LN533@inflate:

; 916  :                 /* fallthrough */
; 917  :         case LENLENS:
; 918  :             while (state->have < state->ncode) {

  00b16	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b1d	41 3b 45 78	 cmp	 eax, DWORD PTR [r13+120]
  00b21	73 60		 jae	 SHORT $LN535@inflate
$LL170@inflate:

; 919  :                 NEEDBITS(3);

  00b23	83 fb 03	 cmp	 ebx, 3
  00b26	73 20		 jae	 SHORT $LN172@inflate
$LL175@inflate:
  00b28	85 f6		 test	 esi, esi
  00b2a	0f 84 bf fd ff
	ff		 je	 $LN999@inflate
  00b30	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00b34	8b cb		 mov	 ecx, ebx
  00b36	d3 e0		 shl	 eax, cl
  00b38	ff ce		 dec	 esi
  00b3a	44 03 f0	 add	 r14d, eax
  00b3d	48 ff c5	 inc	 rbp
  00b40	83 c3 08	 add	 ebx, 8
  00b43	83 fb 03	 cmp	 ebx, 3
  00b46	72 e0		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 920  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00b48	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b4f	41 0f b7 ce	 movzx	 ecx, r14w
  00b53	66 83 e1 07	 and	 cx, 7

; 921  :                 DROPBITS(3);

  00b57	41 c1 ee 03	 shr	 r14d, 3
  00b5b	83 c3 fd	 add	 ebx, -3			; fffffffdH
  00b5e	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[rdx+rax*2]
  00b66	66 41 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], cx
  00b6f	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00b76	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00b7d	41 3b 45 78	 cmp	 eax, DWORD PTR [r13+120]
  00b81	72 a0		 jb	 SHORT $LL170@inflate
$LN535@inflate:

; 922  :             }
; 923  :             while (state->have < 19)

  00b83	83 f8 13	 cmp	 eax, 19
  00b86	73 24		 jae	 SHORT $LN184@inflate
$LL183@inflate:

; 924  :                 state->lens[order[state->have++]] = 0;

  00b88	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[rdx+rax*2]
  00b90	66 45 89 bc 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r15w
  00b99	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00ba0	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00ba7	83 f8 13	 cmp	 eax, 19
  00baa	72 dc		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 925  :             state->next = state->codes;

  00bac	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]

; 926  :             state->lencode = state->distcode = (const code FAR *)(state->next);
; 927  :             state->lenbits = 7;

  00bb3	41 c7 45 70 07
	00 00 00	 mov	 DWORD PTR [r13+112], 7
  00bbb	49 8d 4d 70	 lea	 rcx, QWORD PTR [r13+112]
  00bbf	49 89 45 68	 mov	 QWORD PTR [r13+104], rax
  00bc3	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00bca	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  00bce	49 89 01	 mov	 QWORD PTR [r9], rax

; 928  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00bd1	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  00bd8	49 8d 85 10 03
	00 00		 lea	 rax, QWORD PTR [r13+784]
  00bdf	41 b8 13 00 00
	00		 mov	 r8d, 19
  00be5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00bea	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00bef	33 c9		 xor	 ecx, ecx
  00bf1	e8 00 00 00 00	 call	 inflate_table

; 929  :                                 &(state->lenbits), state->work);
; 930  :             if (ret) {

  00bf6	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
  00bfb	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$1$[rsp], eax
  00c02	85 c0		 test	 eax, eax
  00c04	74 32		 je	 SHORT $LN429@inflate

; 931  :                 strm->msg = (z_const char *)"invalid code lengths set";

  00c06	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set@
  00c0d	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 932  :                 state->mode = BAD;

  00c12	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 933  :                 break;

  00c1a	e9 61 fb ff ff	 jmp	 $LN966@inflate
$LN426@inflate:

; 908  :                 strm->msg = (z_const char *)"too many length or distance symbols";

  00c1f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5sym@
  00c26	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 909  :                 state->mode = BAD;

  00c2b	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 910  :                 break;

  00c33	e9 4d fb ff ff	 jmp	 $LN5@inflate
$LN429@inflate:

; 934  :             }
; 935  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 936  :             state->have = 0;

  00c38	45 89 bd 84 00
	00 00		 mov	 DWORD PTR [r13+132], r15d

; 937  :             state->mode = CODELENS;

  00c3f	41 c7 45 08 46
	3f 00 00	 mov	 DWORD PTR [r13+8], 16198 ; 00003f46H
$LN536@inflate:

; 938  :                 /* fallthrough */
; 939  :         case CODELENS:
; 940  :             while (state->have < state->nlen + state->ndist) {

  00c47	41 8b 85 80 00
	00 00		 mov	 eax, DWORD PTR [r13+128]
  00c4e	41 03 45 7c	 add	 eax, DWORD PTR [r13+124]
  00c52	41 39 85 84 00
	00 00		 cmp	 DWORD PTR [r13+132], eax
  00c59	0f 83 1e 02 00
	00		 jae	 $LN186@inflate
  00c5f	90		 npad	 1
$LL185@inflate:

; 941  :                 for (;;) {
; 942  :                     here = state->lencode[BITS(state->lenbits)];

  00c60	45 8b 45 70	 mov	 r8d, DWORD PTR [r13+112]
  00c64	b8 01 00 00 00	 mov	 eax, 1
  00c69	4d 8b 4d 60	 mov	 r9, QWORD PTR [r13+96]
  00c6d	41 8b c8	 mov	 ecx, r8d
  00c70	d3 e0		 shl	 eax, cl
  00c72	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00c75	41 8b c6	 mov	 eax, r14d
  00c78	48 23 c8	 and	 rcx, rax
  00c7b	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  00c7f	8b c8		 mov	 ecx, eax
  00c81	c1 e9 08	 shr	 ecx, 8
  00c84	0f b6 d1	 movzx	 edx, cl
  00c87	8b c8		 mov	 ecx, eax
  00c89	c1 e9 10	 shr	 ecx, 16
  00c8c	89 44 24 38	 mov	 DWORD PTR here$[rsp], eax

; 943  :                     if ((unsigned)(here.bits) <= bits) break;

  00c90	3b d3		 cmp	 edx, ebx
  00c92	76 46		 jbe	 SHORT $LN563@inflate
$LL189@inflate:

; 944  :                     PULLBYTE();

  00c94	85 f6		 test	 esi, esi
  00c96	0f 84 53 fc ff
	ff		 je	 $LN999@inflate
  00c9c	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00ca0	8b cb		 mov	 ecx, ebx
  00ca2	d3 e0		 shl	 eax, cl
  00ca4	ff ce		 dec	 esi
  00ca6	44 03 f0	 add	 r14d, eax
  00ca9	41 8b c8	 mov	 ecx, r8d
  00cac	b8 01 00 00 00	 mov	 eax, 1
  00cb1	41 8b d6	 mov	 edx, r14d
  00cb4	d3 e0		 shl	 eax, cl
  00cb6	48 ff c5	 inc	 rbp
  00cb9	ff c8		 dec	 eax
  00cbb	83 c3 08	 add	 ebx, 8
  00cbe	48 23 c2	 and	 rax, rdx
  00cc1	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  00cc5	8b c8		 mov	 ecx, eax
  00cc7	c1 e9 08	 shr	 ecx, 8
  00cca	0f b6 d1	 movzx	 edx, cl
  00ccd	8b c8		 mov	 ecx, eax
  00ccf	c1 e9 10	 shr	 ecx, 16
  00cd2	89 44 24 38	 mov	 DWORD PTR here$[rsp], eax
  00cd6	3b d3		 cmp	 edx, ebx
  00cd8	77 ba		 ja	 SHORT $LL189@inflate
$LN563@inflate:

; 945  :                 }
; 946  :                 if (here.val < 16) {

  00cda	66 83 f9 10	 cmp	 cx, 16
  00cde	73 2e		 jae	 SHORT $LN433@inflate

; 947  :                     DROPBITS(here.bits);

  00ce0	0f b6 ca	 movzx	 ecx, dl
  00ce3	41 d3 ee	 shr	 r14d, cl
  00ce6	2b d9		 sub	 ebx, ecx

; 948  :                     state->lens[state->have++] = here.val;

  00ce8	41 8b 8d 84 00
	00 00		 mov	 ecx, DWORD PTR [r13+132]
  00cef	c1 e8 10	 shr	 eax, 16
  00cf2	66 41 89 84 4d
	90 00 00 00	 mov	 WORD PTR [r13+rcx*2+144], ax
  00cfb	41 ff 85 84 00
	00 00		 inc	 DWORD PTR [r13+132]
  00d02	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]

; 949  :                 }

  00d09	e9 45 01 00 00	 jmp	 $LN611@inflate
$LN433@inflate:

; 950  :                 else {
; 951  :                     if (here.val == 16) {

  00d0e	0f b6 d2	 movzx	 edx, dl
  00d11	75 65		 jne	 SHORT $LN435@inflate

; 952  :                         NEEDBITS(here.bits + 2);

  00d13	83 c2 02	 add	 edx, 2
  00d16	3b da		 cmp	 ebx, edx
  00d18	73 25		 jae	 SHORT $LN196@inflate
  00d1a	66 0f 1f 44 00
	00		 npad	 6
$LL199@inflate:
  00d20	85 f6		 test	 esi, esi
  00d22	0f 84 c7 fb ff
	ff		 je	 $LN999@inflate
  00d28	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00d2c	8b cb		 mov	 ecx, ebx
  00d2e	d3 e0		 shl	 eax, cl
  00d30	ff ce		 dec	 esi
  00d32	44 03 f0	 add	 r14d, eax
  00d35	48 ff c5	 inc	 rbp
  00d38	83 c3 08	 add	 ebx, 8
  00d3b	3b da		 cmp	 ebx, edx
  00d3d	72 e1		 jb	 SHORT $LL199@inflate
$LN196@inflate:

; 953  :                         DROPBITS(here.bits);

  00d3f	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR here$[rsp+1]

; 954  :                         if (state->have == 0) {

  00d44	41 8b 85 84 00
	00 00		 mov	 eax, DWORD PTR [r13+132]
  00d4b	2b d9		 sub	 ebx, ecx
  00d4d	41 d3 ee	 shr	 r14d, cl
  00d50	85 c0		 test	 eax, eax
  00d52	0f 84 11 01 00
	00		 je	 $LN569@inflate

; 955  :                             strm->msg = (z_const char *)"invalid bit length repeat";
; 956  :                             state->mode = BAD;
; 957  :                             break;
; 958  :                         }
; 959  :                         len = state->lens[state->have - 1];
; 960  :                         copy = 3 + BITS(2);

  00d58	41 8b d6	 mov	 edx, r14d

; 961  :                         DROPBITS(2);

  00d5b	83 c3 fe	 add	 ebx, -2			; fffffffeH
  00d5e	83 e2 03	 and	 edx, 3
  00d61	41 c1 ee 02	 shr	 r14d, 2
  00d65	83 c2 03	 add	 edx, 3
  00d68	ff c8		 dec	 eax
  00d6a	45 0f b7 8c 45
	90 00 00 00	 movzx	 r9d, WORD PTR [r13+rax*2+144]

; 962  :                     }

  00d73	e9 99 00 00 00	 jmp	 $LN236@inflate
$LN435@inflate:

; 963  :                     else if (here.val == 17) {

  00d78	66 83 f9 11	 cmp	 cx, 17
  00d7c	75 45		 jne	 SHORT $LN226@inflate

; 964  :                         NEEDBITS(here.bits + 3);

  00d7e	83 c2 03	 add	 edx, 3
  00d81	3b da		 cmp	 ebx, edx
  00d83	73 1f		 jae	 SHORT $LN210@inflate
$LL213@inflate:
  00d85	85 f6		 test	 esi, esi
  00d87	0f 84 62 fb ff
	ff		 je	 $LN999@inflate
  00d8d	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00d91	8b cb		 mov	 ecx, ebx
  00d93	d3 e0		 shl	 eax, cl
  00d95	ff ce		 dec	 esi
  00d97	44 03 f0	 add	 r14d, eax
  00d9a	48 ff c5	 inc	 rbp
  00d9d	83 c3 08	 add	 ebx, 8
  00da0	3b da		 cmp	 ebx, edx
  00da2	72 e1		 jb	 SHORT $LL213@inflate
$LN210@inflate:

; 965  :                         DROPBITS(here.bits);

  00da4	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR here$[rsp+1]

; 966  :                         len = 0;
; 967  :                         copy = 3 + BITS(3);
; 968  :                         DROPBITS(3);

  00da9	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00dae	41 d3 ee	 shr	 r14d, cl
  00db1	45 8b cf	 mov	 r9d, r15d
  00db4	41 8b d6	 mov	 edx, r14d
  00db7	83 e2 07	 and	 edx, 7
  00dba	83 c2 03	 add	 edx, 3
  00dbd	41 c1 ee 03	 shr	 r14d, 3

; 969  :                     }

  00dc1	eb 4a		 jmp	 SHORT $LN1192@inflate
$LN226@inflate:

; 970  :                     else {
; 971  :                         NEEDBITS(here.bits + 7);

  00dc3	83 c2 07	 add	 edx, 7
  00dc6	3b da		 cmp	 ebx, edx
  00dc8	73 25		 jae	 SHORT $LN224@inflate
  00dca	66 0f 1f 44 00
	00		 npad	 6
$LL227@inflate:
  00dd0	85 f6		 test	 esi, esi
  00dd2	0f 84 17 fb ff
	ff		 je	 $LN999@inflate
  00dd8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  00ddc	8b cb		 mov	 ecx, ebx
  00dde	d3 e0		 shl	 eax, cl
  00de0	ff ce		 dec	 esi
  00de2	44 03 f0	 add	 r14d, eax
  00de5	48 ff c5	 inc	 rbp
  00de8	83 c3 08	 add	 ebx, 8
  00deb	3b da		 cmp	 ebx, edx
  00ded	72 e1		 jb	 SHORT $LL227@inflate
$LN224@inflate:

; 972  :                         DROPBITS(here.bits);

  00def	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR here$[rsp+1]

; 973  :                         len = 0;
; 974  :                         copy = 11 + BITS(7);
; 975  :                         DROPBITS(7);

  00df4	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00df9	41 d3 ee	 shr	 r14d, cl
  00dfc	45 0f b7 cf	 movzx	 r9d, r15w
  00e00	41 8b d6	 mov	 edx, r14d
  00e03	83 e2 7f	 and	 edx, 127		; 0000007fH
  00e06	83 c2 0b	 add	 edx, 11
  00e09	41 c1 ee 07	 shr	 r14d, 7
$LN1192@inflate:

; 976  :                     }
; 977  :                     if (state->have + copy > state->nlen + state->ndist) {

  00e0d	2b c1		 sub	 eax, ecx
  00e0f	03 d8		 add	 ebx, eax
$LN236@inflate:
  00e11	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]
  00e18	41 8b 85 80 00
	00 00		 mov	 eax, DWORD PTR [r13+128]
  00e1f	41 03 45 7c	 add	 eax, DWORD PTR [r13+124]
  00e23	41 8d 0c 10	 lea	 ecx, DWORD PTR [r8+rdx]
  00e27	3b c8		 cmp	 ecx, eax
  00e29	77 3e		 ja	 SHORT $LN569@inflate
  00e2b	0f 1f 44 00 00	 npad	 5
$LL238@inflate:

; 978  :                         strm->msg = (z_const char *)"invalid bit length repeat";
; 979  :                         state->mode = BAD;
; 980  :                         break;
; 981  :                     }
; 982  :                     while (copy--)
; 983  :                         state->lens[state->have++] = (unsigned short)len;

  00e30	41 8b c0	 mov	 eax, r8d
  00e33	66 45 89 8c 45
	90 00 00 00	 mov	 WORD PTR [r13+rax*2+144], r9w
  00e3c	45 8b 85 84 00
	00 00		 mov	 r8d, DWORD PTR [r13+132]
  00e43	45 8d 40 01	 lea	 r8d, DWORD PTR [r8+1]
  00e47	45 89 85 84 00
	00 00		 mov	 DWORD PTR [r13+132], r8d
  00e4e	83 c2 ff	 add	 edx, -1			; ffffffffH
  00e51	75 dd		 jne	 SHORT $LL238@inflate
$LN611@inflate:

; 938  :                 /* fallthrough */
; 939  :         case CODELENS:
; 940  :             while (state->have < state->nlen + state->ndist) {

  00e53	41 8b 85 80 00
	00 00		 mov	 eax, DWORD PTR [r13+128]
  00e5a	41 03 45 7c	 add	 eax, DWORD PTR [r13+124]
  00e5e	44 3b c0	 cmp	 r8d, eax
  00e61	0f 82 f9 fd ff
	ff		 jb	 $LL185@inflate
  00e67	eb 14		 jmp	 SHORT $LN186@inflate
$LN569@inflate:

; 984  :                 }
; 985  :             }
; 986  : 
; 987  :             /* handle error breaks in while */
; 988  :             if (state->mode == BAD) break;

  00e69	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat@
  00e70	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  00e75	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
$LN186@inflate:
  00e7d	41 81 7d 08 51
	3f 00 00	 cmp	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00e85	0f 84 f5 f8 ff
	ff		 je	 $LN966@inflate

; 989  : 
; 990  :             /* check for end-of-block code (better have one) */
; 991  :             if (state->lens[256] == 0) {

  00e8b	66 41 83 bd 90
	02 00 00 00	 cmp	 WORD PTR [r13+656], 0
  00e94	75 19		 jne	 SHORT $LN445@inflate

; 992  :                 strm->msg = (z_const char *)"invalid code -- missing end-of-block";

  00e96	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9@
  00e9d	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 993  :                 state->mode = BAD;

  00ea2	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 994  :                 break;

  00eaa	e9 d1 f8 ff ff	 jmp	 $LN966@inflate
$LN445@inflate:

; 995  :             }
; 996  : 
; 997  :             /* build code tables -- note: do not change the lenbits or distbits
; 998  :                values here (9 and 6) without reading the comments in inftrees.h
; 999  :                concerning the ENOUGH constants, which depend on those values */
; 1000 :             state->next = state->codes;
; 1001 :             state->lencode = (const code FAR *)(state->next);
; 1002 :             state->lenbits = 9;
; 1003 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00eaf	45 8b 45 7c	 mov	 r8d, DWORD PTR [r13+124]
  00eb3	49 8d 85 50 05
	00 00		 lea	 rax, QWORD PTR [r13+1360]
  00eba	49 89 85 88 00
	00 00		 mov	 QWORD PTR [r13+136], rax
  00ec1	4d 8d bd 10 03
	00 00		 lea	 r15, QWORD PTR [r13+784]
  00ec8	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  00ecc	49 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR [r13+144]
  00ed3	49 8d 45 70	 lea	 rax, QWORD PTR [r13+112]
  00ed7	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00edc	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00ee3	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9
  00ee9	b9 01 00 00 00	 mov	 ecx, 1
  00eee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ef3	e8 00 00 00 00	 call	 inflate_table
  00ef8	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$1$[rsp], eax

; 1004 :                                 &(state->lenbits), state->work);
; 1005 :             if (ret) {

  00eff	85 c0		 test	 eax, eax
  00f01	74 19		 je	 SHORT $LN446@inflate

; 1006 :                 strm->msg = (z_const char *)"invalid literal/lengths set";

  00f03	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set@
  00f0a	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  00f0f	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00f17	e9 5f f8 ff ff	 jmp	 $LN1196@inflate
$LN446@inflate:

; 1007 :                 state->mode = BAD;
; 1008 :                 break;
; 1009 :             }
; 1010 :             state->distcode = (const code FAR *)(state->next);

  00f1c	49 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR [r13+136]

; 1011 :             state->distbits = 6;

  00f23	49 8d 4d 74	 lea	 rcx, QWORD PTR [r13+116]

; 1012 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00f27	45 8b 85 80 00
	00 00		 mov	 r8d, DWORD PTR [r13+128]
  00f2e	4d 8d 8d 88 00
	00 00		 lea	 r9, QWORD PTR [r13+136]
  00f35	49 89 45 68	 mov	 QWORD PTR [r13+104], rax
  00f39	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00f3d	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00f43	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  00f48	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00f4d	b9 02 00 00 00	 mov	 ecx, 2
  00f52	48 8d 14 45 90
	00 00 00	 lea	 rdx, QWORD PTR [rax*2+144]
  00f5a	49 03 d5	 add	 rdx, r13
  00f5d	e8 00 00 00 00	 call	 inflate_table
  00f62	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ret$1$[rsp], eax
  00f69	44 8b f8	 mov	 r15d, eax

; 1013 :                             &(state->next), &(state->distbits), state->work);
; 1014 :             if (ret) {

  00f6c	85 c0		 test	 eax, eax
  00f6e	74 19		 je	 SHORT $LN447@inflate

; 1015 :                 strm->msg = (z_const char *)"invalid distances set";

  00f70	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set@
  00f77	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  00f7c	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  00f84	e9 f2 f7 ff ff	 jmp	 $LN1196@inflate
$LN447@inflate:

; 1016 :                 state->mode = BAD;
; 1017 :                 break;
; 1018 :             }
; 1019 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1020 :             state->mode = LEN_;
; 1021 :             if (flush == Z_TREES) goto inf_leave;

  00f89	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR flush$[rsp]
  00f90	41 c7 45 08 47
	3f 00 00	 mov	 DWORD PTR [r13+8], 16199 ; 00003f47H
  00f98	83 f9 06	 cmp	 ecx, 6
  00f9b	0f 84 fa 06 00
	00		 je	 $LN977@inflate
  00fa1	4c 8b 4c 24 40	 mov	 r9, QWORD PTR put$1$[rsp]
  00fa6	45 33 ff	 xor	 r15d, r15d
  00fa9	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR out$1$[rsp]
  00fb1	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
$LN448@inflate:

; 1022 :                 /* fallthrough */
; 1023 :         case LEN_:
; 1024 :             state->mode = LEN;

  00fb6	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H
$LN450@inflate:

; 1025 :                 /* fallthrough */
; 1026 :         case LEN:
; 1027 :             if (have >= 6 && left >= 258) {

  00fbe	83 fe 06	 cmp	 esi, 6
  00fc1	72 73		 jb	 SHORT $LN451@inflate
  00fc3	41 81 fa 02 01
	00 00		 cmp	 r10d, 258		; 00000102H
  00fca	72 6a		 jb	 SHORT $LN451@inflate

; 1028 :                 RESTORE();

  00fcc	48 8b 7c 24 48	 mov	 rdi, QWORD PTR $T1[rsp]

; 1029 :                 inflate_fast(strm, out);

  00fd1	41 8b d0	 mov	 edx, r8d
  00fd4	45 89 54 24 18	 mov	 DWORD PTR [r12+24], r10d
  00fd9	49 8b cc	 mov	 rcx, r12
  00fdc	49 89 2c 24	 mov	 QWORD PTR [r12], rbp
  00fe0	41 89 74 24 08	 mov	 DWORD PTR [r12+8], esi
  00fe5	4c 89 0f	 mov	 QWORD PTR [rdi], r9
  00fe8	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  00fec	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  00ff0	e8 00 00 00 00	 call	 inflate_fast

; 1030 :                 LOAD();
; 1031 :                 if (state->mode == TYPE)

  00ff5	41 81 7d 08 3f
	3f 00 00	 cmp	 DWORD PTR [r13+8], 16191 ; 00003f3fH
  00ffd	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
  01000	45 8b 54 24 18	 mov	 r10d, DWORD PTR [r12+24]
  01005	49 8b 2c 24	 mov	 rbp, QWORD PTR [r12]
  01009	41 8b 74 24 08	 mov	 esi, DWORD PTR [r12+8]
  0100e	45 8b 75 48	 mov	 r14d, DWORD PTR [r13+72]
  01012	41 8b 5d 4c	 mov	 ebx, DWORD PTR [r13+76]
  01016	4c 89 4c 24 40	 mov	 QWORD PTR put$1$[rsp], r9
  0101b	44 89 54 24 30	 mov	 DWORD PTR left$1$[rsp], r10d
  01020	0f 85 5f f7 ff
	ff		 jne	 $LN5@inflate

; 1032 :                     state->back = -1;

  01026	41 c7 85 e4 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7140], -1

; 1033 :                 break;

  01031	e9 4f f7 ff ff	 jmp	 $LN5@inflate
$LN451@inflate:

; 1034 :             }
; 1035 :             state->back = 0;
; 1036 :             for (;;) {
; 1037 :                 here = state->lencode[BITS(state->lenbits)];

  01036	45 8b 45 70	 mov	 r8d, DWORD PTR [r13+112]
  0103a	b8 01 00 00 00	 mov	 eax, 1
  0103f	49 8b 7d 60	 mov	 rdi, QWORD PTR [r13+96]
  01043	41 8b c8	 mov	 ecx, r8d
  01046	d3 e0		 shl	 eax, cl
  01048	45 89 bd e4 1b
	00 00		 mov	 DWORD PTR [r13+7140], r15d
  0104f	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  01052	41 8b c6	 mov	 eax, r14d
  01055	48 23 c8	 and	 rcx, rax
  01058	8b 04 8f	 mov	 eax, DWORD PTR [rdi+rcx*4]
  0105b	8b c8		 mov	 ecx, eax
  0105d	c1 e9 08	 shr	 ecx, 8
  01060	0f b6 c9	 movzx	 ecx, cl

; 1038 :                 if ((unsigned)(here.bits) <= bits) break;

  01063	3b cb		 cmp	 ecx, ebx
  01065	76 3c		 jbe	 SHORT $LN570@inflate
$LL248@inflate:

; 1039 :                 PULLBYTE();

  01067	85 f6		 test	 esi, esi
  01069	0f 84 80 f8 ff
	ff		 je	 $LN999@inflate
  0106f	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  01073	8b cb		 mov	 ecx, ebx
  01075	d3 e0		 shl	 eax, cl
  01077	ff ce		 dec	 esi
  01079	44 03 f0	 add	 r14d, eax
  0107c	41 8b c8	 mov	 ecx, r8d
  0107f	b8 01 00 00 00	 mov	 eax, 1
  01084	41 8b d6	 mov	 edx, r14d
  01087	d3 e0		 shl	 eax, cl
  01089	48 ff c5	 inc	 rbp
  0108c	ff c8		 dec	 eax
  0108e	83 c3 08	 add	 ebx, 8
  01091	48 23 c2	 and	 rax, rdx
  01094	8b 04 87	 mov	 eax, DWORD PTR [rdi+rax*4]
  01097	8b c8		 mov	 ecx, eax
  01099	c1 e9 08	 shr	 ecx, 8
  0109c	0f b6 c9	 movzx	 ecx, cl
  0109f	3b cb		 cmp	 ecx, ebx
  010a1	77 c4		 ja	 SHORT $LL248@inflate
$LN570@inflate:

; 1040 :             }
; 1041 :             if (here.op && (here.op & 0xf0) == 0) {

  010a3	84 c0		 test	 al, al
  010a5	0f 84 b7 00 00
	00		 je	 $LN263@inflate
  010ab	a8 f0		 test	 al, 240			; 000000f0H
  010ad	0f 85 af 00 00
	00		 jne	 $LN263@inflate

; 1042 :                 last = here;
; 1043 :                 for (;;) {
; 1044 :                     here = state->lencode[last.val +

  010b3	8b c8		 mov	 ecx, eax
  010b5	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax

; 1045 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1046 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  010b9	44 0f b6 5c 24
	39		 movzx	 r11d, BYTE PTR last$[rsp+1]
  010bf	41 b8 01 00 00
	00		 mov	 r8d, 1
  010c5	c1 e9 08	 shr	 ecx, 8
  010c8	8b d0		 mov	 edx, eax
  010ca	44 0f b6 c9	 movzx	 r9d, cl
  010ce	0f b6 c8	 movzx	 ecx, al
  010d1	41 03 c9	 add	 ecx, r9d
  010d4	c1 e8 10	 shr	 eax, 16
  010d7	41 d3 e0	 shl	 r8d, cl
  010da	41 8b c9	 mov	 ecx, r9d
  010dd	41 ff c8	 dec	 r8d
  010e0	45 23 c6	 and	 r8d, r14d
  010e3	41 d3 e8	 shr	 r8d, cl
  010e6	44 03 c0	 add	 r8d, eax
  010e9	42 8b 04 87	 mov	 eax, DWORD PTR [rdi+r8*4]
  010ed	8b c8		 mov	 ecx, eax
  010ef	c1 e9 08	 shr	 ecx, 8
  010f2	44 0f b6 c1	 movzx	 r8d, cl
  010f6	45 03 c1	 add	 r8d, r9d
  010f9	44 3b c3	 cmp	 r8d, ebx
  010fc	76 54		 jbe	 SHORT $LN260@inflate
  010fe	44 0f b7 54 24
	3a		 movzx	 r10d, WORD PTR last$[rsp+2]
$LL254@inflate:

; 1047 :                     PULLBYTE();

  01104	85 f6		 test	 esi, esi
  01106	0f 84 e3 f7 ff
	ff		 je	 $LN999@inflate
  0110c	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  01110	8b cb		 mov	 ecx, ebx
  01112	d3 e0		 shl	 eax, cl
  01114	41 b8 01 00 00
	00		 mov	 r8d, 1
  0111a	44 03 f0	 add	 r14d, eax
  0111d	0f b6 ca	 movzx	 ecx, dl
  01120	41 03 cb	 add	 ecx, r11d
  01123	ff ce		 dec	 esi
  01125	41 d3 e0	 shl	 r8d, cl
  01128	48 ff c5	 inc	 rbp
  0112b	41 ff c8	 dec	 r8d
  0112e	41 8b cb	 mov	 ecx, r11d
  01131	45 23 c6	 and	 r8d, r14d
  01134	83 c3 08	 add	 ebx, 8
  01137	41 d3 e8	 shr	 r8d, cl
  0113a	45 03 c2	 add	 r8d, r10d
  0113d	42 8b 04 87	 mov	 eax, DWORD PTR [rdi+r8*4]
  01141	8b c8		 mov	 ecx, eax
  01143	c1 e9 08	 shr	 ecx, 8
  01146	44 0f b6 c1	 movzx	 r8d, cl
  0114a	45 03 c3	 add	 r8d, r11d
  0114d	44 3b c3	 cmp	 r8d, ebx
  01150	77 b2		 ja	 SHORT $LL254@inflate
$LN260@inflate:

; 1048 :                 }
; 1049 :                 DROPBITS(last.bits);

  01152	41 8b cb	 mov	 ecx, r11d
  01155	41 d3 ee	 shr	 r14d, cl
  01158	41 2b db	 sub	 ebx, r11d

; 1050 :                 state->back += last.bits;

  0115b	41 89 8d e4 1b
	00 00		 mov	 DWORD PTR [r13+7140], ecx
$LN263@inflate:

; 1051 :             }
; 1052 :             DROPBITS(here.bits);

  01162	8b c8		 mov	 ecx, eax
  01164	c1 e9 08	 shr	 ecx, 8
  01167	0f b6 d1	 movzx	 edx, cl

; 1053 :             state->back += here.bits;

  0116a	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
  01171	8b ca		 mov	 ecx, edx
  01173	41 d3 ee	 shr	 r14d, cl
  01176	2b da		 sub	 ebx, edx

; 1054 :             state->length = (unsigned)here.val;

  01178	8b c8		 mov	 ecx, eax
  0117a	c1 e9 10	 shr	 ecx, 16
  0117d	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx

; 1055 :             if ((int)(here.op) == 0) {

  01181	84 c0		 test	 al, al
  01183	75 0d		 jne	 SHORT $LN458@inflate

; 1056 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1057 :                         "inflate:         literal '%c'\n" :
; 1058 :                         "inflate:         literal 0x%02x\n", here.val));
; 1059 :                 state->mode = LIT;

  01185	41 c7 45 08 4d
	3f 00 00	 mov	 DWORD PTR [r13+8], 16205 ; 00003f4dH

; 1060 :                 break;

  0118d	e9 e9 f5 ff ff	 jmp	 $LN1196@inflate
$LN458@inflate:

; 1061 :             }
; 1062 :             if (here.op & 32) {

  01192	a8 20		 test	 al, 32			; 00000020H
  01194	74 10		 je	 SHORT $LN459@inflate

; 1063 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1064 :                 state->back = -1;

  01196	41 c7 85 e4 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7140], -1

; 1065 :                 state->mode = TYPE;
; 1066 :                 break;

  011a1	e9 cd f5 ff ff	 jmp	 $LN1199@inflate
$LN459@inflate:

; 1067 :             }
; 1068 :             if (here.op & 64) {

  011a6	a8 40		 test	 al, 64			; 00000040H
  011a8	74 19		 je	 SHORT $LN460@inflate

; 1069 :                 strm->msg = (z_const char *)"invalid literal/length code";

  011aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code@
  011b1	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  011b6	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  011be	e9 b8 f5 ff ff	 jmp	 $LN1196@inflate
$LN460@inflate:

; 1070 :                 state->mode = BAD;
; 1071 :                 break;
; 1072 :             }
; 1073 :             state->extra = (unsigned)(here.op) & 15;

  011c3	0f b6 c8	 movzx	 ecx, al
  011c6	83 e1 0f	 and	 ecx, 15

; 1074 :             state->mode = LENEXT;

  011c9	41 c7 45 08 49
	3f 00 00	 mov	 DWORD PTR [r13+8], 16201 ; 00003f49H
  011d1	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx
$LN461@inflate:

; 1075 :                 /* fallthrough */
; 1076 :         case LENEXT:
; 1077 :             if (state->extra) {

  011d5	41 8b 55 58	 mov	 edx, DWORD PTR [r13+88]
  011d9	85 d2		 test	 edx, edx
  011db	74 41		 je	 SHORT $LN792@inflate

; 1078 :                 NEEDBITS(state->extra);

  011dd	3b da		 cmp	 ebx, edx
  011df	73 1f		 jae	 SHORT $LN264@inflate
$LL267@inflate:
  011e1	85 f6		 test	 esi, esi
  011e3	0f 84 06 f7 ff
	ff		 je	 $LN999@inflate
  011e9	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  011ed	8b cb		 mov	 ecx, ebx
  011ef	d3 e0		 shl	 eax, cl
  011f1	ff ce		 dec	 esi
  011f3	44 03 f0	 add	 r14d, eax
  011f6	48 ff c5	 inc	 rbp
  011f9	83 c3 08	 add	 ebx, 8
  011fc	3b da		 cmp	 ebx, edx
  011fe	72 e1		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1079 :                 state->length += BITS(state->extra);

  01200	8b ca		 mov	 ecx, edx
  01202	b8 01 00 00 00	 mov	 eax, 1
  01207	d3 e0		 shl	 eax, cl

; 1080 :                 DROPBITS(state->extra);

  01209	2b da		 sub	 ebx, edx
  0120b	ff c8		 dec	 eax
  0120d	41 23 c6	 and	 eax, r14d
  01210	41 d3 ee	 shr	 r14d, cl
  01213	41 01 45 50	 add	 DWORD PTR [r13+80], eax

; 1081 :                 state->back += state->extra;

  01217	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
$LN792@inflate:

; 1082 :             }
; 1083 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1084 :             state->was = state->length;

  0121e	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]
  01222	41 89 85 e8 1b
	00 00		 mov	 DWORD PTR [r13+7144], eax

; 1085 :             state->mode = DIST;

  01229	41 c7 45 08 4a
	3f 00 00	 mov	 DWORD PTR [r13+8], 16202 ; 00003f4aH
$LN464@inflate:

; 1086 :                 /* fallthrough */
; 1087 :         case DIST:
; 1088 :             for (;;) {
; 1089 :                 here = state->distcode[BITS(state->distbits)];

  01231	45 8b 45 74	 mov	 r8d, DWORD PTR [r13+116]
  01235	b8 01 00 00 00	 mov	 eax, 1
  0123a	4d 8b 55 68	 mov	 r10, QWORD PTR [r13+104]
  0123e	41 8b c8	 mov	 ecx, r8d
  01241	d3 e0		 shl	 eax, cl
  01243	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  01246	41 8b c6	 mov	 eax, r14d
  01249	48 23 c8	 and	 rcx, rax
  0124c	41 8b 04 8a	 mov	 eax, DWORD PTR [r10+rcx*4]
  01250	8b c8		 mov	 ecx, eax
  01252	c1 e9 08	 shr	 ecx, 8
  01255	0f b6 c9	 movzx	 ecx, cl

; 1090 :                 if ((unsigned)(here.bits) <= bits) break;

  01258	3b cb		 cmp	 ecx, ebx
  0125a	76 41		 jbe	 SHORT $LN575@inflate
  0125c	0f 1f 40 00	 npad	 4
$LL277@inflate:

; 1091 :                 PULLBYTE();

  01260	85 f6		 test	 esi, esi
  01262	0f 84 87 f6 ff
	ff		 je	 $LN999@inflate
  01268	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  0126c	8b cb		 mov	 ecx, ebx
  0126e	d3 e0		 shl	 eax, cl
  01270	ff ce		 dec	 esi
  01272	44 03 f0	 add	 r14d, eax
  01275	41 8b c8	 mov	 ecx, r8d
  01278	b8 01 00 00 00	 mov	 eax, 1
  0127d	41 8b d6	 mov	 edx, r14d
  01280	d3 e0		 shl	 eax, cl
  01282	48 ff c5	 inc	 rbp
  01285	ff c8		 dec	 eax
  01287	83 c3 08	 add	 ebx, 8
  0128a	48 23 c2	 and	 rax, rdx
  0128d	41 8b 04 82	 mov	 eax, DWORD PTR [r10+rax*4]
  01291	8b c8		 mov	 ecx, eax
  01293	c1 e9 08	 shr	 ecx, 8
  01296	0f b6 c9	 movzx	 ecx, cl
  01299	3b cb		 cmp	 ecx, ebx
  0129b	77 c3		 ja	 SHORT $LL277@inflate
$LN575@inflate:

; 1092 :             }
; 1093 :             if ((here.op & 0xf0) == 0) {

  0129d	a8 f0		 test	 al, 240			; 000000f0H
  0129f	0f 85 aa 00 00
	00		 jne	 $LN292@inflate

; 1094 :                 last = here;
; 1095 :                 for (;;) {
; 1096 :                     here = state->distcode[last.val +

  012a5	8b c8		 mov	 ecx, eax
  012a7	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax

; 1097 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1098 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  012ab	0f b6 7c 24 39	 movzx	 edi, BYTE PTR last$[rsp+1]
  012b0	41 b8 01 00 00
	00		 mov	 r8d, 1
  012b6	c1 e9 08	 shr	 ecx, 8
  012b9	8b d0		 mov	 edx, eax
  012bb	44 0f b6 c9	 movzx	 r9d, cl
  012bf	0f b6 c8	 movzx	 ecx, al
  012c2	41 03 c9	 add	 ecx, r9d
  012c5	c1 e8 10	 shr	 eax, 16
  012c8	41 d3 e0	 shl	 r8d, cl
  012cb	41 8b c9	 mov	 ecx, r9d
  012ce	41 ff c8	 dec	 r8d
  012d1	45 23 c6	 and	 r8d, r14d
  012d4	41 d3 e8	 shr	 r8d, cl
  012d7	44 03 c0	 add	 r8d, eax
  012da	43 8b 04 82	 mov	 eax, DWORD PTR [r10+r8*4]
  012de	8b c8		 mov	 ecx, eax
  012e0	c1 e9 08	 shr	 ecx, 8
  012e3	44 0f b6 c1	 movzx	 r8d, cl
  012e7	45 03 c1	 add	 r8d, r9d
  012ea	44 3b c3	 cmp	 r8d, ebx
  012ed	76 52		 jbe	 SHORT $LN289@inflate
  012ef	44 0f b7 5c 24
	3a		 movzx	 r11d, WORD PTR last$[rsp+2]
$LL283@inflate:

; 1099 :                     PULLBYTE();

  012f5	85 f6		 test	 esi, esi
  012f7	0f 84 f2 f5 ff
	ff		 je	 $LN999@inflate
  012fd	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  01301	8b cb		 mov	 ecx, ebx
  01303	d3 e0		 shl	 eax, cl
  01305	41 b8 01 00 00
	00		 mov	 r8d, 1
  0130b	44 03 f0	 add	 r14d, eax
  0130e	0f b6 ca	 movzx	 ecx, dl
  01311	03 cf		 add	 ecx, edi
  01313	ff ce		 dec	 esi
  01315	41 d3 e0	 shl	 r8d, cl
  01318	48 ff c5	 inc	 rbp
  0131b	41 ff c8	 dec	 r8d
  0131e	8b cf		 mov	 ecx, edi
  01320	45 23 c6	 and	 r8d, r14d
  01323	83 c3 08	 add	 ebx, 8
  01326	41 d3 e8	 shr	 r8d, cl
  01329	45 03 c3	 add	 r8d, r11d
  0132c	43 8b 04 82	 mov	 eax, DWORD PTR [r10+r8*4]
  01330	8b c8		 mov	 ecx, eax
  01332	c1 e9 08	 shr	 ecx, 8
  01335	44 0f b6 c1	 movzx	 r8d, cl
  01339	44 03 c7	 add	 r8d, edi
  0133c	44 3b c3	 cmp	 r8d, ebx
  0133f	77 b4		 ja	 SHORT $LL283@inflate
$LN289@inflate:

; 1100 :                 }
; 1101 :                 DROPBITS(last.bits);

  01341	8b cf		 mov	 ecx, edi
  01343	2b df		 sub	 ebx, edi
  01345	41 d3 ee	 shr	 r14d, cl

; 1102 :                 state->back += last.bits;

  01348	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
$LN292@inflate:

; 1103 :             }
; 1104 :             DROPBITS(here.bits);
; 1105 :             state->back += here.bits;
; 1106 :             if (here.op & 64) {

  0134f	4c 8b 4c 24 40	 mov	 r9, QWORD PTR put$1$[rsp]
  01354	8b c8		 mov	 ecx, eax
  01356	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
  0135b	c1 e9 08	 shr	 ecx, 8
  0135e	0f b6 c9	 movzx	 ecx, cl
  01361	41 01 8d e4 1b
	00 00		 add	 DWORD PTR [r13+7140], ecx
  01368	2b d9		 sub	 ebx, ecx
  0136a	41 d3 ee	 shr	 r14d, cl
  0136d	a8 40		 test	 al, 64			; 00000040H
  0136f	74 19		 je	 SHORT $LN470@inflate

; 1107 :                 strm->msg = (z_const char *)"invalid distance code";

  01371	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code@
  01378	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1108 :                 state->mode = BAD;

  0137d	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1109 :                 break;

  01385	e9 fb f3 ff ff	 jmp	 $LN5@inflate
$LN470@inflate:
  0138a	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR out$1$[rsp]

; 1110 :             }
; 1111 :             state->offset = (unsigned)here.val;

  01392	8b c8		 mov	 ecx, eax
  01394	c1 e9 10	 shr	 ecx, 16
  01397	41 89 4d 54	 mov	 DWORD PTR [r13+84], ecx

; 1112 :             state->extra = (unsigned)(here.op) & 15;

  0139b	0f b6 c8	 movzx	 ecx, al
  0139e	83 e1 0f	 and	 ecx, 15

; 1113 :             state->mode = DISTEXT;

  013a1	41 c7 45 08 4b
	3f 00 00	 mov	 DWORD PTR [r13+8], 16203 ; 00003f4bH
  013a9	41 89 4d 58	 mov	 DWORD PTR [r13+88], ecx
$LN471@inflate:

; 1114 :                 /* fallthrough */
; 1115 :         case DISTEXT:
; 1116 :             if (state->extra) {

  013ad	41 8b 55 58	 mov	 edx, DWORD PTR [r13+88]
  013b1	85 d2		 test	 edx, edx
  013b3	74 48		 je	 SHORT $LN794@inflate

; 1117 :                 NEEDBITS(state->extra);

  013b5	3b da		 cmp	 ebx, edx
  013b7	73 26		 jae	 SHORT $LN293@inflate
  013b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL296@inflate:
  013c0	85 f6		 test	 esi, esi
  013c2	0f 84 27 f5 ff
	ff		 je	 $LN999@inflate
  013c8	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  013cc	8b cb		 mov	 ecx, ebx
  013ce	d3 e0		 shl	 eax, cl
  013d0	ff ce		 dec	 esi
  013d2	44 03 f0	 add	 r14d, eax
  013d5	48 ff c5	 inc	 rbp
  013d8	83 c3 08	 add	 ebx, 8
  013db	3b da		 cmp	 ebx, edx
  013dd	72 e1		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1118 :                 state->offset += BITS(state->extra);

  013df	8b ca		 mov	 ecx, edx
  013e1	b8 01 00 00 00	 mov	 eax, 1
  013e6	d3 e0		 shl	 eax, cl

; 1119 :                 DROPBITS(state->extra);

  013e8	2b da		 sub	 ebx, edx
  013ea	ff c8		 dec	 eax
  013ec	41 23 c6	 and	 eax, r14d
  013ef	41 d3 ee	 shr	 r14d, cl
  013f2	41 01 45 54	 add	 DWORD PTR [r13+84], eax

; 1120 :                 state->back += state->extra;

  013f6	41 01 95 e4 1b
	00 00		 add	 DWORD PTR [r13+7140], edx
$LN794@inflate:

; 1121 :             }
; 1122 : #ifdef INFLATE_STRICT
; 1123 :             if (state->offset > state->dmax) {
; 1124 :                 strm->msg = (z_const char *)"invalid distance too far back";
; 1125 :                 state->mode = BAD;
; 1126 :                 break;
; 1127 :             }
; 1128 : #endif
; 1129 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1130 :             state->mode = MATCH;

  013fd	41 c7 45 08 4c
	3f 00 00	 mov	 DWORD PTR [r13+8], 16204 ; 00003f4cH
$LN474@inflate:

; 1131 :                 /* fallthrough */
; 1132 :         case MATCH:
; 1133 :             if (left == 0) goto inf_leave;

  01405	45 85 d2	 test	 r10d, r10d
  01408	0f 84 e1 f4 ff
	ff		 je	 $LN999@inflate

; 1134 :             copy = out - left;

  0140e	41 8b c0	 mov	 eax, r8d

; 1135 :             if (state->offset > copy) {         /* copy from window */

  01411	45 8b 45 54	 mov	 r8d, DWORD PTR [r13+84]
  01415	41 2b c2	 sub	 eax, r10d
  01418	44 3b c0	 cmp	 r8d, eax
  0141b	76 5c		 jbe	 SHORT $LN476@inflate

; 1136 :                 copy = state->offset - copy;

  0141d	44 2b c0	 sub	 r8d, eax

; 1137 :                 if (copy > state->whave) {

  01420	45 3b 45 38	 cmp	 r8d, DWORD PTR [r13+56]
  01424	76 23		 jbe	 SHORT $LN479@inflate

; 1138 :                     if (state->sane) {

  01426	41 83 bd e0 1b
	00 00 00	 cmp	 DWORD PTR [r13+7136], 0
  0142e	74 19		 je	 SHORT $LN479@inflate

; 1139 :                         strm->msg = (z_const char *)"invalid distance too far back";

  01430	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back@
  01437	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1140 :                         state->mode = BAD;

  0143c	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1141 :                         break;

  01444	e9 3c f3 ff ff	 jmp	 $LN5@inflate
$LN479@inflate:

; 1142 :                     }
; 1143 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1144 :                     Trace((stderr, "inflate.c too far\n"));
; 1145 :                     copy -= state->whave;
; 1146 :                     if (copy > state->length) copy = state->length;
; 1147 :                     if (copy > left) copy = left;
; 1148 :                     left -= copy;
; 1149 :                     state->length -= copy;
; 1150 :                     do {
; 1151 :                         *put++ = 0;
; 1152 :                     } while (--copy);
; 1153 :                     if (state->length == 0) state->mode = LEN;
; 1154 :                     break;
; 1155 : #endif
; 1156 :                 }
; 1157 :                 if (copy > state->wnext) {

  01449	41 8b 45 3c	 mov	 eax, DWORD PTR [r13+60]
  0144d	49 8b 4d 40	 mov	 rcx, QWORD PTR [r13+64]
  01451	44 3b c0	 cmp	 r8d, eax
  01454	76 0c		 jbe	 SHORT $LN480@inflate

; 1158 :                     copy -= state->wnext;
; 1159 :                     from = state->window + (state->wsize - copy);

  01456	41 8b 55 34	 mov	 edx, DWORD PTR [r13+52]
  0145a	44 2b c0	 sub	 r8d, eax
  0145d	41 2b d0	 sub	 edx, r8d

; 1160 :                 }

  01460	eb 05		 jmp	 SHORT $LN1193@inflate
$LN480@inflate:

; 1161 :                 else
; 1162 :                     from = state->window + (state->wnext - copy);

  01462	41 2b c0	 sub	 eax, r8d
  01465	8b d0		 mov	 edx, eax
$LN1193@inflate:

; 1163 :                 if (copy > state->length) copy = state->length;

  01467	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]
  0146b	48 03 d1	 add	 rdx, rcx

; 1164 :             }

  0146e	44 3b c0	 cmp	 r8d, eax
  01471	8b c8		 mov	 ecx, eax
  01473	41 0f 46 c8	 cmovbe	 ecx, r8d
  01477	eb 0c		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1165 :             else {                              /* copy from output */
; 1166 :                 from = put - state->offset;
; 1167 :                 copy = state->length;

  01479	41 8b 45 50	 mov	 eax, DWORD PTR [r13+80]
  0147d	49 8b d1	 mov	 rdx, r9
  01480	49 2b d0	 sub	 rdx, r8
  01483	8b c8		 mov	 ecx, eax
$LN477@inflate:

; 1168 :             }
; 1169 :             if (copy > left) copy = left;

  01485	41 3b ca	 cmp	 ecx, r10d
  01488	41 0f 47 ca	 cmova	 ecx, r10d

; 1170 :             left -= copy;

  0148c	44 2b d1	 sub	 r10d, ecx

; 1171 :             state->length -= copy;

  0148f	2b c1		 sub	 eax, ecx
  01491	44 89 54 24 30	 mov	 DWORD PTR left$1$[rsp], r10d
  01496	49 2b d1	 sub	 rdx, r9
  01499	41 89 45 50	 mov	 DWORD PTR [r13+80], eax
  0149d	0f 1f 00	 npad	 3
$LL306@inflate:

; 1172 :             do {
; 1173 :                 *put++ = *from++;

  014a0	42 0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+r9]
  014a5	41 88 01	 mov	 BYTE PTR [r9], al
  014a8	49 ff c1	 inc	 r9

; 1174 :             } while (--copy);

  014ab	83 c1 ff	 add	 ecx, -1			; ffffffffH
  014ae	75 f0		 jne	 SHORT $LL306@inflate

; 1175 :             if (state->length == 0) state->mode = LEN;

  014b0	4c 89 4c 24 40	 mov	 QWORD PTR put$1$[rsp], r9
  014b5	41 39 4d 50	 cmp	 DWORD PTR [r13+80], ecx
  014b9	0f 85 c6 f2 ff
	ff		 jne	 $LN5@inflate
  014bf	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 1176 :             break;

  014c7	e9 b9 f2 ff ff	 jmp	 $LN5@inflate
$LN485@inflate:

; 1177 :         case LIT:
; 1178 :             if (left == 0) goto inf_leave;

  014cc	45 85 d2	 test	 r10d, r10d
  014cf	0f 84 1a f4 ff
	ff		 je	 $LN999@inflate

; 1179 :             *put++ = (unsigned char)(state->length);

  014d5	41 0f b6 45 50	 movzx	 eax, BYTE PTR [r13+80]
  014da	41 88 01	 mov	 BYTE PTR [r9], al
  014dd	49 ff c1	 inc	 r9

; 1180 :             left--;

  014e0	41 ff ca	 dec	 r10d
  014e3	4c 89 4c 24 40	 mov	 QWORD PTR put$1$[rsp], r9
  014e8	44 89 54 24 30	 mov	 DWORD PTR left$1$[rsp], r10d

; 1181 :             state->mode = LEN;

  014ed	41 c7 45 08 48
	3f 00 00	 mov	 DWORD PTR [r13+8], 16200 ; 00003f48H

; 1182 :             break;

  014f5	e9 8b f2 ff ff	 jmp	 $LN5@inflate
$LN487@inflate:

; 1183 :         case CHECK:
; 1184 :             if (state->wrap) {

  014fa	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  014ff	0f 84 c3 00 00
	00		 je	 $LN1002@inflate

; 1185 :                 NEEDBITS(32);

  01505	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01508	73 26		 jae	 SHORT $LN307@inflate
  0150a	66 0f 1f 44 00
	00		 npad	 6
$LL310@inflate:
  01510	85 f6		 test	 esi, esi
  01512	0f 84 d7 f3 ff
	ff		 je	 $LN999@inflate
  01518	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  0151c	8b cb		 mov	 ecx, ebx
  0151e	d3 e0		 shl	 eax, cl
  01520	ff ce		 dec	 esi
  01522	44 03 f0	 add	 r14d, eax
  01525	48 ff c5	 inc	 rbp
  01528	83 c3 08	 add	 ebx, 8
  0152b	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0152e	72 e0		 jb	 SHORT $LL310@inflate
$LN307@inflate:

; 1186 :                 out -= left;

  01530	45 2b c2	 sub	 r8d, r10d

; 1187 :                 strm->total_out += out;

  01533	45 01 44 24 1c	 add	 DWORD PTR [r12+28], r8d

; 1188 :                 state->total += out;

  01538	45 01 45 24	 add	 DWORD PTR [r13+36], r8d

; 1189 :                 if ((state->wrap & 4) && out)

  0153c	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  01541	74 38		 je	 SHORT $LN490@inflate
  01543	45 85 c0	 test	 r8d, r8d
  01546	74 33		 je	 SHORT $LN490@inflate

; 1190 :                     strm->adler = state->check =

  01548	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  0154c	49 8b d1	 mov	 rdx, r9
  0154f	41 8b c0	 mov	 eax, r8d
  01552	48 2b d0	 sub	 rdx, rax
  01555	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  0155a	74 07		 je	 SHORT $LN512@inflate
  0155c	e8 00 00 00 00	 call	 crc32
  01561	eb 05		 jmp	 SHORT $LN513@inflate
$LN512@inflate:
  01563	e8 00 00 00 00	 call	 adler32
$LN513@inflate:
  01568	4c 8b 4c 24 40	 mov	 r9, QWORD PTR put$1$[rsp]
  0156d	44 8b 54 24 30	 mov	 r10d, DWORD PTR left$1$[rsp]
  01572	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  01576	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN490@inflate:

; 1191 :                         UPDATE_CHECK(state->check, put - out, out);
; 1192 :                 out = left;
; 1193 :                 if ((state->wrap & 4) && (

  0157b	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  01580	41 8b fa	 mov	 edi, r10d
  01583	44 89 94 24 a0
	00 00 00	 mov	 DWORD PTR out$1$[rsp], r10d
  0158b	74 2b		 je	 SHORT $LN317@inflate
  0158d	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  01592	41 8b c6	 mov	 eax, r14d
  01595	75 02		 jne	 SHORT $LN515@inflate
  01597	0f c8		 bswap	 eax
$LN515@inflate:
  01599	41 3b 45 20	 cmp	 eax, DWORD PTR [r13+32]
  0159d	74 19		 je	 SHORT $LN317@inflate

; 1194 : #ifdef GUNZIP
; 1195 :                      state->flags ? hold :
; 1196 : #endif
; 1197 :                      ZSWAP32(hold)) != state->check) {
; 1198 :                     strm->msg = (z_const char *)"incorrect data check";

  0159f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check@
  015a6	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1199 :                     state->mode = BAD;

  015ab	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H

; 1200 :                     break;

  015b3	e9 cd f1 ff ff	 jmp	 $LN5@inflate
$LN317@inflate:

; 1201 :                 }
; 1202 :                 INITBITS();

  015b8	45 8b f7	 mov	 r14d, r15d

; 1203 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1204 :             }
; 1205 : #ifdef GUNZIP
; 1206 :             state->mode = LENGTH;

  015bb	41 c7 45 08 4f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16207 ; 00003f4fH
  015c3	41 8b df	 mov	 ebx, r15d
  015c6	eb 18		 jmp	 SHORT $LN492@inflate
$LN1002@inflate:

; 1183 :         case CHECK:
; 1184 :             if (state->wrap) {

  015c8	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]

; 1203 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1204 :             }
; 1205 : #ifdef GUNZIP
; 1206 :             state->mode = LENGTH;

  015cf	41 c7 45 08 4f
	3f 00 00	 mov	 DWORD PTR [r13+8], 16207 ; 00003f4fH
  015d7	eb 07		 jmp	 SHORT $LN492@inflate
$LN1001@inflate:

; 620  :     for (;;)
; 621  :         switch (state->mode) {

  015d9	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]
$LN492@inflate:

; 1207 :                 /* fallthrough */
; 1208 :         case LENGTH:
; 1209 :             if (state->wrap && state->flags) {

  015e0	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  015e5	74 7d		 je	 SHORT $LN327@inflate
  015e7	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  015ec	74 76		 je	 SHORT $LN327@inflate

; 1210 :                 NEEDBITS(32);

  015ee	83 fb 20	 cmp	 ebx, 32			; 00000020H
  015f1	73 20		 jae	 SHORT $LN318@inflate
$LL321@inflate:
  015f3	85 f6		 test	 esi, esi
  015f5	0f 84 fb f2 ff
	ff		 je	 $LN1003@inflate
  015fb	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  015ff	8b cb		 mov	 ecx, ebx
  01601	d3 e0		 shl	 eax, cl
  01603	ff ce		 dec	 esi
  01605	44 03 f0	 add	 r14d, eax
  01608	48 ff c5	 inc	 rbp
  0160b	83 c3 08	 add	 ebx, 8
  0160e	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01611	72 e0		 jb	 SHORT $LL321@inflate
$LN318@inflate:

; 1211 :                 if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {

  01613	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  01618	74 44		 je	 SHORT $LN328@inflate
  0161a	45 3b 75 24	 cmp	 r14d, DWORD PTR [r13+36]
  0161e	74 3e		 je	 SHORT $LN328@inflate

; 1212 :                     strm->msg = (z_const char *)"incorrect length check";

  01620	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check@
  01627	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1213 :                     state->mode = BAD;

  0162c	41 c7 45 08 51
	3f 00 00	 mov	 DWORD PTR [r13+8], 16209 ; 00003f51H
  01634	e9 4c f1 ff ff	 jmp	 $LN5@inflate
$LN587@inflate:

; 818  :                 RESTORE();

  01639	4d 89 4c 24 10	 mov	 QWORD PTR [r12+16], r9

; 819  :                 return Z_NEED_DICT;

  0163e	b8 02 00 00 00	 mov	 eax, 2
  01643	45 89 54 24 18	 mov	 DWORD PTR [r12+24], r10d
  01648	49 89 2c 24	 mov	 QWORD PTR [r12], rbp
  0164c	41 89 74 24 08	 mov	 DWORD PTR [r12+8], esi
  01651	45 89 75 48	 mov	 DWORD PTR [r13+72], r14d
  01655	41 89 5d 4c	 mov	 DWORD PTR [r13+76], ebx
  01659	e9 1f 01 00 00	 jmp	 $LN1@inflate
$LN328@inflate:

; 1214 :                     break;
; 1215 :                 }
; 1216 :                 INITBITS();

  0165e	45 8b f7	 mov	 r14d, r15d
  01661	41 8b df	 mov	 ebx, r15d
$LN327@inflate:

; 1217 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1218 :             }
; 1219 : #endif
; 1220 :             state->mode = DONE;

  01664	41 c7 45 08 50
	3f 00 00	 mov	 DWORD PTR [r13+8], 16208 ; 00003f50H

; 1221 :                 /* fallthrough */
; 1222 :         case DONE:
; 1223 :             ret = Z_STREAM_END;

  0166c	41 bf 01 00 00
	00		 mov	 r15d, 1

; 1224 :             goto inf_leave;

  01672	e9 87 f2 ff ff	 jmp	 $LN1198@inflate
$LN1000@inflate:

; 620  :     for (;;)
; 621  :         switch (state->mode) {

  01677	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]

; 1221 :                 /* fallthrough */
; 1222 :         case DONE:
; 1223 :             ret = Z_STREAM_END;

  0167e	41 bf 01 00 00
	00		 mov	 r15d, 1

; 1224 :             goto inf_leave;

  01684	e9 75 f2 ff ff	 jmp	 $LN1198@inflate
$LN497@inflate:
  01689	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]

; 1225 :         case BAD:
; 1226 :             ret = Z_DATA_ERROR;

  01690	41 bf fd ff ff
	ff		 mov	 r15d, -3
  01696	e9 63 f2 ff ff	 jmp	 $LN1198@inflate
$LN977@inflate:

; 1016 :                 state->mode = BAD;
; 1017 :                 break;
; 1018 :             }
; 1019 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1020 :             state->mode = LEN_;
; 1021 :             if (flush == Z_TREES) goto inf_leave;

  0169b	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR out$1$[rsp]
  016a2	e9 5e f2 ff ff	 jmp	 $inf_leave$1202
$LN504@inflate:

; 1248 :             return Z_MEM_ERROR;
; 1249 :         }
; 1250 :     in -= strm->avail_in;
; 1251 :     out -= strm->avail_out;

  016a7	41 2b 7c 24 18	 sub	 edi, DWORD PTR [r12+24]
  016ac	44 8b 54 24 3c	 mov	 r10d, DWORD PTR in$1$[rsp]
  016b1	45 2b 54 24 08	 sub	 r10d, DWORD PTR [r12+8]

; 1252 :     strm->total_in += in;

  016b6	45 01 54 24 0c	 add	 DWORD PTR [r12+12], r10d

; 1253 :     strm->total_out += out;

  016bb	41 01 7c 24 1c	 add	 DWORD PTR [r12+28], edi

; 1254 :     state->total += out;

  016c0	41 01 7d 24	 add	 DWORD PTR [r13+36], edi

; 1255 :     if ((state->wrap & 4) && out)

  016c4	41 f6 45 10 04	 test	 BYTE PTR [r13+16], 4
  016c9	44 89 54 24 3c	 mov	 DWORD PTR in$1$[rsp], r10d
  016ce	74 36		 je	 SHORT $LN505@inflate
  016d0	85 ff		 test	 edi, edi
  016d2	74 32		 je	 SHORT $LN505@inflate

; 1256 :         strm->adler = state->check =

  016d4	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]
  016d9	44 8b c7	 mov	 r8d, edi
  016dc	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  016e0	8b c7		 mov	 eax, edi
  016e2	48 2b d0	 sub	 rdx, rax
  016e5	41 83 7d 18 00	 cmp	 DWORD PTR [r13+24], 0
  016ea	74 07		 je	 SHORT $LN516@inflate
  016ec	e8 00 00 00 00	 call	 crc32
  016f1	eb 05		 jmp	 SHORT $LN517@inflate
$LN516@inflate:
  016f3	e8 00 00 00 00	 call	 adler32
$LN517@inflate:
  016f8	44 8b 54 24 3c	 mov	 r10d, DWORD PTR in$1$[rsp]
  016fd	41 89 45 20	 mov	 DWORD PTR [r13+32], eax
  01701	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN505@inflate:

; 1257 :             UPDATE_CHECK(state->check, strm->next_out - out, out);
; 1258 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  01706	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
  0170a	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  01710	74 10		 je	 SHORT $LN518@inflate
  01712	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  01718	74 08		 je	 SHORT $LN518@inflate
  0171a	45 33 c9	 xor	 r9d, r9d
  0171d	45 8b c1	 mov	 r8d, r9d
  01720	eb 09		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  01722	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  01728	45 33 c9	 xor	 r9d, r9d
$LN519@inflate:
  0172b	41 8b 45 0c	 mov	 eax, DWORD PTR [r13+12]
  0172f	f7 d8		 neg	 eax
  01731	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  01736	1b c9		 sbb	 ecx, ecx
  01738	83 e1 40	 and	 ecx, 64			; 00000040H
  0173b	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  01741	44 0f 44 c8	 cmove	 r9d, eax
  01745	41 03 c9	 add	 ecx, r9d
  01748	41 03 4d 4c	 add	 ecx, DWORD PTR [r13+76]
  0174c	41 03 c8	 add	 ecx, r8d
  0174f	41 89 4c 24 48	 mov	 DWORD PTR [r12+72], ecx

; 1259 :                       (state->mode == TYPE ? 128 : 0) +
; 1260 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1261 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01754	45 85 d2	 test	 r10d, r10d
  01757	75 04		 jne	 SHORT $LN508@inflate
  01759	85 ff		 test	 edi, edi
  0175b	74 0a		 je	 SHORT $LN507@inflate
$LN508@inflate:
  0175d	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  01765	75 0c		 jne	 SHORT $LN506@inflate
$LN507@inflate:
  01767	45 85 ff	 test	 r15d, r15d
  0176a	b8 fb ff ff ff	 mov	 eax, -5
  0176f	44 0f 44 f8	 cmove	 r15d, eax
$LN506@inflate:

; 1262 :         ret = Z_BUF_ERROR;
; 1263 :     return ret;

  01773	41 8b c7	 mov	 eax, r15d
  01776	eb 05		 jmp	 SHORT $LN1@inflate
$LN333@inflate:

; 611  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 612  :         return Z_STREAM_ERROR;

  01778	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflate:

; 1264 : }

  0177d	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  01785	48 83 c4 50	 add	 rsp, 80			; 00000050H
  01789	41 5f		 pop	 r15
  0178b	41 5e		 pop	 r14
  0178d	41 5d		 pop	 r13
  0178f	41 5c		 pop	 r12
  01791	5f		 pop	 rdi
  01792	5e		 pop	 rsi
  01793	5d		 pop	 rbp
  01794	c3		 ret	 0
  01795	0f 1f 00	 npad	 3
$LN881@inflate:
  01798	00 00 00 00	 DD	 $LN335@inflate
  0179c	00 00 00 00	 DD	 $LN32@inflate
  017a0	00 00 00 00	 DD	 $LN46@inflate
  017a4	00 00 00 00	 DD	 $LN60@inflate
  017a8	00 00 00 00	 DD	 $LN361@inflate
  017ac	00 00 00 00	 DD	 $LN368@inflate
  017b0	00 00 00 00	 DD	 $LN375@inflate
  017b4	00 00 00 00	 DD	 $LN384@inflate
  017b8	00 00 00 00	 DD	 $LN393@inflate
  017bc	00 00 00 00	 DD	 $LN105@inflate
  017c0	00 00 00 00	 DD	 $LN400@inflate
  017c4	00 00 00 00	 DD	 $LN402@inflate
  017c8	00 00 00 00	 DD	 $LN403@inflate
  017cc	00 00 00 00	 DD	 $LN141@inflate
  017d0	00 00 00 00	 DD	 $LN416@inflate
  017d4	00 00 00 00	 DD	 $LN418@inflate
  017d8	00 00 00 00	 DD	 $LN155@inflate
  017dc	00 00 00 00	 DD	 $LN533@inflate
  017e0	00 00 00 00	 DD	 $LN536@inflate
  017e4	00 00 00 00	 DD	 $LN448@inflate
  017e8	00 00 00 00	 DD	 $LN450@inflate
  017ec	00 00 00 00	 DD	 $LN461@inflate
  017f0	00 00 00 00	 DD	 $LN464@inflate
  017f4	00 00 00 00	 DD	 $LN471@inflate
  017f8	00 00 00 00	 DD	 $LN474@inflate
  017fc	00 00 00 00	 DD	 $LN485@inflate
  01800	00 00 00 00	 DD	 $LN487@inflate
  01804	00 00 00 00	 DD	 $LN1001@inflate
  01808	00 00 00 00	 DD	 $LN1000@inflate
  0180c	00 00 00 00	 DD	 $LN497@inflate
  01810	00 00 00 00	 DD	 $LN498@inflate
  01814	00 00 00 00	 DD	 $LN333@inflate
inflate	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateEnd
_TEXT	SEGMENT
strm$ = 48
inflateEnd PROC						; COMDAT

; 1266 : int ZEXPORT inflateEnd(z_streamp strm) {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1267 :     struct inflate_state FAR *state;
; 1268 :     if (inflateStateCheck(strm))

  00009	e8 00 00 00 00	 call	 inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN2@inflateEnd

; 1269 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1276 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN2@inflateEnd:

; 1270 :     state = (struct inflate_state FAR *)strm->state;
; 1271 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0001d	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00021	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00026	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0002b	48 8b 50 40	 mov	 rdx, QWORD PTR [rax+64]
  0002f	48 85 d2	 test	 rdx, rdx
  00032	74 0a		 je	 SHORT $LN5@inflateEnd
  00034	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00038	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0003c	ff d0		 call	 rax
$LN5@inflateEnd:

; 1272 :     ZFREE(strm, strm->state);

  0003e	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00042	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  00046	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0004a	ff d0		 call	 rax

; 1273 :     strm->state = Z_NULL;
; 1274 :     Tracev((stderr, "inflate: end\n"));
; 1275 :     return Z_OK;

  0004c	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00051	33 c0		 xor	 eax, eax
  00053	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00058	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 1276 : }

  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5b		 pop	 rbx
  00065	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateStateCheck
_TEXT	SEGMENT
strm$ = 8
inflateStateCheck PROC					; COMDAT

; 95   :     struct inflate_state FAR *state;
; 96   :     if (strm == Z_NULL ||
; 97   :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2c		 je	 SHORT $LN3@inflateSta
  00005	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  0000a	74 25		 je	 SHORT $LN3@inflateSta
  0000c	48 83 79 38 00	 cmp	 QWORD PTR [rcx+56], 0
  00011	74 1e		 je	 SHORT $LN3@inflateSta

; 99   :     state = (struct inflate_state FAR *)strm->state;

  00013	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 100  :     if (state == Z_NULL || state->strm != strm ||
; 101  :         state->mode < HEAD || state->mode > SYNC)

  00017	48 85 c0	 test	 rax, rax
  0001a	74 15		 je	 SHORT $LN3@inflateSta
  0001c	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001f	75 10		 jne	 SHORT $LN3@inflateSta
  00021	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00024	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00029	83 f8 1f	 cmp	 eax, 31
  0002c	77 03		 ja	 SHORT $LN3@inflateSta

; 102  :         return 1;
; 103  :     return 0;

  0002e	33 c0		 xor	 eax, eax

; 104  : }

  00030	c3		 ret	 0
$LN3@inflateSta:

; 98   :         return 1;

  00031	b8 01 00 00 00	 mov	 eax, 1

; 104  : }

  00036	c3		 ret	 0
inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateResetKeep
_TEXT	SEGMENT
strm$ = 48
inflateResetKeep PROC					; COMDAT

; 106  : int ZEXPORT inflateResetKeep(z_streamp strm) {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b d1	 mov	 rdx, rcx

; 107  :     struct inflate_state FAR *state;
; 108  : 
; 109  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00007	e8 00 00 00 00	 call	 inflateStateCheck
  0000c	85 c0		 test	 eax, eax
  0000e	74 0a		 je	 SHORT $LN2@inflateRes
  00010	b8 fe ff ff ff	 mov	 eax, -2

; 128  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
$LN2@inflateRes:

; 110  :     state = (struct inflate_state FAR *)strm->state;

  0001a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]

; 111  :     strm->total_in = strm->total_out = state->total = 0;

  0001e	45 33 c0	 xor	 r8d, r8d
  00021	44 89 41 24	 mov	 DWORD PTR [rcx+36], r8d
  00025	44 89 42 1c	 mov	 DWORD PTR [rdx+28], r8d
  00029	44 89 42 0c	 mov	 DWORD PTR [rdx+12], r8d

; 112  :     strm->msg = Z_NULL;

  0002d	4c 89 42 20	 mov	 QWORD PTR [rdx+32], r8

; 113  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00031	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00034	85 c0		 test	 eax, eax
  00036	74 06		 je	 SHORT $LN3@inflateRes

; 114  :         strm->adler = state->wrap & 1;

  00038	83 e0 01	 and	 eax, 1
  0003b	89 42 4c	 mov	 DWORD PTR [rdx+76], eax
$LN3@inflateRes:

; 115  :     state->mode = HEAD;
; 116  :     state->last = 0;
; 117  :     state->havedict = 0;
; 118  :     state->flags = -1;
; 119  :     state->dmax = 32768U;
; 120  :     state->head = Z_NULL;
; 121  :     state->hold = 0;
; 122  :     state->bits = 0;
; 123  :     state->lencode = state->distcode = state->next = state->codes;

  0003e	48 8d 81 50 05
	00 00		 lea	 rax, QWORD PTR [rcx+1360]
  00045	48 c7 41 08 34
	3f 00 00	 mov	 QWORD PTR [rcx+8], 16180 ; 00003f34H
  0004d	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00054	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00058	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 124  :     state->sane = 1;
; 125  :     state->back = -1;
; 126  :     Tracev((stderr, "inflate: reset\n"));
; 127  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	44 89 41 14	 mov	 DWORD PTR [rcx+20], r8d
  00062	c7 41 18 ff ff
	ff ff		 mov	 DWORD PTR [rcx+24], -1
  00069	c7 41 1c 00 80
	00 00		 mov	 DWORD PTR [rcx+28], 32768 ; 00008000H
  00070	4c 89 41 28	 mov	 QWORD PTR [rcx+40], r8
  00074	4c 89 41 48	 mov	 QWORD PTR [rcx+72], r8
  00078	c7 81 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rcx+7136], 1
  00082	c7 81 e4 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rcx+7140], -1

; 128  : }

  0008c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00090	c3		 ret	 0
inflateResetKeep ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateReset2
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
inflateReset2 PROC					; COMDAT

; 141  : int ZEXPORT inflateReset2(z_streamp strm, int windowBits) {

$LN22:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	8b da		 mov	 ebx, edx
  00016	48 8b e9	 mov	 rbp, rcx

; 142  :     int wrap;
; 143  :     struct inflate_state FAR *state;
; 144  : 
; 145  :     /* get the state */
; 146  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00019	e8 00 00 00 00	 call	 inflateStateCheck
  0001e	85 c0		 test	 eax, eax
  00020	75 5f		 jne	 SHORT $LN8@inflateRes

; 147  :     state = (struct inflate_state FAR *)strm->state;

  00022	48 8b 71 28	 mov	 rsi, QWORD PTR [rcx+40]

; 148  : 
; 149  :     /* extract wrap request from windowBits parameter */
; 150  :     if (windowBits < 0) {

  00026	85 d2		 test	 edx, edx
  00028	79 0b		 jns	 SHORT $LN3@inflateRes

; 151  :         if (windowBits < -15)

  0002a	83 fa f1	 cmp	 edx, -15
  0002d	7c 52		 jl	 SHORT $LN8@inflateRes

; 152  :             return Z_STREAM_ERROR;
; 153  :         wrap = 0;

  0002f	33 ff		 xor	 edi, edi

; 154  :         windowBits = -windowBits;

  00031	f7 db		 neg	 ebx

; 155  :     }

  00033	eb 10		 jmp	 SHORT $LN6@inflateRes
$LN3@inflateRes:

; 156  :     else {
; 157  :         wrap = (windowBits >> 4) + 5;

  00035	8b fb		 mov	 edi, ebx
  00037	c1 ef 04	 shr	 edi, 4
  0003a	83 c7 05	 add	 edi, 5

; 158  : #ifdef GUNZIP
; 159  :         if (windowBits < 48)

  0003d	83 fb 30	 cmp	 ebx, 48			; 00000030H
  00040	7d 03		 jge	 SHORT $LN6@inflateRes

; 160  :             windowBits &= 15;

  00042	83 e3 0f	 and	 ebx, 15
$LN6@inflateRes:

; 161  : #endif
; 162  :     }
; 163  : 
; 164  :     /* set number of window bits, free window if different */
; 165  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00045	85 db		 test	 ebx, ebx
  00047	74 08		 je	 SHORT $LN7@inflateRes
  00049	8d 43 f8	 lea	 eax, DWORD PTR [rbx-8]
  0004c	83 f8 07	 cmp	 eax, 7
  0004f	77 30		 ja	 SHORT $LN8@inflateRes
$LN7@inflateRes:

; 167  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00051	48 8b 56 40	 mov	 rdx, QWORD PTR [rsi+64]
  00055	48 85 d2	 test	 rdx, rdx
  00058	74 17		 je	 SHORT $LN9@inflateRes
  0005a	39 5e 30	 cmp	 DWORD PTR [rsi+48], ebx
  0005d	74 12		 je	 SHORT $LN9@inflateRes

; 168  :         ZFREE(strm, state->window);

  0005f	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00063	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00067	ff d0		 call	 rax

; 169  :         state->window = Z_NULL;

  00069	48 c7 46 40 00
	00 00 00	 mov	 QWORD PTR [rsi+64], 0
$LN9@inflateRes:

; 170  :     }
; 171  : 
; 172  :     /* update state and reset the rest of it */
; 173  :     state->wrap = wrap;
; 174  :     state->wbits = (unsigned)windowBits;
; 175  :     return inflateReset(strm);

  00071	48 8b cd	 mov	 rcx, rbp
  00074	89 7e 10	 mov	 DWORD PTR [rsi+16], edi
  00077	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx
  0007a	e8 00 00 00 00	 call	 inflateReset
  0007f	eb 05		 jmp	 SHORT $LN1@inflateRes
$LN8@inflateRes:

; 166  :         return Z_STREAM_ERROR;

  00081	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflateRes:

; 176  : }

  00086	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008b	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00090	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
inflateReset2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 8
version$ = 16
stream_size$ = 24
inflateInit_ PROC					; COMDAT

; 220  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00000	45 8b c8	 mov	 r9d, r8d
  00003	4c 8b c2	 mov	 r8, rdx
  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	e9 00 00 00 00	 jmp	 inflateInit2_
inflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflatePrime
_TEXT	SEGMENT
strm$ = 48
bits$ = 56
value$ = 64
inflatePrime PROC					; COMDAT

; 223  : int ZEXPORT inflatePrime(z_streamp strm, int bits, int value) {

$LN11:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	45 8b d8	 mov	 r11d, r8d
  00007	44 8b ca	 mov	 r9d, edx

; 224  :     struct inflate_state FAR *state;
; 225  : 
; 226  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  0000a	e8 00 00 00 00	 call	 inflateStateCheck
  0000f	85 c0		 test	 eax, eax
  00011	75 49		 jne	 SHORT $LN6@inflatePri

; 227  :     if (bits == 0)

  00013	85 d2		 test	 edx, edx
  00015	74 3e		 je	 SHORT $LN9@inflatePri

; 228  :         return Z_OK;
; 229  :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]

; 230  :     if (bits < 0) {

  0001b	79 09		 jns	 SHORT $LN4@inflatePri

; 231  :         state->hold = 0;

  0001d	48 89 42 48	 mov	 QWORD PTR [rdx+72], rax

; 239  :     return Z_OK;
; 240  : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
$LN4@inflatePri:

; 232  :         state->bits = 0;
; 233  :         return Z_OK;
; 234  :     }
; 235  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00026	41 83 f9 10	 cmp	 r9d, 16
  0002a	7f 30		 jg	 SHORT $LN6@inflatePri
  0002c	44 8b 42 4c	 mov	 r8d, DWORD PTR [rdx+76]
  00030	47 8d 14 08	 lea	 r10d, DWORD PTR [r8+r9]
  00034	41 83 fa 20	 cmp	 r10d, 32		; 00000020H
  00038	77 22		 ja	 SHORT $LN6@inflatePri

; 236  :     value &= (1L << bits) - 1;

  0003a	41 8b c9	 mov	 ecx, r9d

; 237  :     state->hold += (unsigned)value << state->bits;
; 238  :     state->bits += (uInt)bits;

  0003d	44 89 52 4c	 mov	 DWORD PTR [rdx+76], r10d
  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	d3 e0		 shl	 eax, cl
  00048	41 8b c8	 mov	 ecx, r8d
  0004b	ff c8		 dec	 eax
  0004d	41 23 c3	 and	 eax, r11d
  00050	d3 e0		 shl	 eax, cl
  00052	01 42 48	 add	 DWORD PTR [rdx+72], eax
$LN9@inflatePri:

; 239  :     return Z_OK;
; 240  : }

  00055	33 c0		 xor	 eax, eax
  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
$LN6@inflatePri:

; 232  :         state->bits = 0;
; 233  :         return Z_OK;
; 234  :     }
; 235  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  0005c	b8 fe ff ff ff	 mov	 eax, -2

; 239  :     return Z_OK;
; 240  : }

  00061	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00065	c3		 ret	 0
inflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 253  : #ifdef BUILDFIXED
; 254  :     static int virgin = 1;
; 255  :     static code *lenfix, *distfix;
; 256  :     static code fixed[544];
; 257  : 
; 258  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 259  :     if (virgin) {
; 260  :         unsigned sym, bits;
; 261  :         static code *next;
; 262  : 
; 263  :         /* literal/length table */
; 264  :         sym = 0;
; 265  :         while (sym < 144) state->lens[sym++] = 8;
; 266  :         while (sym < 256) state->lens[sym++] = 9;
; 267  :         while (sym < 280) state->lens[sym++] = 7;
; 268  :         while (sym < 288) state->lens[sym++] = 8;
; 269  :         next = fixed;
; 270  :         lenfix = next;
; 271  :         bits = 9;
; 272  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 273  : 
; 274  :         /* distance table */
; 275  :         sym = 0;
; 276  :         while (sym < 32) state->lens[sym++] = 5;
; 277  :         distfix = next;
; 278  :         bits = 5;
; 279  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 280  : 
; 281  :         /* do this just once */
; 282  :         virgin = 0;
; 283  :     }
; 284  : #else /* !BUILDFIXED */
; 285  : #   include "inffixed.h"
; 286  : #endif /* BUILDFIXED */
; 287  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 288  :     state->lenbits = 9;

  00007	c7 41 70 09 00
	00 00		 mov	 DWORD PTR [rcx+112], 9
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 289  :     state->distcode = distfix;

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00019	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 290  :     state->distbits = 5;

  0001d	c7 41 74 05 00
	00 00		 mov	 DWORD PTR [rcx+116], 5

; 291  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT updatewindow
_TEXT	SEGMENT
strm$ = 64
tv296 = 64
end$ = 72
copy$ = 80
updatewindow PROC					; COMDAT

; 368  : local int updatewindow(z_streamp strm, const Bytef *end, unsigned copy) {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 56		 push	 r14
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 369  :     struct inflate_state FAR *state;
; 370  :     unsigned dist;
; 371  : 
; 372  :     state = (struct inflate_state FAR *)strm->state;

  0000d	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00011	48 8b f2	 mov	 rsi, rdx
  00014	41 8b e8	 mov	 ebp, r8d
  00017	4c 8b d1	 mov	 r10, rcx

; 373  : 
; 374  :     /* if it hasn't been done already, allocate space for the window */
; 375  :     if (state->window == Z_NULL) {

  0001a	4c 8b 4b 40	 mov	 r9, QWORD PTR [rbx+64]
  0001e	4d 85 c9	 test	 r9, r9
  00021	75 3a		 jne	 SHORT $LN15@updatewind

; 376  :         state->window = (unsigned char FAR *)

  00023	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  00026	ba 01 00 00 00	 mov	 edx, 1
  0002b	4d 8b 4a 30	 mov	 r9, QWORD PTR [r10+48]
  0002f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00035	d3 e2		 shl	 edx, cl
  00037	49 8b 4a 40	 mov	 rcx, QWORD PTR [r10+64]
  0003b	41 ff d1	 call	 r9
  0003e	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax
  00042	4c 8b c8	 mov	 r9, rax

; 377  :                         ZALLOC(strm, 1U << state->wbits,
; 378  :                                sizeof(unsigned char));
; 379  :         if (state->window == Z_NULL) return 1;

  00045	48 85 c0	 test	 rax, rax
  00048	75 13		 jne	 SHORT $LN15@updatewind
  0004a	b8 01 00 00 00	 mov	 eax, 1

; 412  : }

  0004f	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	41 5e		 pop	 r14
  0005a	5e		 pop	 rsi
  0005b	5d		 pop	 rbp
  0005c	c3		 ret	 0
$LN15@updatewind:
  0005d	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 380  :     }
; 381  : 
; 382  :     /* if window not in use yet, initialize */
; 383  :     if (state->wsize == 0) {

  00062	8b 7b 34	 mov	 edi, DWORD PTR [rbx+52]
  00065	4c 89 7c 24 50	 mov	 QWORD PTR [rsp+80], r15
  0006a	45 33 ff	 xor	 r15d, r15d
  0006d	85 ff		 test	 edi, edi
  0006f	75 11		 jne	 SHORT $LN16@updatewind

; 384  :         state->wsize = 1U << state->wbits;

  00071	8b 4b 30	 mov	 ecx, DWORD PTR [rbx+48]
  00074	bf 01 00 00 00	 mov	 edi, 1
  00079	d3 e7		 shl	 edi, cl
  0007b	89 7b 34	 mov	 DWORD PTR [rbx+52], edi

; 385  :         state->wnext = 0;
; 386  :         state->whave = 0;

  0007e	4c 89 7b 38	 mov	 QWORD PTR [rbx+56], r15
$LN16@updatewind:

; 387  :     }
; 388  : 
; 389  :     /* copy state->wsize or less output bytes into the circular window */
; 390  :     if (copy >= state->wsize) {

  00082	3b ef		 cmp	 ebp, edi
  00084	72 1a		 jb	 SHORT $LN5@updatewind

; 391  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00086	44 8b c7	 mov	 r8d, edi
  00089	49 8b c9	 mov	 rcx, r9
  0008c	49 2b f0	 sub	 rsi, r8
  0008f	48 8b d6	 mov	 rdx, rsi
  00092	e8 00 00 00 00	 call	 memcpy

; 392  :         state->wnext = 0;
; 393  :         state->whave = state->wsize;

  00097	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  0009a	44 89 7b 3c	 mov	 DWORD PTR [rbx+60], r15d

; 394  :     }

  0009e	eb 55		 jmp	 SHORT $LN24@updatewind
$LN5@updatewind:

; 395  :     else {
; 396  :         dist = state->wsize - state->wnext;

  000a0	8b 4b 3c	 mov	 ecx, DWORD PTR [rbx+60]

; 397  :         if (dist > copy) dist = copy;
; 398  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  000a3	48 8b d6	 mov	 rdx, rsi
  000a6	2b f9		 sub	 edi, ecx
  000a8	3b fd		 cmp	 edi, ebp
  000aa	0f 47 fd	 cmova	 edi, ebp
  000ad	48 2b d5	 sub	 rdx, rbp
  000b0	44 8b c7	 mov	 r8d, edi
  000b3	49 03 c9	 add	 rcx, r9
  000b6	e8 00 00 00 00	 call	 memcpy

; 399  :         copy -= dist;

  000bb	2b ef		 sub	 ebp, edi

; 400  :         if (copy) {

  000bd	74 1a		 je	 SHORT $LN8@updatewind

; 401  :             zmemcpy(state->window, end - copy, copy);

  000bf	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000c3	44 8b c5	 mov	 r8d, ebp
  000c6	49 2b f0	 sub	 rsi, r8
  000c9	48 8b d6	 mov	 rdx, rsi
  000cc	e8 00 00 00 00	 call	 memcpy

; 402  :             state->wnext = copy;
; 403  :             state->whave = state->wsize;

  000d1	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  000d4	89 6b 3c	 mov	 DWORD PTR [rbx+60], ebp

; 404  :         }

  000d7	eb 1c		 jmp	 SHORT $LN24@updatewind
$LN8@updatewind:

; 405  :         else {
; 406  :             state->wnext += dist;

  000d9	8b 4b 3c	 mov	 ecx, DWORD PTR [rbx+60]

; 407  :             if (state->wnext == state->wsize) state->wnext = 0;

  000dc	8b 53 34	 mov	 edx, DWORD PTR [rbx+52]
  000df	03 cf		 add	 ecx, edi
  000e1	89 4b 3c	 mov	 DWORD PTR [rbx+60], ecx
  000e4	3b ca		 cmp	 ecx, edx
  000e6	75 04		 jne	 SHORT $LN10@updatewind
  000e8	44 89 7b 3c	 mov	 DWORD PTR [rbx+60], r15d
$LN10@updatewind:

; 408  :             if (state->whave < state->wsize) state->whave += dist;

  000ec	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  000ef	3b c2		 cmp	 eax, edx
  000f1	73 05		 jae	 SHORT $LN11@updatewind
  000f3	03 c7		 add	 eax, edi
$LN24@updatewind:

; 409  :         }
; 410  :     }
; 411  :     return 0;

  000f5	89 43 38	 mov	 DWORD PTR [rbx+56], eax
$LN11@updatewind:
  000f8	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]
  000fd	33 c0		 xor	 eax, eax
  000ff	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 412  : }

  00104	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00109	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010d	41 5e		 pop	 r14
  0010f	5e		 pop	 rsi
  00110	5d		 pop	 rbp
  00111	c3		 ret	 0
updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateGetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateGetDictionary PROC				; COMDAT

; 1279 :                                  uInt *dictLength) {

$LN11:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b f2	 mov	 rsi, rdx

; 1280 :     struct inflate_state FAR *state;
; 1281 : 
; 1282 :     /* check state */
; 1283 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00010	e8 00 00 00 00	 call	 inflateStateCheck
  00015	85 c0		 test	 eax, eax
  00017	74 10		 je	 SHORT $LN2@inflateGet
  00019	b8 fe ff ff ff	 mov	 eax, -2

; 1296 : }

  0001e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5f		 pop	 rdi
  00028	c3		 ret	 0
$LN2@inflateGet:
  00029	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1284 :     state = (struct inflate_state FAR *)strm->state;

  0002e	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]

; 1285 : 
; 1286 :     /* copy dictionary */
; 1287 :     if (state->whave && dictionary != Z_NULL) {

  00032	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00035	85 c0		 test	 eax, eax
  00037	74 2f		 je	 SHORT $LN3@inflateGet
  00039	48 85 f6	 test	 rsi, rsi
  0003c	74 2a		 je	 SHORT $LN3@inflateGet

; 1288 :         zmemcpy(dictionary, state->window + state->wnext,

  0003e	8b 53 3c	 mov	 edx, DWORD PTR [rbx+60]
  00041	48 8b ce	 mov	 rcx, rsi
  00044	2b c2		 sub	 eax, edx
  00046	48 03 53 40	 add	 rdx, QWORD PTR [rbx+64]
  0004a	44 8b c0	 mov	 r8d, eax
  0004d	e8 00 00 00 00	 call	 memcpy

; 1289 :                 state->whave - state->wnext);
; 1290 :         zmemcpy(dictionary + state->whave - state->wnext,

  00052	44 8b 43 3c	 mov	 r8d, DWORD PTR [rbx+60]
  00056	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]
  00059	48 8b 53 40	 mov	 rdx, QWORD PTR [rbx+64]
  0005d	49 2b c8	 sub	 rcx, r8
  00060	48 03 ce	 add	 rcx, rsi
  00063	e8 00 00 00 00	 call	 memcpy
$LN3@inflateGet:

; 1291 :                 state->window, state->wnext);
; 1292 :     }
; 1293 :     if (dictLength != Z_NULL)

  00068	48 85 ff	 test	 rdi, rdi
  0006b	74 05		 je	 SHORT $LN4@inflateGet

; 1294 :         *dictLength = state->whave;

  0006d	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00070	89 07		 mov	 DWORD PTR [rdi], eax
$LN4@inflateGet:

; 1295 :     return Z_OK;

  00072	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00077	33 c0		 xor	 eax, eax

; 1296 : }

  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
inflateGetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateSetDictionary PROC				; COMDAT

; 1299 :                                  uInt dictLength) {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	41 8b e8	 mov	 ebp, r8d
  0001d	4c 8b f2	 mov	 r14, rdx
  00020	48 8b f1	 mov	 rsi, rcx

; 1300 :     struct inflate_state FAR *state;
; 1301 :     unsigned long dictid;
; 1302 :     int ret;
; 1303 : 
; 1304 :     /* check state */
; 1305 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00023	e8 00 00 00 00	 call	 inflateStateCheck
  00028	85 c0		 test	 eax, eax
  0002a	75 6c		 jne	 SHORT $LN11@inflateSet

; 1306 :     state = (struct inflate_state FAR *)strm->state;

  0002c	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]

; 1307 :     if (state->wrap != 0 && state->mode != DICT)

  00030	39 47 10	 cmp	 DWORD PTR [rdi+16], eax
  00033	74 09		 je	 SHORT $LN10@inflateSet
  00035	81 7f 08 3e 3f
	00 00		 cmp	 DWORD PTR [rdi+8], 16190 ; 00003f3eH
  0003c	75 5a		 jne	 SHORT $LN11@inflateSet
$LN10@inflateSet:

; 1309 : 
; 1310 :     /* check for correct dictionary identifier */
; 1311 :     if (state->mode == DICT) {

  0003e	81 7f 08 3e 3f
	00 00		 cmp	 DWORD PTR [rdi+8], 16190 ; 00003f3eH
  00045	75 25		 jne	 SHORT $LN5@inflateSet

; 1312 :         dictid = adler32(0L, Z_NULL, 0);

  00047	45 33 c0	 xor	 r8d, r8d
  0004a	33 d2		 xor	 edx, edx
  0004c	33 c9		 xor	 ecx, ecx
  0004e	e8 00 00 00 00	 call	 adler32

; 1313 :         dictid = adler32(dictid, dictionary, dictLength);

  00053	44 8b c5	 mov	 r8d, ebp
  00056	49 8b d6	 mov	 rdx, r14
  00059	8b c8		 mov	 ecx, eax
  0005b	e8 00 00 00 00	 call	 adler32

; 1314 :         if (dictid != state->check)

  00060	3b 47 20	 cmp	 eax, DWORD PTR [rdi+32]
  00063	74 07		 je	 SHORT $LN5@inflateSet

; 1315 :             return Z_DATA_ERROR;

  00065	b8 fd ff ff ff	 mov	 eax, -3
  0006a	eb 31		 jmp	 SHORT $LN1@inflateSet
$LN5@inflateSet:

; 1316 :     }
; 1317 : 
; 1318 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1319 :        existing dictionary if appropriate */
; 1320 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  0006c	49 8d 14 2e	 lea	 rdx, QWORD PTR [r14+rbp]
  00070	44 8b c5	 mov	 r8d, ebp
  00073	48 8b ce	 mov	 rcx, rsi
  00076	e8 00 00 00 00	 call	 updatewindow

; 1321 :     if (ret) {

  0007b	85 c0		 test	 eax, eax
  0007d	74 0e		 je	 SHORT $LN6@inflateSet

; 1322 :         state->mode = MEM;

  0007f	c7 47 08 52 3f
	00 00		 mov	 DWORD PTR [rdi+8], 16210 ; 00003f52H

; 1323 :         return Z_MEM_ERROR;

  00086	b8 fc ff ff ff	 mov	 eax, -4
  0008b	eb 10		 jmp	 SHORT $LN1@inflateSet
$LN6@inflateSet:

; 1324 :     }
; 1325 :     state->havedict = 1;

  0008d	c7 47 14 01 00
	00 00		 mov	 DWORD PTR [rdi+20], 1

; 1326 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1327 :     return Z_OK;

  00094	33 c0		 xor	 eax, eax
  00096	eb 05		 jmp	 SHORT $LN1@inflateSet
$LN11@inflateSet:

; 1308 :         return Z_STREAM_ERROR;

  00098	b8 fe ff ff ff	 mov	 eax, -2
$LN1@inflateSet:

; 1328 : }

  0009d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a2	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ac	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b5	41 5e		 pop	 r14
  000b7	c3		 ret	 0
inflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
strm$ = 48
head$ = 56
inflateGetHeader PROC					; COMDAT

; 1330 : int ZEXPORT inflateGetHeader(z_streamp strm, gz_headerp head) {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1331 :     struct inflate_state FAR *state;
; 1332 : 
; 1333 :     /* check state */
; 1334 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	75 1c		 jne	 SHORT $LN5@inflateGet

; 1335 :     state = (struct inflate_state FAR *)strm->state;

  0000d	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1336 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00011	f6 40 10 02	 test	 BYTE PTR [rax+16], 2
  00015	74 12		 je	 SHORT $LN5@inflateGet

; 1337 : 
; 1338 :     /* save header structure */
; 1339 :     state->head = head;

  00017	48 89 50 28	 mov	 QWORD PTR [rax+40], rdx

; 1340 :     head->done = 0;
; 1341 :     return Z_OK;

  0001b	33 c0		 xor	 eax, eax
  0001d	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [rdx+64], 0

; 1342 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
$LN5@inflateGet:

; 1336 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2

; 1342 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT syncsearch
_TEXT	SEGMENT
have$ = 8
buf$ = 16
len$ = 24
syncsearch PROC						; COMDAT

; 1356 :                           unsigned len) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1357 :     unsigned got;
; 1358 :     unsigned next;
; 1359 : 
; 1360 :     got = *have;

  00005	8b 01		 mov	 eax, DWORD PTR [rcx]

; 1361 :     next = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	45 8b d0	 mov	 r10d, r8d
  0000c	4c 8b d9	 mov	 r11, rcx
  0000f	44 8b cb	 mov	 r9d, ebx

; 1362 :     while (next < len && got < 4) {

  00012	45 85 c0	 test	 r8d, r8d
  00015	74 43		 je	 SHORT $LN14@syncsearch
$LL2@syncsearch:
  00017	83 f8 04	 cmp	 eax, 4
  0001a	73 32		 jae	 SHORT $LN15@syncsearch

; 1363 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  0001c	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  00020	83 f8 02	 cmp	 eax, 2
  00023	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00028	0f 42 cb	 cmovb	 ecx, ebx
  0002b	44 3b c1	 cmp	 r8d, ecx
  0002e	75 04		 jne	 SHORT $LN4@syncsearch

; 1364 :             got++;

  00030	ff c0		 inc	 eax
  00032	eb 0f		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1365 :         else if (buf[next])
; 1366 :             got = 0;
; 1367 :         else
; 1368 :             got = 4 - got;

  00034	b9 04 00 00 00	 mov	 ecx, 4
  00039	2b c8		 sub	 ecx, eax
  0003b	45 84 c0	 test	 r8b, r8b
  0003e	8b c1		 mov	 eax, ecx
  00040	0f 45 c3	 cmovne	 eax, ebx
$LN7@syncsearch:

; 1369 :         next++;

  00043	41 ff c1	 inc	 r9d
  00046	48 ff c2	 inc	 rdx
  00049	45 3b ca	 cmp	 r9d, r10d
  0004c	72 c9		 jb	 SHORT $LL2@syncsearch
$LN15@syncsearch:

; 1370 :     }
; 1371 :     *have = got;
; 1372 :     return next;
; 1373 : }

  0004e	41 89 03	 mov	 DWORD PTR [r11], eax
  00051	41 8b c1	 mov	 eax, r9d
  00054	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00059	c3		 ret	 0
$LN14@syncsearch:
  0005a	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005f	89 01		 mov	 DWORD PTR [rcx], eax
  00061	41 8b c1	 mov	 eax, r9d
  00064	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateSync
_TEXT	SEGMENT
strm$ = 64
buf$ = 72
inflateSync PROC					; COMDAT

; 1375 : int ZEXPORT inflateSync(z_streamp strm) {

$LN34:
  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f1	 mov	 rsi, rcx

; 1376 :     unsigned len;               /* number of bytes to look at or looked at */
; 1377 :     int flags;                  /* temporary to save header status */
; 1378 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1379 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1380 :     struct inflate_state FAR *state;
; 1381 : 
; 1382 :     /* check parameters */
; 1383 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00009	e8 00 00 00 00	 call	 inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN4@inflateSyn
  00012	b8 fe ff ff ff	 mov	 eax, -2

; 1421 : }

  00017	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001b	5e		 pop	 rsi
  0001c	c3		 ret	 0
$LN4@inflateSyn:

; 1384 :     state = (struct inflate_state FAR *)strm->state;
; 1385 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001d	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00021	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00026	48 8b 69 28	 mov	 rbp, QWORD PTR [rcx+40]
  0002a	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  0002f	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  00033	75 1b		 jne	 SHORT $LN20@inflateSyn
  00035	83 7d 4c 08	 cmp	 DWORD PTR [rbp+76], 8
  00039	73 15		 jae	 SHORT $LN20@inflateSyn
  0003b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00040	b8 fb ff ff ff	 mov	 eax, -5
  00045	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]

; 1421 : }

  0004a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004e	5e		 pop	 rsi
  0004f	c3		 ret	 0
$LN20@inflateSyn:

; 1386 : 
; 1387 :     /* if first time, start search in bit buffer */
; 1388 :     if (state->mode != SYNC) {

  00050	81 7d 08 53 3f
	00 00		 cmp	 DWORD PTR [rbp+8], 16211 ; 00003f53H
  00057	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0005c	74 6a		 je	 SHORT $LN21@inflateSyn

; 1389 :         state->mode = SYNC;
; 1390 :         state->hold >>= state->bits & 7;

  0005e	8b 55 4c	 mov	 edx, DWORD PTR [rbp+76]

; 1391 :         state->bits -= state->bits & 7;
; 1392 :         len = 0;

  00061	45 33 c0	 xor	 r8d, r8d
  00064	44 8b 55 48	 mov	 r10d, DWORD PTR [rbp+72]
  00068	8b ca		 mov	 ecx, edx
  0006a	83 e1 07	 and	 ecx, 7
  0006d	c7 45 08 53 3f
	00 00		 mov	 DWORD PTR [rbp+8], 16211 ; 00003f53H
  00074	41 d3 ea	 shr	 r10d, cl
  00077	2b d1		 sub	 edx, ecx
  00079	44 89 55 48	 mov	 DWORD PTR [rbp+72], r10d
  0007d	89 55 4c	 mov	 DWORD PTR [rbp+76], edx

; 1393 :         while (state->bits >= 8) {

  00080	83 fa 08	 cmp	 edx, 8
  00083	72 2c		 jb	 SHORT $LN3@inflateSyn
  00085	41 8b ca	 mov	 ecx, r10d
  00088	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@inflateSyn:

; 1394 :             buf[len++] = (unsigned char)(state->hold);

  00090	46 88 54 04 48	 mov	 BYTE PTR buf$[rsp+r8], r10b

; 1395 :             state->hold >>= 8;
; 1396 :             state->bits -= 8;

  00095	83 c2 f8	 add	 edx, -8			; fffffff8H
  00098	c1 e9 08	 shr	 ecx, 8
  0009b	41 ff c0	 inc	 r8d
  0009e	44 0f b6 d1	 movzx	 r10d, cl
  000a2	83 fa 08	 cmp	 edx, 8
  000a5	73 e9		 jae	 SHORT $LL2@inflateSyn
  000a7	89 55 4c	 mov	 DWORD PTR [rbp+76], edx
  000aa	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
  000ae	89 4d 48	 mov	 DWORD PTR [rbp+72], ecx
$LN3@inflateSyn:

; 1397 :         }
; 1398 :         state->have = 0;

  000b1	48 8d 8d 84 00
	00 00		 lea	 rcx, QWORD PTR [rbp+132]

; 1399 :         syncsearch(&(state->have), buf, len);

  000b8	48 8d 54 24 48	 lea	 rdx, QWORD PTR buf$[rsp]
  000bd	c7 01 00 00 00
	00		 mov	 DWORD PTR [rcx], 0
  000c3	e8 00 00 00 00	 call	 syncsearch
$LN21@inflateSyn:

; 1400 :     }
; 1401 : 
; 1402 :     /* search available input */
; 1403 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000c8	44 8b 07	 mov	 r8d, DWORD PTR [rdi]
  000cb	48 8d 8d 84 00
	00 00		 lea	 rcx, QWORD PTR [rbp+132]
  000d2	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000d5	e8 00 00 00 00	 call	 syncsearch

; 1404 :     strm->avail_in -= len;

  000da	29 07		 sub	 DWORD PTR [rdi], eax

; 1405 :     strm->next_in += len;
; 1406 :     strm->total_in += len;

  000dc	01 46 0c	 add	 DWORD PTR [rsi+12], eax
  000df	8b c8		 mov	 ecx, eax
  000e1	48 01 0e	 add	 QWORD PTR [rsi], rcx

; 1407 : 
; 1408 :     /* return no joy or set up to restart inflate() on a new block */
; 1409 :     if (state->have != 4) return Z_DATA_ERROR;

  000e4	83 bd 84 00 00
	00 04		 cmp	 DWORD PTR [rbp+132], 4
  000eb	74 07		 je	 SHORT $LN7@inflateSyn
  000ed	b8 fd ff ff ff	 mov	 eax, -3
  000f2	eb 42		 jmp	 SHORT $LN32@inflateSyn
$LN7@inflateSyn:
  000f4	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14

; 1410 :     if (state->flags == -1)

  000f9	44 8b 75 18	 mov	 r14d, DWORD PTR [rbp+24]
  000fd	41 83 fe ff	 cmp	 r14d, -1
  00101	75 09		 jne	 SHORT $LN8@inflateSyn

; 1411 :         state->wrap = 0;    /* if no header yet, treat as raw */

  00103	c7 45 10 00 00
	00 00		 mov	 DWORD PTR [rbp+16], 0
  0010a	eb 04		 jmp	 SHORT $LN9@inflateSyn
$LN8@inflateSyn:

; 1412 :     else
; 1413 :         state->wrap &= ~4;  /* no point in computing a check value now */

  0010c	83 65 10 fb	 and	 DWORD PTR [rbp+16], -5
$LN9@inflateSyn:

; 1414 :     flags = state->flags;
; 1415 :     in = strm->total_in;  out = strm->total_out;

  00110	8b 7e 0c	 mov	 edi, DWORD PTR [rsi+12]

; 1416 :     inflateReset(strm);

  00113	48 8b ce	 mov	 rcx, rsi
  00116	8b 5e 1c	 mov	 ebx, DWORD PTR [rsi+28]
  00119	e8 00 00 00 00	 call	 inflateReset

; 1417 :     strm->total_in = in;  strm->total_out = out;

  0011e	89 7e 0c	 mov	 DWORD PTR [rsi+12], edi

; 1418 :     state->flags = flags;
; 1419 :     state->mode = TYPE;
; 1420 :     return Z_OK;

  00121	33 c0		 xor	 eax, eax
  00123	89 5e 1c	 mov	 DWORD PTR [rsi+28], ebx
  00126	44 89 75 18	 mov	 DWORD PTR [rbp+24], r14d
  0012a	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  0012f	c7 45 08 3f 3f
	00 00		 mov	 DWORD PTR [rbp+8], 16191 ; 00003f3fH
$LN32@inflateSyn:
  00136	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0013b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00140	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]

; 1421 : }

  00145	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00149	5e		 pop	 rsi
  0014a	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
strm$ = 48
inflateSyncPoint PROC					; COMDAT

; 1431 : int ZEXPORT inflateSyncPoint(z_streamp strm) {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1432 :     struct inflate_state FAR *state;
; 1433 : 
; 1434 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateSyn
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1437 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateSyn:

; 1435 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1436 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 08 41 3f
	00 00		 cmp	 DWORD PTR [rax+8], 16193 ; 00003f41H
  00022	75 10		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00028	75 0a		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1437 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN4@inflateSyn:

; 1436 :     return state->mode == STORED && state->bits == 0;

  00034	33 c0		 xor	 eax, eax

; 1437 : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateCopy
_TEXT	SEGMENT
dest$ = 64
source$ = 72
inflateCopy PROC					; COMDAT

; 1439 : int ZEXPORT inflateCopy(z_streamp dest, z_streamp source) {

$LN28:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00007	48 8b e9	 mov	 rbp, rcx
  0000a	48 8b fa	 mov	 rdi, rdx

; 1440 :     struct inflate_state FAR *state;
; 1441 :     struct inflate_state FAR *copy;
; 1442 :     unsigned char FAR *window;
; 1443 :     unsigned wsize;
; 1444 : 
; 1445 :     /* check input */
; 1446 :     if (inflateStateCheck(source) || dest == Z_NULL)

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 inflateStateCheck
  00015	85 c0		 test	 eax, eax
  00017	0f 85 8e 01 00
	00		 jne	 $LN3@inflateCop
  0001d	48 85 ed	 test	 rbp, rbp
  00020	0f 84 85 01 00
	00		 je	 $LN3@inflateCop

; 1448 :     state = (struct inflate_state FAR *)source->state;
; 1449 : 
; 1450 :     /* allocate space */
; 1451 :     copy = (struct inflate_state FAR *)

  00026	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
  0002a	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  00030	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00034	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00039	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0003e	48 8b 72 28	 mov	 rsi, QWORD PTR [rdx+40]
  00042	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00047	41 bf 01 00 00
	00		 mov	 r15d, 1
  0004d	41 8b d7	 mov	 edx, r15d
  00050	ff d0		 call	 rax
  00052	48 8b d8	 mov	 rbx, rax

; 1452 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1453 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00055	48 85 c0	 test	 rax, rax
  00058	75 07		 jne	 SHORT $LN4@inflateCop
  0005a	b8 fc ff ff ff	 mov	 eax, -4
  0005f	eb 4c		 jmp	 SHORT $LN24@inflateCop
$LN4@inflateCop:
  00061	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00066	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14

; 1454 :     window = Z_NULL;

  0006b	45 33 f6	 xor	 r14d, r14d

; 1455 :     if (state->window != Z_NULL) {

  0006e	4c 39 76 40	 cmp	 QWORD PTR [rsi+64], r14
  00072	74 4f		 je	 SHORT $LN12@inflateCop

; 1456 :         window = (unsigned char FAR *)

  00074	8b 4e 30	 mov	 ecx, DWORD PTR [rsi+48]
  00077	41 8b d7	 mov	 edx, r15d
  0007a	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  0007e	45 8b c7	 mov	 r8d, r15d
  00081	d3 e2		 shl	 edx, cl
  00083	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  00087	ff d0		 call	 rax
  00089	4c 8b f0	 mov	 r14, rax

; 1457 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1458 :         if (window == Z_NULL) {

  0008c	48 85 c0	 test	 rax, rax
  0008f	75 32		 jne	 SHORT $LN12@inflateCop

; 1459 :             ZFREE(source, copy);

  00091	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00095	48 8b d3	 mov	 rdx, rbx
  00098	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  0009c	ff d0		 call	 rax

; 1460 :             return Z_MEM_ERROR;

  0009e	b8 fc ff ff ff	 mov	 eax, -4
$LN26@inflateCop:
  000a3	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  000a8	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
$LN24@inflateCop:
  000ad	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b7	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 1481 : }

  000bc	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c0	5f		 pop	 rdi
  000c1	5d		 pop	 rbp
  000c2	c3		 ret	 0
$LN12@inflateCop:

; 1461 :         }
; 1462 :     }
; 1463 : 
; 1464 :     /* copy state */
; 1465 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  000c3	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]

; 1466 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  000c6	41 b8 f0 1b 00
	00		 mov	 r8d, 7152		; 00001bf0H
  000cc	48 8b d6	 mov	 rdx, rsi
  000cf	48 8b cb	 mov	 rcx, rbx
  000d2	0f 11 45 00	 movups	 XMMWORD PTR [rbp], xmm0
  000d6	0f 10 4f 10	 movups	 xmm1, XMMWORD PTR [rdi+16]
  000da	0f 11 4d 10	 movups	 XMMWORD PTR [rbp+16], xmm1
  000de	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [rdi+32]
  000e2	0f 11 45 20	 movups	 XMMWORD PTR [rbp+32], xmm0
  000e6	0f 10 4f 30	 movups	 xmm1, XMMWORD PTR [rdi+48]
  000ea	0f 11 4d 30	 movups	 XMMWORD PTR [rbp+48], xmm1
  000ee	0f 10 47 40	 movups	 xmm0, XMMWORD PTR [rdi+64]
  000f2	0f 11 45 40	 movups	 XMMWORD PTR [rbp+64], xmm0
  000f6	f2 0f 10 4f 50	 movsd	 xmm1, QWORD PTR [rdi+80]
  000fb	f2 0f 11 4d 50	 movsd	 QWORD PTR [rbp+80], xmm1
  00100	e8 00 00 00 00	 call	 memcpy

; 1467 :     copy->strm = dest;

  00105	48 89 2b	 mov	 QWORD PTR [rbx], rbp

; 1468 :     if (state->lencode >= state->codes &&

  00108	48 8d 86 50 05
	00 00		 lea	 rax, QWORD PTR [rsi+1360]
  0010f	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]
  00113	48 3b d0	 cmp	 rdx, rax
  00116	72 45		 jb	 SHORT $LN7@inflateCop
  00118	48 8d 86 dc 1b
	00 00		 lea	 rax, QWORD PTR [rsi+7132]
  0011f	48 3b d0	 cmp	 rdx, rax
  00122	77 39		 ja	 SHORT $LN7@inflateCop

; 1469 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1470 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  00124	48 c7 c1 b0 fa
	ff ff		 mov	 rcx, -1360		; fffffffffffffab0H
  0012b	48 2b ce	 sub	 rcx, rsi
  0012e	48 8d 04 11	 lea	 rax, QWORD PTR [rcx+rdx]
  00132	48 c1 f8 02	 sar	 rax, 2
  00136	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  0013c	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  00140	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 1471 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  00144	48 8b 46 68	 mov	 rax, QWORD PTR [rsi+104]
  00148	48 03 c1	 add	 rax, rcx
  0014b	48 c1 f8 02	 sar	 rax, 2
  0014f	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  00155	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  00159	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax
$LN7@inflateCop:

; 1472 :     }
; 1473 :     copy->next = copy->codes + (state->next - state->codes);

  0015d	48 8b 86 88 00
	00 00		 mov	 rax, QWORD PTR [rsi+136]
  00164	48 2b c6	 sub	 rax, rsi
  00167	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  0016d	48 c1 f8 02	 sar	 rax, 2
  00171	48 05 54 01 00
	00		 add	 rax, 340		; 00000154H
  00177	48 8d 04 83	 lea	 rax, QWORD PTR [rbx+rax*4]
  0017b	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 1474 :     if (window != Z_NULL) {

  00182	4d 85 f6	 test	 r14, r14
  00185	74 15		 je	 SHORT $LN8@inflateCop

; 1475 :         wsize = 1U << state->wbits;

  00187	8b 4e 30	 mov	 ecx, DWORD PTR [rsi+48]

; 1476 :         zmemcpy(window, state->window, wsize);

  0018a	48 8b 56 40	 mov	 rdx, QWORD PTR [rsi+64]
  0018e	41 d3 e7	 shl	 r15d, cl
  00191	49 8b ce	 mov	 rcx, r14
  00194	45 8b c7	 mov	 r8d, r15d
  00197	e8 00 00 00 00	 call	 memcpy
$LN8@inflateCop:

; 1477 :     }
; 1478 :     copy->window = window;

  0019c	4c 89 73 40	 mov	 QWORD PTR [rbx+64], r14

; 1479 :     dest->state = (struct internal_state FAR *)copy;
; 1480 :     return Z_OK;

  001a0	33 c0		 xor	 eax, eax
  001a2	48 89 5d 28	 mov	 QWORD PTR [rbp+40], rbx
  001a6	e9 f8 fe ff ff	 jmp	 $LN26@inflateCop
$LN3@inflateCop:

; 1447 :         return Z_STREAM_ERROR;

  001ab	b8 fe ff ff ff	 mov	 eax, -2

; 1481 : }

  001b0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001b4	5f		 pop	 rdi
  001b5	5d		 pop	 rbp
  001b6	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateUndermine
_TEXT	SEGMENT
strm$ = 48
subvert$ = 56
inflateUndermine PROC					; COMDAT

; 1483 : int ZEXPORT inflateUndermine(z_streamp strm, int subvert) {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1484 :     struct inflate_state FAR *state;
; 1485 : 
; 1486 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateUnd
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1495 : #endif
; 1496 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateUnd:

; 1487 :     state = (struct inflate_state FAR *)strm->state;
; 1488 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1489 :     state->sane = !subvert;
; 1490 :     return Z_OK;
; 1491 : #else
; 1492 :     (void)subvert;
; 1493 :     state->sane = 1;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  0001b	c7 80 e0 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7136], 1

; 1494 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3

; 1495 : #endif
; 1496 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateValidate
_TEXT	SEGMENT
strm$ = 48
check$ = 56
inflateValidate PROC					; COMDAT

; 1498 : int ZEXPORT inflateValidate(z_streamp strm, int check) {

$LN10:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1499 :     struct inflate_state FAR *state;
; 1500 : 
; 1501 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateVal
  0000d	b8 fe ff ff ff	 mov	 eax, -2

; 1508 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateVal:

; 1502 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1503 :     if (check && state->wrap)

  0001b	85 d2		 test	 edx, edx
  0001d	74 14		 je	 SHORT $LN8@inflateVal
  0001f	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00022	85 c9		 test	 ecx, ecx
  00024	74 0d		 je	 SHORT $LN8@inflateVal

; 1504 :         state->wrap |= 4;

  00026	83 c9 04	 or	 ecx, 4
  00029	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 1507 :     return Z_OK;

  0002c	33 c0		 xor	 eax, eax

; 1508 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
$LN8@inflateVal:

; 1505 :     else
; 1506 :         state->wrap &= ~4;

  00033	83 60 10 fb	 and	 DWORD PTR [rax+16], -5

; 1507 :     return Z_OK;

  00037	33 c0		 xor	 eax, eax

; 1508 : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
inflateValidate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateMark
_TEXT	SEGMENT
strm$ = 48
inflateMark PROC					; COMDAT

; 1510 : long ZEXPORT inflateMark(z_streamp strm) {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1511 :     struct inflate_state FAR *state;
; 1512 : 
; 1513 :     if (inflateStateCheck(strm))

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateMar

; 1514 :         return -(1L << 16);

  0000d	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H

; 1517 :         (state->mode == COPY ? state->length :
; 1518 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1519 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateMar:

; 1515 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]

; 1516 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 13		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  00029	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  0002f	c1 e0 10	 shl	 eax, 16
  00032	03 c1		 add	 eax, ecx

; 1517 :         (state->mode == COPY ? state->length :
; 1518 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1519 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
$LN6@inflateMar:

; 1516 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00039	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003f	75 19		 jne	 SHORT $LN4@inflateMar
  00041	8b 88 e8 1b 00
	00		 mov	 ecx, DWORD PTR [rax+7144]
  00047	2b 48 50	 sub	 ecx, DWORD PTR [rax+80]
  0004a	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  00050	c1 e0 10	 shl	 eax, 16
  00053	03 c1		 add	 eax, ecx

; 1517 :         (state->mode == COPY ? state->length :
; 1518 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1519 : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
$LN4@inflateMar:

; 1516 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0005a	8b 80 e4 1b 00
	00		 mov	 eax, DWORD PTR [rax+7140]
  00060	33 c9		 xor	 ecx, ecx
  00062	c1 e0 10	 shl	 eax, 16
  00065	03 c1		 add	 eax, ecx

; 1517 :         (state->mode == COPY ? state->length :
; 1518 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1519 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inflate.c
;	COMDAT inflateCodesUsed
_TEXT	SEGMENT
strm$ = 48
inflateCodesUsed PROC					; COMDAT

; 1521 : unsigned long ZEXPORT inflateCodesUsed(z_streamp strm) {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1522 :     struct inflate_state FAR *state;
; 1523 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00004	e8 00 00 00 00	 call	 inflateStateCheck
  00009	85 c0		 test	 eax, eax
  0000b	74 0a		 je	 SHORT $LN2@inflateCod
  0000d	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH

; 1526 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@inflateCod:

; 1524 :     state = (struct inflate_state FAR *)strm->state;

  00017	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]

; 1525 :     return (unsigned long)(state->next - state->codes);

  0001b	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]
  00022	48 2b c1	 sub	 rax, rcx
  00025	48 2d 50 05 00
	00		 sub	 rax, 1360		; 00000550H
  0002b	48 c1 f8 02	 sar	 rax, 2

; 1526 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
inflateCodesUsed ENDP
_TEXT	ENDS
END
