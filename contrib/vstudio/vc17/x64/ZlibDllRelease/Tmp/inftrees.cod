; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35209.0 

include listing.inc

INCLUDELIB OLDNAMES

	ORG $+10
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	049H
	DW	0c8H
	ORG $+2
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
PUBLIC	inflate_table
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN270
	DD	imagerel $LN270+1433
	DD	imagerel $unwind$inflate_table
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 092101H
	DD	0f01ae221H
	DD	0d016e018H
	DD	07012c014H
	DD	030106011H
	DD	0500fH
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\inftrees.c
;	COMDAT inflate_table
_TEXT	SEGMENT
here$ = 0
match$1$ = 4
low$1$ = 8
mask$1$ = 12
count$ = 16
extra$2$ = 48
base$2$ = 56
offs$ = 64
min$2$ = 96
type$ = 192
lens$ = 200
codes$ = 208
tv1998 = 208
tv2232 = 208
table$ = 216
bits$ = 224
work$ = 232
inflate_table PROC					; COMDAT

; 34   :                                 unsigned FAR *bits, unsigned short FAR *work) {

$LN270:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	55		 push	 rbp
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 55		 push	 r13
  00016	41 56		 push	 r14
  00018	41 57		 push	 r15
  0001a	48 8b ec	 mov	 rbp, rsp
  0001d	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 35   :     unsigned len;               /* a code's length in bits */
; 36   :     unsigned sym;               /* index of code symbols */
; 37   :     unsigned min, max;          /* minimum and maximum code lengths */
; 38   :     unsigned root;              /* number of index bits for root table */
; 39   :     unsigned curr;              /* number of index bits for current table */
; 40   :     unsigned drop;              /* code bits to drop for sub-table */
; 41   :     int left;                   /* number of prefix codes available */
; 42   :     unsigned used;              /* code entries in table used */
; 43   :     unsigned huff;              /* Huffman code */
; 44   :     unsigned incr;              /* for incrementing code, index */
; 45   :     unsigned fill;              /* index for replicating entries */
; 46   :     unsigned low;               /* low bits for current root entry */
; 47   :     unsigned mask;              /* mask for low root bits */
; 48   :     code here;                  /* table entry for duplication */
; 49   :     code FAR *next;             /* next available space in table */
; 50   :     const unsigned short FAR *base;     /* base value table to use */
; 51   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 52   :     unsigned match;             /* use base and extra for symbol >= match */
; 53   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 54   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 55   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 56   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 57   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 58   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 59   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 60   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 200};
; 61   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 62   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 63   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 64   :         8193, 12289, 16385, 24577, 0, 0};
; 65   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 66   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 67   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 68   :         28, 28, 29, 29, 64, 64};
; 69   : 
; 70   :     /*
; 71   :        Process a set of code lengths to create a canonical Huffman code.  The
; 72   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 73   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 74   :        symbols by length from short to long, and retaining the symbol order
; 75   :        for codes with equal lengths.  Then the code starts with all zero bits
; 76   :        for the first code of the shortest length, and the codes are integer
; 77   :        increments for the same length, and zeros are appended as the length
; 78   :        increases.  For the deflate format, these bits are stored backwards
; 79   :        from their more natural integer increment ordering, and so when the
; 80   :        decoding tables are built in the large loop below, the integer codes
; 81   :        are incremented backwards.
; 82   : 
; 83   :        This routine assumes, but does not check, that all of the entries in
; 84   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 85   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 86   :        symbol does not occur in this code.
; 87   : 
; 88   :        The codes are sorted by computing a count of codes for each length,
; 89   :        creating from that a table of starting indices for each length in the
; 90   :        sorted table, and then entering the symbols in order in the sorted
; 91   :        table.  The sorted table is work[], with that space being provided by
; 92   :        the caller.
; 93   : 
; 94   :        The length counts are used for other purposes as well, i.e. finding
; 95   :        the minimum and maximum length codes, determining if there are any
; 96   :        codes at all, checking for a valid set of lengths, and looking ahead
; 97   :        at length counts to determine sub-table sizes when building the
; 98   :        decoding tables.
; 99   :      */
; 100  : 
; 101  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 102  :     for (len = 0; len <= MAXBITS; len++)
; 103  :         count[len] = 0;

  00021	45 33 e4	 xor	 r12d, r12d
  00024	41 8b f8	 mov	 edi, r8d
  00027	4c 89 65 98	 mov	 QWORD PTR count$[rbp-120], r12
  0002b	45 0f b7 dc	 movzx	 r11d, r12w
  0002f	4c 89 65 a0	 mov	 QWORD PTR count$[rbp-112], r12
  00033	41 0f b7 f4	 movzx	 esi, r12w
  00037	4c 89 65 a8	 mov	 QWORD PTR count$[rbp-104], r12
  0003b	45 0f b7 f4	 movzx	 r14d, r12w
  0003f	4c 89 65 b0	 mov	 QWORD PTR count$[rbp-96], r12
  00043	45 0f b7 fc	 movzx	 r15d, r12w
  00047	45 0f b7 ec	 movzx	 r13d, r12w

; 104  :     for (sym = 0; sym < codes; sym++)

  0004b	45 85 c0	 test	 r8d, r8d
  0004e	74 3a		 je	 SHORT $LN6@inflate_ta

; 35   :     unsigned len;               /* a code's length in bits */
; 36   :     unsigned sym;               /* index of code symbols */
; 37   :     unsigned min, max;          /* minimum and maximum code lengths */
; 38   :     unsigned root;              /* number of index bits for root table */
; 39   :     unsigned curr;              /* number of index bits for current table */
; 40   :     unsigned drop;              /* code bits to drop for sub-table */
; 41   :     int left;                   /* number of prefix codes available */
; 42   :     unsigned used;              /* code entries in table used */
; 43   :     unsigned huff;              /* Huffman code */
; 44   :     unsigned incr;              /* for incrementing code, index */
; 45   :     unsigned fill;              /* index for replicating entries */
; 46   :     unsigned low;               /* low bits for current root entry */
; 47   :     unsigned mask;              /* mask for low root bits */
; 48   :     code here;                  /* table entry for duplication */
; 49   :     code FAR *next;             /* next available space in table */
; 50   :     const unsigned short FAR *base;     /* base value table to use */
; 51   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 52   :     unsigned match;             /* use base and extra for symbol >= match */
; 53   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 54   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 55   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 56   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 57   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 58   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 59   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 60   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 200};
; 61   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 62   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 63   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 64   :         8193, 12289, 16385, 24577, 0, 0};
; 65   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 66   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 67   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 68   :         28, 28, 29, 29, 64, 64};
; 69   : 
; 70   :     /*
; 71   :        Process a set of code lengths to create a canonical Huffman code.  The
; 72   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 73   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 74   :        symbols by length from short to long, and retaining the symbol order
; 75   :        for codes with equal lengths.  Then the code starts with all zero bits
; 76   :        for the first code of the shortest length, and the codes are integer
; 77   :        increments for the same length, and zeros are appended as the length
; 78   :        increases.  For the deflate format, these bits are stored backwards
; 79   :        from their more natural integer increment ordering, and so when the
; 80   :        decoding tables are built in the large loop below, the integer codes
; 81   :        are incremented backwards.
; 82   : 
; 83   :        This routine assumes, but does not check, that all of the entries in
; 84   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 85   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 86   :        symbol does not occur in this code.
; 87   : 
; 88   :        The codes are sorted by computing a count of codes for each length,
; 89   :        creating from that a table of starting indices for each length in the
; 90   :        sorted table, and then entering the symbols in order in the sorted
; 91   :        table.  The sorted table is work[], with that space being provided by
; 92   :        the caller.
; 93   : 
; 94   :        The length counts are used for other purposes as well, i.e. finding
; 95   :        the minimum and maximum length codes, determining if there are any
; 96   :        codes at all, checking for a valid set of lengths, and looking ahead
; 97   :        at length counts to determine sub-table sizes when building the
; 98   :        decoding tables.
; 99   :      */
; 100  : 
; 101  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 102  :     for (len = 0; len <= MAXBITS; len++)
; 103  :         count[len] = 0;

  00050	48 8b ca	 mov	 rcx, rdx
  00053	8b d7		 mov	 edx, edi
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL7@inflate_ta:

; 105  :         count[lens[sym]]++;

  00060	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00063	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
  00067	66 ff 44 45 98	 inc	 WORD PTR count$[rbp+rax*2-120]
  0006c	48 83 ea 01	 sub	 rdx, 1
  00070	75 ee		 jne	 SHORT $LL7@inflate_ta
  00072	44 0f b7 6d a2	 movzx	 r13d, WORD PTR count$[rbp-110]
  00077	44 0f b7 7d a0	 movzx	 r15d, WORD PTR count$[rbp-112]
  0007c	44 0f b7 75 9e	 movzx	 r14d, WORD PTR count$[rbp-114]
  00081	0f b7 75 9c	 movzx	 esi, WORD PTR count$[rbp-116]
  00085	44 0f b7 5d 9a	 movzx	 r11d, WORD PTR count$[rbp-118]
$LN6@inflate_ta:

; 106  : 
; 107  :     /* bound code lengths, force root to be within code lengths */
; 108  :     root = *bits;

  0008a	4c 8b 55 68	 mov	 r10, QWORD PTR bits$[rbp-120]

; 109  :     for (max = MAXBITS; max >= 1; max--)

  0008e	bb 0f 00 00 00	 mov	 ebx, 15
  00093	ba 0d 00 00 00	 mov	 edx, 13
  00098	45 8b 02	 mov	 r8d, DWORD PTR [r10]
  0009b	0f 1f 44 00 00	 npad	 5
$LL10@inflate_ta:

; 110  :         if (count[max] != 0) break;

  000a0	8b c3		 mov	 eax, ebx
  000a2	66 44 39 64 45
	98		 cmp	 WORD PTR count$[rbp+rax*2-120], r12w
  000a8	75 49		 jne	 SHORT $LN78@inflate_ta
  000aa	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  000ad	66 44 39 64 45
	98		 cmp	 WORD PTR count$[rbp+rax*2-120], r12w
  000b3	75 3c		 jne	 SHORT $LN177@inflate_ta
  000b5	8b c2		 mov	 eax, edx
  000b7	66 44 39 64 45
	98		 cmp	 WORD PTR count$[rbp+rax*2-120], r12w
  000bd	75 2d		 jne	 SHORT $LN178@inflate_ta
  000bf	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  000c2	66 44 39 64 45
	98		 cmp	 WORD PTR count$[rbp+rax*2-120], r12w
  000c8	75 1d		 jne	 SHORT $LN179@inflate_ta
  000ca	8d 42 fe	 lea	 eax, DWORD PTR [rdx-2]
  000cd	66 44 39 64 45
	98		 cmp	 WORD PTR count$[rbp+rax*2-120], r12w
  000d3	75 0d		 jne	 SHORT $LN180@inflate_ta

; 109  :     for (max = MAXBITS; max >= 1; max--)

  000d5	83 c3 fb	 add	 ebx, -5			; fffffffbH
  000d8	83 c2 fb	 add	 edx, -5			; fffffffbH
  000db	83 fb 01	 cmp	 ebx, 1
  000de	73 c0		 jae	 SHORT $LL10@inflate_ta
  000e0	eb 11		 jmp	 SHORT $LN78@inflate_ta
$LN180@inflate_ta:

; 110  :         if (count[max] != 0) break;

  000e2	83 c3 fc	 add	 ebx, -4			; fffffffcH
  000e5	eb 0c		 jmp	 SHORT $LN78@inflate_ta
$LN179@inflate_ta:
  000e7	83 c3 fd	 add	 ebx, -3			; fffffffdH
  000ea	eb 07		 jmp	 SHORT $LN78@inflate_ta
$LN178@inflate_ta:
  000ec	83 c3 fe	 add	 ebx, -2			; fffffffeH
  000ef	eb 02		 jmp	 SHORT $LN78@inflate_ta
$LN177@inflate_ta:
  000f1	ff cb		 dec	 ebx
$LN78@inflate_ta:

; 111  :     if (root > max) root = max;
; 112  :     if (max == 0) {                     /* no symbols to code at all */

  000f3	44 3b c3	 cmp	 r8d, ebx
  000f6	8b cb		 mov	 ecx, ebx
  000f8	41 0f 46 c8	 cmovbe	 ecx, r8d
  000fc	85 db		 test	 ebx, ebx
  000fe	75 2a		 jne	 SHORT $LN37@inflate_ta

; 113  :         here.op = (unsigned char)64;    /* invalid code marker */
; 114  :         here.bits = (unsigned char)1;
; 115  :         here.val = (unsigned short)0;
; 116  :         *(*table)++ = here;             /* make a table to force an error */

  00100	49 8b 09	 mov	 rcx, QWORD PTR [r9]
  00103	c7 45 88 40 01
	00 00		 mov	 DWORD PTR here$[rbp-120], 320 ; 00000140H
  0010a	8b 45 88	 mov	 eax, DWORD PTR here$[rbp-120]
  0010d	89 01		 mov	 DWORD PTR [rcx], eax
  0010f	49 83 01 04	 add	 QWORD PTR [r9], 4
  00113	49 8b 09	 mov	 rcx, QWORD PTR [r9]
  00116	89 01		 mov	 DWORD PTR [rcx], eax
  00118	49 83 01 04	 add	 QWORD PTR [r9], 4

; 117  :         *(*table)++ = here;
; 118  :         *bits = 1;
; 119  :         return 0;     /* no symbols, but wait for decoding to report error */

  0011c	33 c0		 xor	 eax, eax
  0011e	41 c7 02 01 00
	00 00		 mov	 DWORD PTR [r10], 1
  00125	e9 5e 04 00 00	 jmp	 $LN1@inflate_ta
$LN37@inflate_ta:

; 120  :     }
; 121  :     for (min = 1; min < max; min++)

  0012a	41 ba 01 00 00
	00		 mov	 r10d, 1
  00130	41 3b da	 cmp	 ebx, r10d
  00133	76 1d		 jbe	 SHORT $LN222@inflate_ta
  00135	48 8d 45 9a	 lea	 rax, QWORD PTR count$[rbp-118]
  00139	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@inflate_ta:

; 122  :         if (count[min] != 0) break;

  00140	66 44 39 20	 cmp	 WORD PTR [rax], r12w
  00144	75 0c		 jne	 SHORT $LN222@inflate_ta

; 120  :     }
; 121  :     for (min = 1; min < max; min++)

  00146	41 ff c2	 inc	 r10d
  00149	48 83 c0 02	 add	 rax, 2
  0014d	44 3b d3	 cmp	 r10d, ebx
  00150	72 ee		 jb	 SHORT $LL13@inflate_ta
$LN222@inflate_ta:

; 123  :     if (root < min) root = min;
; 124  : 
; 125  :     /* check for an over-subscribed or incomplete set of lengths */
; 126  :     left = 1;

  00152	41 3b ca	 cmp	 ecx, r10d
  00155	45 8b e2	 mov	 r12d, r10d

; 127  :     for (len = 1; len <= MAXBITS; len++) {

  00158	ba 01 00 00 00	 mov	 edx, 1
  0015d	44 0f 43 e1	 cmovae	 r12d, ecx
  00161	44 8b c2	 mov	 r8d, edx
  00164	44 89 65 58	 mov	 DWORD PTR tv2232[rbp-120], r12d
  00168	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL16@inflate_ta:

; 128  :         left <<= 1;
; 129  :         left -= count[len];

  00170	8b c2		 mov	 eax, edx
  00172	45 03 c0	 add	 r8d, r8d
  00175	0f b7 4c 45 98	 movzx	 ecx, WORD PTR count$[rbp+rax*2-120]
  0017a	44 2b c1	 sub	 r8d, ecx

; 130  :         if (left < 0) return -1;        /* over-subscribed */

  0017d	0f 88 00 04 00
	00		 js	 $LN42@inflate_ta

; 127  :     for (len = 1; len <= MAXBITS; len++) {

  00183	ff c2		 inc	 edx
  00185	83 fa 0f	 cmp	 edx, 15
  00188	76 e6		 jbe	 SHORT $LL16@inflate_ta

; 131  :     }
; 132  :     if (left > 0 && (type == CODES || max != 1))

  0018a	45 85 c0	 test	 r8d, r8d
  0018d	7e 13		 jle	 SHORT $LN41@inflate_ta
  0018f	83 7d 48 00	 cmp	 DWORD PTR type$[rbp-120], 0
  00193	0f 84 ea 03 00
	00		 je	 $LN42@inflate_ta
  00199	83 fb 01	 cmp	 ebx, 1
  0019c	0f 85 e1 03 00
	00		 jne	 $LN42@inflate_ta
$LN41@inflate_ta:

; 137  :     for (len = 1; len < MAXBITS; len++)
; 138  :         offs[len + 1] = offs[len] + count[len];

  001a2	66 44 89 5d cc	 mov	 WORD PTR offs$[rbp-116], r11w
  001a7	33 c0		 xor	 eax, eax
  001a9	66 44 03 de	 add	 r11w, si
  001ad	66 89 45 ca	 mov	 WORD PTR offs$[rbp-118], ax
  001b1	66 44 89 5d ce	 mov	 WORD PTR offs$[rbp-114], r11w

; 139  : 
; 140  :     /* sort symbols by length, by symbol order within each length */
; 141  :     for (sym = 0; sym < codes; sym++)

  001b6	33 f6		 xor	 esi, esi
  001b8	66 45 03 de	 add	 r11w, r14w
  001bc	44 8b c6	 mov	 r8d, esi
  001bf	66 44 89 5d d0	 mov	 WORD PTR offs$[rbp-112], r11w
  001c4	66 45 03 df	 add	 r11w, r15w
  001c8	66 44 89 5d d2	 mov	 WORD PTR offs$[rbp-110], r11w
  001cd	66 45 03 dd	 add	 r11w, r13w
  001d1	66 44 89 5d d4	 mov	 WORD PTR offs$[rbp-108], r11w
  001d6	66 44 03 5d a4	 add	 r11w, WORD PTR count$[rbp-108]
  001db	66 44 89 5d d6	 mov	 WORD PTR offs$[rbp-106], r11w
  001e0	66 44 03 5d a6	 add	 r11w, WORD PTR count$[rbp-106]
  001e5	66 44 89 5d d8	 mov	 WORD PTR offs$[rbp-104], r11w
  001ea	66 44 03 5d a8	 add	 r11w, WORD PTR count$[rbp-104]
  001ef	66 44 89 5d da	 mov	 WORD PTR offs$[rbp-102], r11w
  001f4	66 44 03 5d aa	 add	 r11w, WORD PTR count$[rbp-102]
  001f9	66 44 89 5d dc	 mov	 WORD PTR offs$[rbp-100], r11w
  001fe	66 44 03 5d ac	 add	 r11w, WORD PTR count$[rbp-100]
  00203	66 44 89 5d de	 mov	 WORD PTR offs$[rbp-98], r11w
  00208	66 44 03 5d ae	 add	 r11w, WORD PTR count$[rbp-98]
  0020d	66 44 89 5d e0	 mov	 WORD PTR offs$[rbp-96], r11w
  00212	66 44 03 5d b0	 add	 r11w, WORD PTR count$[rbp-96]
  00217	66 44 89 5d e2	 mov	 WORD PTR offs$[rbp-94], r11w
  0021c	66 44 03 5d b2	 add	 r11w, WORD PTR count$[rbp-94]
  00221	66 44 89 5d e4	 mov	 WORD PTR offs$[rbp-92], r11w
  00226	66 44 03 5d b4	 add	 r11w, WORD PTR count$[rbp-92]
  0022b	66 44 89 5d e6	 mov	 WORD PTR offs$[rbp-90], r11w
  00230	85 ff		 test	 edi, edi
  00232	74 32		 je	 SHORT $LN21@inflate_ta

; 134  : 
; 135  :     /* generate offsets into symbol table for each length for sorting */
; 136  :     offs[1] = 0;

  00234	48 8b 55 50	 mov	 rdx, QWORD PTR lens$[rbp-120]
  00238	4c 8b 5d 70	 mov	 r11, QWORD PTR work$[rbp-120]
  0023c	0f 1f 40 00	 npad	 4
$LL22@inflate_ta:

; 142  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00240	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00243	66 85 c0	 test	 ax, ax
  00246	74 12		 je	 SHORT $LN20@inflate_ta
  00248	0f b7 4c 45 c8	 movzx	 ecx, WORD PTR offs$[rbp+rax*2-120]
  0024d	66 45 89 04 4b	 mov	 WORD PTR [r11+rcx*2], r8w
  00252	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00255	66 ff 44 45 c8	 inc	 WORD PTR offs$[rbp+rax*2-120]
$LN20@inflate_ta:

; 139  : 
; 140  :     /* sort symbols by length, by symbol order within each length */
; 141  :     for (sym = 0; sym < codes; sym++)

  0025a	41 ff c0	 inc	 r8d
  0025d	48 83 c2 02	 add	 rdx, 2
  00261	44 3b c7	 cmp	 r8d, edi
  00264	72 da		 jb	 SHORT $LL22@inflate_ta
$LN21@inflate_ta:

; 143  : 
; 144  :     /*
; 145  :        Create and fill in decoding tables.  In this loop, the table being
; 146  :        filled is at next and has curr index bits.  The code being used is huff
; 147  :        with length len.  That code is converted to an index by dropping drop
; 148  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 149  :        those top drop + curr - len bits are incremented through all values to
; 150  :        fill the table with replicated entries.
; 151  : 
; 152  :        root is the number of index bits for the root table.  When len exceeds
; 153  :        root, sub-tables are created pointed to by the root entry with an index
; 154  :        of the low root bits of huff.  This is saved in low to check for when a
; 155  :        new sub-table should be started.  drop is zero when the root table is
; 156  :        being filled, and drop is root when sub-tables are being filled.
; 157  : 
; 158  :        When a new sub-table is needed, it is necessary to look ahead in the
; 159  :        code lengths to determine what size sub-table is needed.  The length
; 160  :        counts are used for this, and so count[] is decremented as codes are
; 161  :        entered in the tables.
; 162  : 
; 163  :        used keeps track of how many table entries have been allocated from the
; 164  :        provided *table space.  It is checked for LENS and DIST tables against
; 165  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 166  :        the initial root table size constants.  See the comments in inftrees.h
; 167  :        for more information.
; 168  : 
; 169  :        sym increments through all symbols, and the loop terminates when
; 170  :        all codes of length max, i.e. all codes, have been processed.  This
; 171  :        routine permits incomplete codes, so another loop after this one fills
; 172  :        in the rest of the decoding tables with invalid code markers.
; 173  :      */
; 174  : 
; 175  :     /* set up for code type */
; 176  :     switch (type) {

  00266	8b 4d 48	 mov	 ecx, DWORD PTR type$[rbp-120]
  00269	44 8b de	 mov	 r11d, esi
  0026c	4d 8b 31	 mov	 r14, QWORD PTR [r9]
  0026f	44 8b ee	 mov	 r13d, esi
  00272	45 8b cc	 mov	 r9d, r12d
  00275	85 c9		 test	 ecx, ecx
  00277	0f 84 f7 00 00
	00		 je	 $LN44@inflate_ta
  0027d	83 f9 01	 cmp	 ecx, 1
  00280	41 8b cc	 mov	 ecx, r12d
  00283	0f 84 a5 00 00
	00		 je	 $LN45@inflate_ta

; 185  :         break;
; 186  :     default:    /* DISTS */
; 187  :         base = dbase;
; 188  :         extra = dext;
; 189  :         match = 0;
; 190  :     }
; 191  : 
; 192  :     /* initialize state for loop */
; 193  :     huff = 0;                   /* starting code */
; 194  :     sym = 0;                    /* starting code symbol */
; 195  :     len = min;                  /* starting code length */
; 196  :     next = *table;              /* current table to fill in */
; 197  :     curr = root;                /* current table index bits */
; 198  :     drop = 0;                   /* current bits to drop from code for index */
; 199  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */

  00289	41 bf ff ff ff
	ff		 mov	 r15d, -1		; ffffffffH

; 200  :     used = 1U << root;          /* use root table entries */
; 201  :     mask = used - 1;            /* mask for comparing low */

  0028f	89 75 8c	 mov	 DWORD PTR match$1$[rbp-120], esi
  00292	44 89 7d 90	 mov	 DWORD PTR low$1$[rbp-120], r15d
  00296	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  0029d	41 bf 01 00 00
	00		 mov	 r15d, 1
  002a3	48 89 45 b8	 mov	 QWORD PTR extra$2$[rbp-120], rax
  002a7	41 d3 e7	 shl	 r15d, cl
  002aa	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:?dbase@?1??inflate_table@@9@9

; 202  : 
; 203  :     /* check available table space */
; 204  :     if ((type == LENS && used > ENOUGH_LENS) ||

  002b1	83 7d 48 01	 cmp	 DWORD PTR type$[rbp-120], 1
  002b5	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  002bc	48 89 7d c0	 mov	 QWORD PTR base$2$[rbp-120], rdi
  002c0	41 8b c7	 mov	 eax, r15d
  002c3	41 8d 4f ff	 lea	 ecx, DWORD PTR [r15-1]
  002c7	89 4d 94	 mov	 DWORD PTR mask$1$[rbp-120], ecx
  002ca	0f 84 92 00 00
	00		 je	 $LN205@inflate_ta
  002d0	83 7d 48 02	 cmp	 DWORD PTR type$[rbp-120], 2
  002d4	41 bf ff ff ff
	ff		 mov	 r15d, -1		; ffffffffH
  002da	44 8b 4d 58	 mov	 r9d, DWORD PTR tv2232[rbp-120]
  002de	44 89 7d 90	 mov	 DWORD PTR low$1$[rbp-120], r15d
  002e2	44 8b f8	 mov	 r15d, eax
  002e5	48 89 7d c0	 mov	 QWORD PTR base$2$[rbp-120], rdi
  002e9	4c 89 65 b8	 mov	 QWORD PTR extra$2$[rbp-120], r12
  002ed	89 75 8c	 mov	 DWORD PTR match$1$[rbp-120], esi
  002f0	89 4d 94	 mov	 DWORD PTR mask$1$[rbp-120], ecx
  002f3	0f 85 af 00 00
	00		 jne	 $LN224@inflate_ta
  002f9	41 bf ff ff ff
	ff		 mov	 r15d, -1		; ffffffffH
  002ff	48 89 7d c0	 mov	 QWORD PTR base$2$[rbp-120], rdi
  00303	33 ff		 xor	 edi, edi
  00305	4c 89 65 b8	 mov	 QWORD PTR extra$2$[rbp-120], r12
  00309	44 89 7d 90	 mov	 DWORD PTR low$1$[rbp-120], r15d
  0030d	45 8b e1	 mov	 r12d, r9d
  00310	89 7d 8c	 mov	 DWORD PTR match$1$[rbp-120], edi
  00313	44 8b f8	 mov	 r15d, eax
  00316	89 4d 94	 mov	 DWORD PTR mask$1$[rbp-120], ecx
  00319	3d 50 02 00 00	 cmp	 eax, 592		; 00000250H
  0031e	0f 86 88 00 00
	00		 jbe	 $LN265@inflate_ta
$LN62@inflate_ta:

; 274  :                 (type == DISTS && used > ENOUGH_DISTS))
; 275  :                 return 1;

  00324	b8 01 00 00 00	 mov	 eax, 1
  00329	e9 5a 02 00 00	 jmp	 $LN1@inflate_ta
$LN45@inflate_ta:

; 180  :         break;
; 181  :     case LENS:
; 182  :         base = lbase;

  0032e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9

; 183  :         extra = lext;
; 184  :         match = 257;

  00335	c7 45 8c 01 01
	00 00		 mov	 DWORD PTR match$1$[rbp-120], 257 ; 00000101H
  0033c	48 89 45 c0	 mov	 QWORD PTR base$2$[rbp-120], rax
  00340	41 bf 01 00 00
	00		 mov	 r15d, 1
  00346	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  0034d	41 d3 e7	 shl	 r15d, cl
  00350	48 89 45 b8	 mov	 QWORD PTR extra$2$[rbp-120], rax
  00354	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR low$1$[rbp-120], -1 ; ffffffffH
  0035b	41 8d 47 ff	 lea	 eax, DWORD PTR [r15-1]
  0035f	89 45 94	 mov	 DWORD PTR mask$1$[rbp-120], eax
$LN205@inflate_ta:

; 202  : 
; 203  :     /* check available table space */
; 204  :     if ((type == LENS && used > ENOUGH_LENS) ||

  00362	41 81 ff 54 03
	00 00		 cmp	 r15d, 852		; 00000354H
  00369	77 b9		 ja	 SHORT $LN62@inflate_ta
  0036b	44 8b 65 58	 mov	 r12d, DWORD PTR tv2232[rbp-120]
  0036f	8b 55 8c	 mov	 edx, DWORD PTR match$1$[rbp-120]
  00372	eb 3a		 jmp	 SHORT $LN266@inflate_ta
$LN44@inflate_ta:

; 177  :     case CODES:
; 178  :         base = extra = work;    /* dummy value--not used */

  00374	4c 8b 45 70	 mov	 r8, QWORD PTR work$[rbp-120]

; 179  :         match = 20;

  00378	41 8b cc	 mov	 ecx, r12d
  0037b	44 8b 65 58	 mov	 r12d, DWORD PTR tv2232[rbp-120]
  0037f	41 bf 01 00 00
	00		 mov	 r15d, 1
  00385	41 d3 e7	 shl	 r15d, cl
  00388	ba 14 00 00 00	 mov	 edx, 20
  0038d	4c 89 45 b8	 mov	 QWORD PTR extra$2$[rbp-120], r8
  00391	4c 89 45 c0	 mov	 QWORD PTR base$2$[rbp-120], r8
  00395	89 55 8c	 mov	 DWORD PTR match$1$[rbp-120], edx
  00398	41 8d 47 ff	 lea	 eax, DWORD PTR [r15-1]
  0039c	c7 45 90 ff ff
	ff ff		 mov	 DWORD PTR low$1$[rbp-120], -1 ; ffffffffH
  003a3	89 45 94	 mov	 DWORD PTR mask$1$[rbp-120], eax

; 202  : 
; 203  :     /* check available table space */
; 204  :     if ((type == LENS && used > ENOUGH_LENS) ||

  003a6	eb 0a		 jmp	 SHORT $LL27@inflate_ta
$LN224@inflate_ta:
  003a8	44 8b 65 58	 mov	 r12d, DWORD PTR tv2232[rbp-120]
$LN265@inflate_ta:

; 205  :         (type == DISTS && used > ENOUGH_DISTS))
; 206  :         return 1;
; 207  : 
; 208  :     /* process all codes and make table entries */
; 209  :     for (;;) {
; 210  :         /* create table entry */
; 211  :         here.bits = (unsigned char)(len - drop);

  003ac	8b d6		 mov	 edx, esi
$LN266@inflate_ta:
  003ae	4c 8b 45 70	 mov	 r8, QWORD PTR work$[rbp-120]
$LL27@inflate_ta:
  003b2	41 0f b6 c2	 movzx	 eax, r10b
  003b6	40 2a c6	 sub	 al, sil
  003b9	88 45 89	 mov	 BYTE PTR here$[rbp-119], al

; 212  :         if (work[sym] + 1U < match) {

  003bc	41 8b c5	 mov	 eax, r13d
  003bf	41 0f b7 0c 40	 movzx	 ecx, WORD PTR [r8+rax*2]
  003c4	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  003c7	3b c2		 cmp	 eax, edx
  003c9	73 0a		 jae	 SHORT $LN50@inflate_ta

; 213  :             here.op = (unsigned char)0;

  003cb	c6 45 88 00	 mov	 BYTE PTR here$[rbp-120], 0

; 214  :             here.val = work[sym];

  003cf	66 89 4d 8a	 mov	 WORD PTR here$[rbp-118], cx

; 215  :         }

  003d3	eb 28		 jmp	 SHORT $LN53@inflate_ta
$LN50@inflate_ta:

; 216  :         else if (work[sym] >= match) {

  003d5	3b ca		 cmp	 ecx, edx
  003d7	72 1a		 jb	 SHORT $LN52@inflate_ta

; 217  :             here.op = (unsigned char)(extra[work[sym] - match]);

  003d9	48 8b 45 b8	 mov	 rax, QWORD PTR extra$2$[rbp-120]
  003dd	2b ca		 sub	 ecx, edx
  003df	48 03 c9	 add	 rcx, rcx
  003e2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003e6	88 45 88	 mov	 BYTE PTR here$[rbp-120], al

; 218  :             here.val = base[work[sym] - match];

  003e9	48 8b 45 c0	 mov	 rax, QWORD PTR base$2$[rbp-120]
  003ed	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]

; 219  :         }

  003f1	eb 06		 jmp	 SHORT $LN267@inflate_ta
$LN52@inflate_ta:

; 220  :         else {
; 221  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  003f3	c6 45 88 60	 mov	 BYTE PTR here$[rbp-120], 96 ; 00000060H

; 222  :             here.val = 0;

  003f7	33 c0		 xor	 eax, eax
$LN267@inflate_ta:

; 223  :         }
; 224  : 
; 225  :         /* replicate for those indices with low len bits equal to huff */
; 226  :         incr = 1U << (len - drop);

  003f9	66 89 45 8a	 mov	 WORD PTR here$[rbp-118], ax
$LN53@inflate_ta:
  003fd	8b 45 88	 mov	 eax, DWORD PTR here$[rbp-120]
  00400	41 8b ca	 mov	 ecx, r10d
  00403	2b ce		 sub	 ecx, esi
  00405	bf 01 00 00 00	 mov	 edi, 1
  0040a	d3 e7		 shl	 edi, cl

; 227  :         fill = 1U << curr;

  0040c	ba 01 00 00 00	 mov	 edx, 1
  00411	41 8b c9	 mov	 ecx, r9d
  00414	45 8b c3	 mov	 r8d, r11d
  00417	d3 e2		 shl	 edx, cl
  00419	8b ce		 mov	 ecx, esi
  0041b	41 d3 e8	 shr	 r8d, cl
  0041e	44 03 c2	 add	 r8d, edx

; 228  :         min = fill;                 /* save offset to next table */

  00421	89 55 e8	 mov	 DWORD PTR min$2$[rbp-120], edx
$LL30@inflate_ta:

; 229  :         do {
; 230  :             fill -= incr;

  00424	44 2b c7	 sub	 r8d, edi

; 231  :             next[(huff >> drop) + fill] = here;

  00427	43 89 04 86	 mov	 DWORD PTR [r14+r8*4], eax
  0042b	2b d7		 sub	 edx, edi

; 232  :         } while (fill != 0);

  0042d	75 f5		 jne	 SHORT $LL30@inflate_ta

; 233  : 
; 234  :         /* backwards increment the len-bit code huff */
; 235  :         incr = 1U << (len - 1);

  0042f	41 8d 4a ff	 lea	 ecx, DWORD PTR [r10-1]
  00433	ba 01 00 00 00	 mov	 edx, 1
  00438	d3 e2		 shl	 edx, cl

; 236  :         while (huff & incr)

  0043a	41 85 d3	 test	 edx, r11d
  0043d	74 08		 je	 SHORT $LN32@inflate_ta
  0043f	90		 npad	 1
$LL31@inflate_ta:

; 237  :             incr >>= 1;

  00440	d1 ea		 shr	 edx, 1
  00442	41 85 d3	 test	 edx, r11d
  00445	75 f9		 jne	 SHORT $LL31@inflate_ta
$LN32@inflate_ta:

; 238  :         if (incr != 0) {

  00447	85 d2		 test	 edx, edx
  00449	74 0d		 je	 SHORT $LN54@inflate_ta

; 239  :             huff &= incr - 1;

  0044b	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  0044e	44 23 d8	 and	 r11d, eax

; 240  :             huff += incr;

  00451	44 03 da	 add	 r11d, edx

; 241  :         }

  00454	33 c9		 xor	 ecx, ecx
  00456	eb 05		 jmp	 SHORT $LN55@inflate_ta
$LN54@inflate_ta:

; 242  :         else
; 243  :             huff = 0;

  00458	33 c9		 xor	 ecx, ecx
  0045a	44 8b d9	 mov	 r11d, ecx
$LN55@inflate_ta:

; 244  : 
; 245  :         /* go to next symbol, update count, len */
; 246  :         sym++;
; 247  :         if (--(count[len]) == 0) {

  0045d	41 8b c2	 mov	 eax, r10d
  00460	41 ff c5	 inc	 r13d
  00463	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00468	66 01 54 45 98	 add	 WORD PTR count$[rbp+rax*2-120], dx
  0046d	75 1d		 jne	 SHORT $LN225@inflate_ta

; 248  :             if (len == max) break;

  0046f	44 3b d3	 cmp	 r10d, ebx
  00472	0f 84 db 00 00
	00		 je	 $LN82@inflate_ta

; 249  :             len = lens[work[sym]];

  00478	4c 8b 45 70	 mov	 r8, QWORD PTR work$[rbp-120]
  0047c	48 8b 45 50	 mov	 rax, QWORD PTR lens$[rbp-120]
  00480	43 0f b7 0c 68	 movzx	 ecx, WORD PTR [r8+r13*2]
  00485	44 0f b7 14 48	 movzx	 r10d, WORD PTR [rax+rcx*2]
  0048a	eb 04		 jmp	 SHORT $LN56@inflate_ta
$LN225@inflate_ta:

; 244  : 
; 245  :         /* go to next symbol, update count, len */
; 246  :         sym++;
; 247  :         if (--(count[len]) == 0) {

  0048c	4c 8b 45 70	 mov	 r8, QWORD PTR work$[rbp-120]
$LN56@inflate_ta:

; 250  :         }
; 251  : 
; 252  :         /* create new sub-table if needed */
; 253  :         if (len > root && (huff & mask) != low) {

  00490	8b 55 8c	 mov	 edx, DWORD PTR match$1$[rbp-120]
  00493	45 3b d4	 cmp	 r10d, r12d
  00496	0f 86 16 ff ff
	ff		 jbe	 $LL27@inflate_ta
  0049c	8b 7d 94	 mov	 edi, DWORD PTR mask$1$[rbp-120]
  0049f	41 23 fb	 and	 edi, r11d
  004a2	3b 7d 90	 cmp	 edi, DWORD PTR low$1$[rbp-120]
  004a5	0f 84 07 ff ff
	ff		 je	 $LL27@inflate_ta

; 254  :             /* if first time, transition to sub-tables */
; 255  :             if (drop == 0)
; 256  :                 drop = root;
; 257  : 
; 258  :             /* increment past last table */
; 259  :             next += min;            /* here min is 1 << curr */

  004ab	8b 45 e8	 mov	 eax, DWORD PTR min$2$[rbp-120]
  004ae	85 f6		 test	 esi, esi

; 260  : 
; 261  :             /* determine length of next table */
; 262  :             curr = len - drop;

  004b0	45 8b ca	 mov	 r9d, r10d
  004b3	41 0f 44 f4	 cmove	 esi, r12d
  004b7	44 2b ce	 sub	 r9d, esi
  004ba	4d 8d 34 86	 lea	 r14, QWORD PTR [r14+rax*4]

; 263  :             left = (int)(1 << curr);

  004be	41 8b c9	 mov	 ecx, r9d
  004c1	b8 01 00 00 00	 mov	 eax, 1
  004c6	d3 e0		 shl	 eax, cl

; 264  :             while (curr + drop < max) {

  004c8	44 3b d3	 cmp	 r10d, ebx
  004cb	73 1e		 jae	 SHORT $LN223@inflate_ta

; 254  :             /* if first time, transition to sub-tables */
; 255  :             if (drop == 0)
; 256  :                 drop = root;
; 257  : 
; 258  :             /* increment past last table */
; 259  :             next += min;            /* here min is 1 << curr */

  004cd	45 8b c2	 mov	 r8d, r10d
$LL33@inflate_ta:

; 265  :                 left -= count[curr + drop];

  004d0	41 8b c8	 mov	 ecx, r8d
  004d3	0f b7 54 4d 98	 movzx	 edx, WORD PTR count$[rbp+rcx*2-120]
  004d8	2b c2		 sub	 eax, edx

; 266  :                 if (left <= 0) break;

  004da	85 c0		 test	 eax, eax
  004dc	7e 0d		 jle	 SHORT $LN223@inflate_ta

; 267  :                 curr++;

  004de	41 ff c1	 inc	 r9d
  004e1	41 ff c0	 inc	 r8d

; 268  :                 left <<= 1;

  004e4	03 c0		 add	 eax, eax
  004e6	44 3b c3	 cmp	 r8d, ebx
  004e9	72 e5		 jb	 SHORT $LL33@inflate_ta
$LN223@inflate_ta:

; 269  :             }
; 270  : 
; 271  :             /* check for enough space */
; 272  :             used += 1U << curr;

  004eb	41 8b c9	 mov	 ecx, r9d
  004ee	b8 01 00 00 00	 mov	 eax, 1
  004f3	d3 e0		 shl	 eax, cl
  004f5	44 03 f8	 add	 r15d, eax

; 273  :             if ((type == LENS && used > ENOUGH_LENS) ||

  004f8	8b 45 48	 mov	 eax, DWORD PTR type$[rbp-120]
  004fb	83 f8 01	 cmp	 eax, 1
  004fe	75 09		 jne	 SHORT $LN63@inflate_ta
  00500	41 81 ff 54 03
	00 00		 cmp	 r15d, 852		; 00000354H
  00507	eb 0c		 jmp	 SHORT $LN268@inflate_ta
$LN63@inflate_ta:
  00509	83 f8 02	 cmp	 eax, 2
  0050c	75 0d		 jne	 SHORT $LN61@inflate_ta
  0050e	41 81 ff 50 02
	00 00		 cmp	 r15d, 592		; 00000250H
$LN268@inflate_ta:

; 276  : 
; 277  :             /* point entry in root table to sub-table */
; 278  :             low = huff & mask;

  00515	0f 87 09 fe ff
	ff		 ja	 $LN62@inflate_ta
$LN61@inflate_ta:

; 279  :             (*table)[low].op = (unsigned char)curr;

  0051b	48 8b 4d 60	 mov	 rcx, QWORD PTR table$[rbp-120]
  0051f	48 8d 14 bd 00
	00 00 00	 lea	 rdx, QWORD PTR [rdi*4]
  00527	89 7d 90	 mov	 DWORD PTR low$1$[rbp-120], edi
  0052a	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0052d	44 88 0c 02	 mov	 BYTE PTR [rdx+rax], r9b

; 280  :             (*table)[low].bits = (unsigned char)root;

  00531	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00534	44 88 64 02 01	 mov	 BYTE PTR [rdx+rax+1], r12b

; 281  :             (*table)[low].val = (unsigned short)(next - *table);

  00539	49 8b c6	 mov	 rax, r14
  0053c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0053f	48 2b c1	 sub	 rax, rcx
  00542	48 c1 f8 02	 sar	 rax, 2
  00546	66 89 44 0a 02	 mov	 WORD PTR [rdx+rcx+2], ax
  0054b	8b 55 8c	 mov	 edx, DWORD PTR match$1$[rbp-120]
  0054e	e9 5b fe ff ff	 jmp	 $LN266@inflate_ta
$LN82@inflate_ta:

; 282  :         }
; 283  :     }
; 284  : 
; 285  :     /* fill in remaining table entry if code is incomplete (guaranteed to have
; 286  :        at most one remaining entry, since if the code is incomplete, the
; 287  :        maximum code length that was allowed to get this far is one bit) */
; 288  :     if (huff != 0) {

  00553	45 85 db	 test	 r11d, r11d
  00556	74 12		 je	 SHORT $LN64@inflate_ta

; 289  :         here.op = (unsigned char)64;            /* invalid code marker */
; 290  :         here.bits = (unsigned char)(len - drop);
; 291  :         here.val = (unsigned short)0;

  00558	66 89 4d 8a	 mov	 WORD PTR here$[rbp-118], cx

; 292  :         next[huff] = here;

  0055c	41 8b cb	 mov	 ecx, r11d
  0055f	c6 45 88 40	 mov	 BYTE PTR here$[rbp-120], 64 ; 00000040H
  00563	8b 45 88	 mov	 eax, DWORD PTR here$[rbp-120]
  00566	41 89 04 8e	 mov	 DWORD PTR [r14+rcx*4], eax
$LN64@inflate_ta:

; 293  :     }
; 294  : 
; 295  :     /* set return parameters */
; 296  :     *table += used;

  0056a	48 8b 4d 60	 mov	 rcx, QWORD PTR table$[rbp-120]
  0056e	41 8b c7	 mov	 eax, r15d
  00571	48 c1 e0 02	 shl	 rax, 2
  00575	48 01 01	 add	 QWORD PTR [rcx], rax

; 297  :     *bits = root;

  00578	48 8b 45 68	 mov	 rax, QWORD PTR bits$[rbp-120]
  0057c	44 89 20	 mov	 DWORD PTR [rax], r12d

; 298  :     return 0;

  0057f	33 c0		 xor	 eax, eax
  00581	eb 05		 jmp	 SHORT $LN1@inflate_ta
$LN42@inflate_ta:

; 133  :         return -1;                      /* incomplete set */

  00583	b8 ff ff ff ff	 mov	 eax, -1
$LN1@inflate_ta:

; 299  : }

  00588	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0058c	41 5f		 pop	 r15
  0058e	41 5e		 pop	 r14
  00590	41 5d		 pop	 r13
  00592	41 5c		 pop	 r12
  00594	5f		 pop	 rdi
  00595	5e		 pop	 rsi
  00596	5b		 pop	 rbx
  00597	5d		 pop	 rbp
  00598	c3		 ret	 0
inflate_table ENDP
_TEXT	ENDS
END
