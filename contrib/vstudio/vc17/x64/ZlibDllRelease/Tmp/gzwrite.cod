; Listing generated by Microsoft (R) Optimizing Compiler Version 19.44.35209.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@ ; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@ ; `string'
PUBLIC	??_C@_0CC@ENDIFONJ@string?5length?5does?5not?5fit?5in?5i@ ; `string'
EXTRN	__imp_write:PROC
;	COMDAT ??_C@_0CC@ENDIFONJ@string?5length?5does?5not?5fit?5in?5i@
CONST	SEGMENT
??_C@_0CC@ENDIFONJ@string?5length?5does?5not?5fit?5in?5i@ DB 'string leng'
	DB	'th does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@ DB 'requested le'
	DB	'ngth does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@ DB 'internal err'
	DB	'or: deflate stream corrupt', 00H		; `string'
PUBLIC	gzsetparams
PUBLIC	gzflush
PUBLIC	gzprintf
PUBLIC	gzvprintf
PUBLIC	gzputs
PUBLIC	gzputc
PUBLIC	gzfwrite
PUBLIC	gzwrite
PUBLIC	gzclose_w
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzsetparams DD imagerel $LN32
	DD	imagerel $LN32+64
	DD	imagerel $unwind$gzsetparams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gzsetparams DD imagerel $LN32+64
	DD	imagerel $LN32+102
	DD	imagerel $chain$1$gzsetparams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gzsetparams DD imagerel $LN32+102
	DD	imagerel $LN32+185
	DD	imagerel $chain$2$gzsetparams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gzsetparams DD imagerel $LN32+185
	DD	imagerel $LN32+210
	DD	imagerel $chain$3$gzsetparams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$gzsetparams DD imagerel $LN32+210
	DD	imagerel $LN32+239
	DD	imagerel $chain$5$gzsetparams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$gzsetparams DD imagerel $LN32+239
	DD	imagerel $LN32+259
	DD	imagerel $chain$6$gzsetparams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzflush DD imagerel $LN22
	DD	imagerel $LN22+107
	DD	imagerel $unwind$gzflush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzprintf DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$gzprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzvprintf DD imagerel $LN40
	DD	imagerel $LN40+129
	DD	imagerel $unwind$gzvprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gzvprintf DD imagerel $LN40+129
	DD	imagerel $LN40+331
	DD	imagerel $chain$1$gzvprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gzvprintf DD imagerel $LN40+331
	DD	imagerel $LN40+374
	DD	imagerel $chain$3$gzvprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$gzvprintf DD imagerel $LN40+374
	DD	imagerel $LN40+396
	DD	imagerel $chain$4$gzvprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputs DD imagerel $LN18
	DD	imagerel $LN18+33
	DD	imagerel $unwind$gzputs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gzputs DD imagerel $LN18+33
	DD	imagerel $LN18+95
	DD	imagerel $chain$0$gzputs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gzputs DD imagerel $LN18+95
	DD	imagerel $LN18+125
	DD	imagerel $chain$2$gzputs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gzputs DD imagerel $LN18+125
	DD	imagerel $LN18+138
	DD	imagerel $chain$3$gzputs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputc DD imagerel $LN27
	DD	imagerel $LN27+204
	DD	imagerel $unwind$gzputc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzfwrite DD imagerel $LN17
	DD	imagerel $LN17+114
	DD	imagerel $unwind$gzfwrite
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzwrite DD imagerel $LN9
	DD	imagerel $LN9+65
	DD	imagerel $unwind$gzwrite
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_write DD imagerel gz_write
	DD	imagerel gz_write+317
	DD	imagerel $unwind$gz_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_zero DD imagerel gz_zero
	DD	imagerel gz_zero+166
	DD	imagerel $unwind$gz_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_comp DD imagerel gz_comp
	DD	imagerel gz_comp+205
	DD	imagerel $unwind$gz_comp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gz_comp DD imagerel gz_comp+205
	DD	imagerel gz_comp+438
	DD	imagerel $chain$2$gz_comp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gz_comp DD imagerel gz_comp+438
	DD	imagerel gz_comp+457
	DD	imagerel $chain$3$gz_comp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_init DD imagerel gz_init
	DD	imagerel gz_init+291
	DD	imagerel $unwind$gz_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose_w DD imagerel $LN21
	DD	imagerel $LN21+207
	DD	imagerel $unwind$gzclose_w
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_w DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_init DD 085b01H
	DD	0b745bH
	DD	0a5456H
	DD	0c340aH
	DD	06006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gz_comp DD 021H
	DD	imagerel gz_comp
	DD	imagerel gz_comp+205
	DD	imagerel $unwind$gz_comp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gz_comp DD 020521H
	DD	085405H
	DD	imagerel gz_comp
	DD	imagerel gz_comp+205
	DD	imagerel $unwind$gz_comp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_comp DD 083d01H
	DD	0ae43dH
	DD	096438H
	DD	0f0053209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_zero DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_write DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzwrite DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzfwrite DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputc DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gzputs DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+33
	DD	imagerel $unwind$gzputs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gzputs DD 020021H
	DD	063400H
	DD	imagerel $LN18
	DD	imagerel $LN18+33
	DD	imagerel $unwind$gzputs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gzputs DD 020521H
	DD	063405H
	DD	imagerel $LN18
	DD	imagerel $LN18+33
	DD	imagerel $unwind$gzputs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputs DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$gzvprintf DD 021H
	DD	imagerel $LN40
	DD	imagerel $LN40+129
	DD	imagerel $unwind$gzvprintf
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gzvprintf DD 040021H
	DD	095400H
	DD	083400H
	DD	imagerel $LN40
	DD	imagerel $LN40+129
	DD	imagerel $unwind$gzvprintf
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gzvprintf DD 040a21H
	DD	09540aH
	DD	083405H
	DD	imagerel $LN40
	DD	imagerel $LN40+129
	DD	imagerel $unwind$gzvprintf
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzvprintf DD 061001H
	DD	0b7410H
	DD	0a6410H
	DD	0e00c5210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzprintf DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzflush DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$gzsetparams DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+64
	DD	imagerel $unwind$gzsetparams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$gzsetparams DD 060021H
	DD	0ac400H
	DD	097400H
	DD	086400H
	DD	imagerel $LN32
	DD	imagerel $LN32+64
	DD	imagerel $unwind$gzsetparams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gzsetparams DD 021H
	DD	imagerel $LN32+64
	DD	imagerel $LN32+102
	DD	imagerel $chain$1$gzsetparams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gzsetparams DD 020521H
	DD	0ac405H
	DD	imagerel $LN32+64
	DD	imagerel $LN32+102
	DD	imagerel $chain$1$gzsetparams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gzsetparams DD 040e21H
	DD	09740eH
	DD	086405H
	DD	imagerel $LN32
	DD	imagerel $LN32+64
	DD	imagerel $unwind$gzsetparams
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzsetparams DD 060e01H
	DD	0b340eH
	DD	0f00a320eH
	DD	05006e008H
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gzclose_w
_TEXT	SEGMENT
file$ = 48
gzclose_w PROC						; COMDAT

; 595  : int ZEXPORT gzclose_w(gzFile file) {

$LN21:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 596  :     int ret = Z_OK;

  0000a	33 ff		 xor	 edi, edi
  0000c	48 8b d9	 mov	 rbx, rcx

; 597  :     gz_statep state;
; 598  : 
; 599  :     /* get internal structure */
; 600  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	0f 84 a7 00 00
	00		 je	 $LN11@gzclose_w

; 601  :         return Z_STREAM_ERROR;
; 602  :     state = (gz_statep)file;
; 603  : 
; 604  :     /* check that we're writing */
; 605  :     if (state->mode != GZ_WRITE)

  00018	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  0001f	0f 85 9a 00 00
	00		 jne	 $LN11@gzclose_w

; 606  :         return Z_STREAM_ERROR;
; 607  : 
; 608  :     /* check for seek request */
; 609  :     if (state->seek) {

  00025	39 79 70	 cmp	 DWORD PTR [rcx+112], edi
  00028	74 14		 je	 SHORT $LN5@gzclose_w

; 610  :         state->seek = 0;
; 611  :         if (gz_zero(state, state->skip) == -1)

  0002a	48 8b 51 68	 mov	 rdx, QWORD PTR [rcx+104]
  0002e	89 79 70	 mov	 DWORD PTR [rcx+112], edi
  00031	e8 00 00 00 00	 call	 gz_zero
  00036	83 f8 ff	 cmp	 eax, -1
  00039	75 03		 jne	 SHORT $LN5@gzclose_w

; 612  :             ret = state->err;

  0003b	8b 7b 74	 mov	 edi, DWORD PTR [rbx+116]
$LN5@gzclose_w:

; 613  :     }
; 614  : 
; 615  :     /* flush, free memory, and close file */
; 616  :     if (gz_comp(state, Z_FINISH) == -1)

  0003e	ba 04 00 00 00	 mov	 edx, 4
  00043	48 8b cb	 mov	 rcx, rbx
  00046	e8 00 00 00 00	 call	 gz_comp
  0004b	83 f8 ff	 cmp	 eax, -1
  0004e	75 03		 jne	 SHORT $LN6@gzclose_w

; 617  :         ret = state->err;

  00050	8b 7b 74	 mov	 edi, DWORD PTR [rbx+116]
$LN6@gzclose_w:

; 618  :     if (state->size) {

  00053	83 7b 28 00	 cmp	 DWORD PTR [rbx+40], 0
  00057	74 26		 je	 SHORT $LN7@gzclose_w

; 619  :         if (!state->direct) {

  00059	83 7b 40 00	 cmp	 DWORD PTR [rbx+64], 0
  0005d	75 16		 jne	 SHORT $LN8@gzclose_w

; 620  :             (void)deflateEnd(&(state->strm));

  0005f	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  00066	e8 00 00 00 00	 call	 deflateEnd

; 621  :             free(state->out);

  0006b	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN8@gzclose_w:

; 622  :         }
; 623  :         free(state->in);

  00075	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@gzclose_w:

; 624  :     }
; 625  :     gz_error(state, Z_OK, NULL);

  0007f	45 33 c0	 xor	 r8d, r8d
  00082	33 d2		 xor	 edx, edx
  00084	48 8b cb	 mov	 rcx, rbx
  00087	e8 00 00 00 00	 call	 gz_error

; 626  :     free(state->path);

  0008c	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 627  :     if (close(state->fd) == -1)

  00096	8b 4b 1c	 mov	 ecx, DWORD PTR [rbx+28]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  0009f	b9 ff ff ff ff	 mov	 ecx, -1
  000a4	3b c1		 cmp	 eax, ecx
  000a6	0f 44 f9	 cmove	 edi, ecx

; 628  :         ret = Z_ERRNO;
; 629  :     free(state);

  000a9	48 8b cb	 mov	 rcx, rbx
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 630  :     return ret;

  000b2	8b c7		 mov	 eax, edi

; 631  : }

  000b4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
$LN11@gzclose_w:
  000bf	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c4	b8 fe ff ff ff	 mov	 eax, -2
  000c9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cd	5f		 pop	 rdi
  000ce	c3		 ret	 0
gzclose_w ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gz_init
_TEXT	SEGMENT
state$ = 80
gz_init	PROC						; COMDAT

; 11   : local int gz_init(gz_statep state) {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 12   :     int ret;
; 13   :     z_streamp strm = &(state->strm);
; 14   : 
; 15   :     /* allocate input buffer (double size for gzprintf) */
; 16   :     state->in = (unsigned char *)malloc(state->want << 1);

  0000a	8b 41 2c	 mov	 eax, DWORD PTR [rcx+44]
  0000d	48 8d b1 80 00
	00 00		 lea	 rsi, QWORD PTR [rcx+128]
  00014	48 8b d9	 mov	 rbx, rcx
  00017	8d 0c 00	 lea	 ecx, DWORD PTR [rax+rax]
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00020	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax

; 17   :     if (state->in == NULL) {

  00024	48 85 c0	 test	 rax, rax
  00027	75 24		 jne	 SHORT $LN2@gz_init

; 18   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  00029	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@
  00030	ba fc ff ff ff	 mov	 edx, -4
  00035	48 8b cb	 mov	 rcx, rbx
  00038	e8 00 00 00 00	 call	 gz_error

; 19   :         return -1;

  0003d	b8 ff ff ff ff	 mov	 eax, -1

; 57   : }

  00042	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00047	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0004b	5e		 pop	 rsi
  0004c	c3		 ret	 0
$LN2@gz_init:

; 20   :     }
; 21   : 
; 22   :     /* only need output buffer and deflate state if compressing */
; 23   :     if (!state->direct) {

  0004d	83 7b 40 00	 cmp	 DWORD PTR [rbx+64], 0
  00051	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00056	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  0005b	0f 85 90 00 00
	00		 jne	 $LN8@gz_init

; 24   :         /* allocate output buffer */
; 25   :         state->out = (unsigned char *)malloc(state->want);

  00061	8b 4b 2c	 mov	 ecx, DWORD PTR [rbx+44]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0006a	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 26   :         if (state->out == NULL) {

  0006e	48 85 c0	 test	 rax, rax
  00071	74 56		 je	 SHORT $LN16@gz_init

; 27   :             free(state->in);
; 28   :             gz_error(state, Z_MEM_ERROR, "out of memory");
; 29   :             return -1;
; 30   :         }
; 31   : 
; 32   :         /* allocate deflate memory, set up for gzip compression */
; 33   :         strm->zalloc = Z_NULL;

  00073	33 ed		 xor	 ebp, ebp

; 34   :         strm->zfree = Z_NULL;
; 35   :         strm->opaque = Z_NULL;
; 36   :         ret = deflateInit2(strm, state->level, Z_DEFLATED,

  00075	c7 44 24 38 58
	00 00 00	 mov	 DWORD PTR [rsp+56], 88	; 00000058H
  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0P@CNPFHDLN@1?43?41?41?9motley@
  00084	48 89 6e 30	 mov	 QWORD PTR [rsi+48], rbp
  00088	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0008d	41 b9 1f 00 00
	00		 mov	 r9d, 31
  00093	48 89 6e 38	 mov	 QWORD PTR [rsi+56], rbp
  00097	41 b8 08 00 00
	00		 mov	 r8d, 8
  0009d	48 89 6e 40	 mov	 QWORD PTR [rsi+64], rbp
  000a1	48 8b ce	 mov	 rcx, rsi
  000a4	8b 43 5c	 mov	 eax, DWORD PTR [rbx+92]
  000a7	8b 53 58	 mov	 edx, DWORD PTR [rbx+88]
  000aa	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000ae	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  000b6	e8 00 00 00 00	 call	 deflateInit2_

; 37   :                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
; 38   :         if (ret != Z_OK) {

  000bb	85 c0		 test	 eax, eax
  000bd	74 2f		 je	 SHORT $LN5@gz_init

; 39   :             free(state->out);

  000bf	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN16@gz_init:

; 40   :             free(state->in);

  000c9	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 41   :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000d3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory@
  000da	ba fc ff ff ff	 mov	 edx, -4
  000df	48 8b cb	 mov	 rcx, rbx
  000e2	e8 00 00 00 00	 call	 gz_error

; 42   :             return -1;

  000e7	b8 ff ff ff ff	 mov	 eax, -1
  000ec	eb 20		 jmp	 SHORT $LN15@gz_init
$LN5@gz_init:

; 43   :         }
; 44   :         strm->next_in = NULL;

  000ee	48 89 2e	 mov	 QWORD PTR [rsi], rbp
$LN8@gz_init:

; 45   :     }
; 46   : 
; 47   :     /* mark state as initialized */
; 48   :     state->size = state->want;
; 49   : 
; 50   :     /* initialize write buffer if compressing */
; 51   :     if (!state->direct) {

  000f1	83 7b 40 00	 cmp	 DWORD PTR [rbx+64], 0
  000f5	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  000f8	89 43 28	 mov	 DWORD PTR [rbx+40], eax
  000fb	75 0f		 jne	 SHORT $LN6@gz_init

; 52   :         strm->avail_out = state->size;

  000fd	89 46 18	 mov	 DWORD PTR [rsi+24], eax

; 53   :         strm->next_out = state->out;

  00100	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00104	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax

; 54   :         state->x.next = strm->next_out;

  00108	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
$LN6@gz_init:

; 55   :     }
; 56   :     return 0;

  0010c	33 c0		 xor	 eax, eax
$LN15@gz_init:
  0010e	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00113	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 57   : }

  00118	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0011d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00121	5e		 pop	 rsi
  00122	c3		 ret	 0
gz_init	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gz_comp
_TEXT	SEGMENT
state$ = 64
flush$ = 72
gz_comp	PROC						; COMDAT

; 65   : local int gz_comp(gz_statep state, int flush) {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 57		 push	 r15
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 66   :     int ret, writ;
; 67   :     unsigned have, put, max = ((unsigned)-1 >> 2) + 1;
; 68   :     z_streamp strm = &(state->strm);
; 69   : 
; 70   :     /* allocate memory if this is the first time through */
; 71   :     if (state->size == 0 && gz_init(state) == -1)

  00009	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  0000d	48 8d 99 80 00
	00 00		 lea	 rbx, QWORD PTR [rcx+128]
  00014	44 8b fa	 mov	 r15d, edx
  00017	48 8b f9	 mov	 rdi, rcx
  0001a	75 13		 jne	 SHORT $LN41@gz_comp
  0001c	e8 00 00 00 00	 call	 gz_init
  00021	83 f8 ff	 cmp	 eax, -1
  00024	75 09		 jne	 SHORT $LN41@gz_comp

; 139  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	41 5f		 pop	 r15
  0002c	5f		 pop	 rdi
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
$LN41@gz_comp:

; 72   :         return -1;
; 73   : 
; 74   :     /* write directly if requested */
; 75   :     if (state->direct) {

  0002f	83 7f 40 00	 cmp	 DWORD PTR [rdi+64], 0
  00033	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00038	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14
  0003d	74 67		 je	 SHORT $LN10@gz_comp

; 76   :         while (strm->avail_in) {

  0003f	8b 4b 08	 mov	 ecx, DWORD PTR [rbx+8]
  00042	85 c9		 test	 ecx, ecx
  00044	74 6f		 je	 SHORT $LN45@gz_comp
  00046	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00049	be 00 00 00 40	 mov	 esi, 1073741824		; 40000000H
  0004e	66 90		 npad	 2
$LL2@gz_comp:

; 77   :             put = strm->avail_in > max ? max : strm->avail_in;

  00050	3b ce		 cmp	 ecx, esi
  00052	0f 47 ce	 cmova	 ecx, esi

; 78   :             writ = write(state->fd, strm->next_in, put);

  00055	44 8b c1	 mov	 r8d, ecx
  00058	8b 4f 1c	 mov	 ecx, DWORD PTR [rdi+28]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 79   :             if (writ < 0) {

  00061	85 c0		 test	 eax, eax
  00063	78 19		 js	 SHORT $LN29@gz_comp

; 82   :             }
; 83   :             strm->avail_in -= (unsigned)writ;

  00065	29 43 08	 sub	 DWORD PTR [rbx+8], eax
  00068	8b 4b 08	 mov	 ecx, DWORD PTR [rbx+8]

; 84   :             strm->next_in += writ;

  0006b	48 98		 cdqe
  0006d	48 01 03	 add	 QWORD PTR [rbx], rax
  00070	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00073	85 c9		 test	 ecx, ecx
  00075	75 d9		 jne	 SHORT $LL2@gz_comp

; 93   :             return 0;

  00077	33 c0		 xor	 eax, eax
  00079	e9 38 01 00 00	 jmp	 $LN62@gz_comp
$LN29@gz_comp:

; 80   :                 gz_error(state, Z_ERRNO, zstrerror());

  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00084	8b 08		 mov	 ecx, DWORD PTR [rax]
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  0008c	ba ff ff ff ff	 mov	 edx, -1
  00091	48 8b cf	 mov	 rcx, rdi
  00094	4c 8b c0	 mov	 r8, rax
  00097	e8 00 00 00 00	 call	 gz_error

; 81   :                 return -1;

  0009c	b8 ff ff ff ff	 mov	 eax, -1
  000a1	e9 10 01 00 00	 jmp	 $LN62@gz_comp
$LN10@gz_comp:

; 85   :         }
; 86   :         return 0;
; 87   :     }
; 88   : 
; 89   :     /* check for a pending reset */
; 90   :     if (state->reset) {

  000a6	45 33 f6	 xor	 r14d, r14d
  000a9	44 39 77 60	 cmp	 DWORD PTR [rdi+96], r14d
  000ad	74 19		 je	 SHORT $LN12@gz_comp

; 91   :         /* don't start a new gzip member unless there is data to write */
; 92   :         if (strm->avail_in == 0)

  000af	44 39 73 08	 cmp	 DWORD PTR [rbx+8], r14d
  000b3	75 07		 jne	 SHORT $LN13@gz_comp
$LN45@gz_comp:

; 93   :             return 0;

  000b5	33 c0		 xor	 eax, eax
  000b7	e9 fa 00 00 00	 jmp	 $LN62@gz_comp
$LN13@gz_comp:

; 94   :         deflateReset(strm);

  000bc	48 8b cb	 mov	 rcx, rbx
  000bf	e8 00 00 00 00	 call	 deflateReset

; 95   :         state->reset = 0;

  000c4	44 89 77 60	 mov	 DWORD PTR [rdi+96], r14d
$LN12@gz_comp:

; 96   :     }
; 97   : 
; 98   :     /* run deflate() on provided input until it produces no more output */
; 99   :     ret = Z_OK;

  000c8	be 00 00 00 40	 mov	 esi, 1073741824		; 40000000H
  000cd	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
$LL6@gz_comp:

; 100  :     do {
; 101  :         /* write out current buffer contents if full, or if flushing, but if
; 102  :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 103  :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&

  000d2	83 7b 18 00	 cmp	 DWORD PTR [rbx+24], 0
  000d6	74 11		 je	 SHORT $LN28@gz_comp
  000d8	45 85 ff	 test	 r15d, r15d
  000db	74 73		 je	 SHORT $LN18@gz_comp
  000dd	41 83 ff 04	 cmp	 r15d, 4
  000e1	75 06		 jne	 SHORT $LN28@gz_comp
  000e3	41 83 fe 01	 cmp	 r14d, 1
  000e7	75 67		 jne	 SHORT $LN18@gz_comp
$LN28@gz_comp:

; 104  :             (flush != Z_FINISH || ret == Z_STREAM_END))) {
; 105  :             while (strm->next_out > state->x.next) {

  000e9	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000ed	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  000f1	48 3b c2	 cmp	 rax, rdx
  000f4	76 3e		 jbe	 SHORT $LN8@gz_comp
  000f6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@gz_comp:

; 106  :                 put = strm->next_out - state->x.next > (int)max ? max :

  00100	48 8b c8	 mov	 rcx, rax
  00103	48 2b ca	 sub	 rcx, rdx
  00106	48 3b ce	 cmp	 rcx, rsi
  00109	7e 04		 jle	 SHORT $LN24@gz_comp
  0010b	8b c6		 mov	 eax, esi
  0010d	eb 02		 jmp	 SHORT $LN25@gz_comp
$LN24@gz_comp:
  0010f	2b c2		 sub	 eax, edx
$LN25@gz_comp:

; 107  :                       (unsigned)(strm->next_out - state->x.next);
; 108  :                 writ = write(state->fd, state->x.next, put);

  00111	8b 4f 1c	 mov	 ecx, DWORD PTR [rdi+28]
  00114	44 8b c0	 mov	 r8d, eax
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 109  :                 if (writ < 0) {

  0011d	85 c0		 test	 eax, eax
  0011f	78 5f		 js	 SHORT $LN30@gz_comp

; 112  :                 }
; 113  :                 state->x.next += writ;

  00121	48 98		 cdqe
  00123	48 01 47 08	 add	 QWORD PTR [rdi+8], rax
  00127	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  0012b	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0012f	48 3b c2	 cmp	 rax, rdx
  00132	77 cc		 ja	 SHORT $LL7@gz_comp
$LN8@gz_comp:

; 114  :             }
; 115  :             if (strm->avail_out == 0) {

  00134	83 7b 18 00	 cmp	 DWORD PTR [rbx+24], 0
  00138	75 16		 jne	 SHORT $LN18@gz_comp

; 116  :                 strm->avail_out = state->size;

  0013a	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  0013d	89 43 18	 mov	 DWORD PTR [rbx+24], eax

; 117  :                 strm->next_out = state->out;

  00140	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00144	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 118  :                 state->x.next = state->out;

  00148	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  0014c	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
$LN18@gz_comp:

; 119  :             }
; 120  :         }
; 121  : 
; 122  :         /* compress */
; 123  :         have = strm->avail_out;

  00150	8b 6b 18	 mov	 ebp, DWORD PTR [rbx+24]

; 124  :         ret = deflate(strm, flush);

  00153	41 8b d7	 mov	 edx, r15d
  00156	48 8b cb	 mov	 rcx, rbx
  00159	e8 00 00 00 00	 call	 deflate
  0015e	44 8b f0	 mov	 r14d, eax

; 125  :         if (ret == Z_STREAM_ERROR) {

  00161	83 f8 fe	 cmp	 eax, -2
  00164	74 32		 je	 SHORT $LN32@gz_comp

; 129  :         }
; 130  :         have -= strm->avail_out;

  00166	3b 6b 18	 cmp	 ebp, DWORD PTR [rbx+24]

; 131  :     } while (have);

  00169	0f 85 63 ff ff
	ff		 jne	 $LL6@gz_comp

; 132  : 
; 133  :     /* if that completed a deflate stream, allow another to start */
; 134  :     if (flush == Z_FINISH)

  0016f	41 83 ff 04	 cmp	 r15d, 4
  00173	75 07		 jne	 SHORT $LN20@gz_comp

; 135  :         state->reset = 1;

  00175	c7 47 60 01 00
	00 00		 mov	 DWORD PTR [rdi+96], 1
$LN20@gz_comp:

; 136  : 
; 137  :     /* all done, no errors */
; 138  :     return 0;

  0017c	33 c0		 xor	 eax, eax
  0017e	eb 31		 jmp	 SHORT $LN63@gz_comp
$LN30@gz_comp:

; 110  :                     gz_error(state, Z_ERRNO, zstrerror());

  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00186	8b 08		 mov	 ecx, DWORD PTR [rax]
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  0018e	4c 8b c0	 mov	 r8, rax
  00191	ba ff ff ff ff	 mov	 edx, -1

; 111  :                     return -1;

  00196	eb 0c		 jmp	 SHORT $LN64@gz_comp
$LN32@gz_comp:

; 126  :             gz_error(state, Z_STREAM_ERROR,

  00198	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5@
  0019f	ba fe ff ff ff	 mov	 edx, -2
$LN64@gz_comp:
  001a4	48 8b cf	 mov	 rcx, rdi
  001a7	e8 00 00 00 00	 call	 gz_error

; 127  :                       "internal error: deflate stream corrupt");
; 128  :             return -1;

  001ac	b8 ff ff ff ff	 mov	 eax, -1
$LN63@gz_comp:
  001b1	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
$LN62@gz_comp:
  001b6	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001bb	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]

; 139  : }

  001c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c4	41 5f		 pop	 r15
  001c6	5f		 pop	 rdi
  001c7	5b		 pop	 rbx
  001c8	c3		 ret	 0
gz_comp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gz_zero
_TEXT	SEGMENT
state$ = 48
len$ = 56
gz_zero	PROC						; COMDAT

; 143  : local int gz_zero(gz_statep state, z_off64_t len) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 144  :     int first;
; 145  :     unsigned n;
; 146  :     z_streamp strm = &(state->strm);
; 147  : 
; 148  :     /* consume whatever's left in the input buffer */
; 149  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00014	83 b9 88 00 00
	00 00		 cmp	 DWORD PTR [rcx+136], 0
  0001b	48 8b fa	 mov	 rdi, rdx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	74 0c		 je	 SHORT $LN4@gz_zero
  00023	33 d2		 xor	 edx, edx
  00025	e8 00 00 00 00	 call	 gz_comp
  0002a	83 f8 ff	 cmp	 eax, -1
  0002d	74 70		 je	 SHORT $LN11@gz_zero
$LN4@gz_zero:

; 150  :         return -1;
; 151  : 
; 152  :     /* compress len zeros (len guaranteed > 0) */
; 153  :     first = 1;

  0002f	bd 01 00 00 00	 mov	 ebp, 1

; 154  :     while (len) {

  00034	48 85 ff	 test	 rdi, rdi
  00037	74 4f		 je	 SHORT $LN3@gz_zero
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@gz_zero:

; 155  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?

  00040	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]

; 156  :             (unsigned)len : state->size;
; 157  :         if (first) {

  00043	48 3b c7	 cmp	 rax, rdi
  00046	0f 4f c7	 cmovg	 eax, edi
  00049	8b f0		 mov	 esi, eax
  0004b	85 ed		 test	 ebp, ebp
  0004d	74 10		 je	 SHORT $LN13@gz_zero

; 158  :             memset(state->in, 0, n);

  0004f	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00053	44 8b c6	 mov	 r8d, esi
  00056	33 d2		 xor	 edx, edx
  00058	e8 00 00 00 00	 call	 memset

; 159  :             first = 0;

  0005d	33 ed		 xor	 ebp, ebp
$LN13@gz_zero:

; 160  :         }
; 161  :         strm->avail_in = n;

  0005f	89 b3 88 00 00
	00		 mov	 DWORD PTR [rbx+136], esi

; 162  :         strm->next_in = state->in;
; 163  :         state->x.pos += n;
; 164  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00065	33 d2		 xor	 edx, edx
  00067	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax
  00075	48 01 73 10	 add	 QWORD PTR [rbx+16], rsi
  00079	e8 00 00 00 00	 call	 gz_comp
  0007e	83 f8 ff	 cmp	 eax, -1
  00081	74 1c		 je	 SHORT $LN11@gz_zero

; 166  :         len -= n;

  00083	48 2b fe	 sub	 rdi, rsi
  00086	75 b8		 jne	 SHORT $LL2@gz_zero
$LN3@gz_zero:

; 167  :     }
; 168  :     return 0;

  00088	33 c0		 xor	 eax, eax
$LN1@gz_zero:

; 169  : }

  0008a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008f	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00094	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00099	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009d	5f		 pop	 rdi
  0009e	c3		 ret	 0
$LN11@gz_zero:

; 165  :             return -1;

  0009f	b8 ff ff ff ff	 mov	 eax, -1
  000a4	eb e4		 jmp	 SHORT $LN1@gz_zero
gz_zero	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gz_write
_TEXT	SEGMENT
state$ = 64
buf$ = 72
len$ = 80
gz_write PROC						; COMDAT

; 173  : local z_size_t gz_write(gz_statep state, voidpc buf, z_size_t len) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	49 8b e8	 mov	 rbp, r8
  0001b	4c 8b f2	 mov	 r14, rdx
  0001e	48 8b d9	 mov	 rbx, rcx

; 174  :     z_size_t put = len;

  00021	4d 8b f8	 mov	 r15, r8

; 175  : 
; 176  :     /* if len is zero, avoid unnecessary operations */
; 177  :     if (len == 0)

  00024	4d 85 c0	 test	 r8, r8
  00027	0f 84 a0 00 00
	00		 je	 $LN25@gz_write

; 178  :         return 0;
; 179  : 
; 180  :     /* allocate memory if this is the first time through */
; 181  :     if (state->size == 0 && gz_init(state) == -1)

  0002d	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  00031	75 0e		 jne	 SHORT $LN35@gz_write
  00033	e8 00 00 00 00	 call	 gz_init
  00038	83 f8 ff	 cmp	 eax, -1
  0003b	0f 84 8c 00 00
	00		 je	 $LN25@gz_write
$LN35@gz_write:

; 182  :         return 0;
; 183  : 
; 184  :     /* check for seek request */
; 185  :     if (state->seek) {

  00041	83 7b 70 00	 cmp	 DWORD PTR [rbx+112], 0
  00045	74 18		 je	 SHORT $LN11@gz_write

; 186  :         state->seek = 0;
; 187  :         if (gz_zero(state, state->skip) == -1)

  00047	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  0004b	48 8b cb	 mov	 rcx, rbx
  0004e	c7 43 70 00 00
	00 00		 mov	 DWORD PTR [rbx+112], 0
  00055	e8 00 00 00 00	 call	 gz_zero
  0005a	83 f8 ff	 cmp	 eax, -1
  0005d	74 6e		 je	 SHORT $LN25@gz_write
$LN11@gz_write:

; 188  :             return 0;
; 189  :     }
; 190  : 
; 191  :     /* for small len, copy to input buffer, otherwise compress directly */
; 192  :     if (len < state->size) {

  0005f	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00062	48 3b e8	 cmp	 rbp, rax
  00065	0f 83 7d 00 00
	00		 jae	 $LN12@gz_write
  0006b	0f 1f 44 00 00	 npad	 5
$LL4@gz_write:

; 193  :         /* copy to input buffer, compress when full */
; 194  :         do {
; 195  :             unsigned have, copy;
; 196  : 
; 197  :             if (state->strm.avail_in == 0)

  00070	8b 8b 88 00 00
	00		 mov	 ecx, DWORD PTR [rbx+136]
  00076	85 c9		 test	 ecx, ecx
  00078	75 0b		 jne	 SHORT $LN32@gz_write

; 198  :                 state->strm.next_in = state->in;

  0007a	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0007e	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax
$LN32@gz_write:

; 199  :             have = (unsigned)((state->strm.next_in + state->strm.avail_in) -
; 200  :                               state->in);
; 201  :             copy = state->size - have;

  00085	8b 73 28	 mov	 esi, DWORD PTR [rbx+40]

; 202  :             if (copy > len)
; 203  :                 copy = (unsigned)len;
; 204  :             memcpy(state->in + have, buf, copy);

  00088	49 8b d6	 mov	 rdx, r14
  0008b	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [rbx+128]
  00091	2b 43 30	 sub	 eax, DWORD PTR [rbx+48]
  00094	03 c8		 add	 ecx, eax
  00096	2b f1		 sub	 esi, ecx
  00098	48 3b f5	 cmp	 rsi, rbp
  0009b	0f 47 f5	 cmova	 esi, ebp
  0009e	48 03 4b 30	 add	 rcx, QWORD PTR [rbx+48]
  000a2	44 8b c6	 mov	 r8d, esi
  000a5	8b fe		 mov	 edi, esi
  000a7	e8 00 00 00 00	 call	 memcpy

; 205  :             state->strm.avail_in += copy;

  000ac	01 b3 88 00 00
	00		 add	 DWORD PTR [rbx+136], esi

; 206  :             state->x.pos += copy;
; 207  :             buf = (const char *)buf + copy;

  000b2	4c 03 f7	 add	 r14, rdi
  000b5	48 01 7b 10	 add	 QWORD PTR [rbx+16], rdi

; 208  :             len -= copy;

  000b9	48 2b ef	 sub	 rbp, rdi

; 209  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  000bc	74 7a		 je	 SHORT $LN6@gz_write
  000be	33 d2		 xor	 edx, edx
  000c0	48 8b cb	 mov	 rcx, rbx
  000c3	e8 00 00 00 00	 call	 gz_comp
  000c8	83 f8 ff	 cmp	 eax, -1
  000cb	75 a3		 jne	 SHORT $LL4@gz_write
$LN25@gz_write:

; 227  :                 return 0;

  000cd	33 c0		 xor	 eax, eax
$LN1@gz_write:

; 234  : }

  000cf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d4	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000d9	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000de	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e2	41 5f		 pop	 r15
  000e4	41 5e		 pop	 r14
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
$LN12@gz_write:

; 210  :                 return 0;
; 211  :         } while (len);
; 212  :     }
; 213  :     else {
; 214  :         /* consume whatever's left in the input buffer */
; 215  :         if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  000e8	83 bb 88 00 00
	00 00		 cmp	 DWORD PTR [rbx+136], 0
  000ef	74 0f		 je	 SHORT $LN17@gz_write
  000f1	33 d2		 xor	 edx, edx
  000f3	48 8b cb	 mov	 rcx, rbx
  000f6	e8 00 00 00 00	 call	 gz_comp
  000fb	83 f8 ff	 cmp	 eax, -1
  000fe	74 cd		 je	 SHORT $LN25@gz_write
$LN17@gz_write:

; 216  :             return 0;
; 217  : 
; 218  :         /* directly compress user buffer to file */
; 219  :         state->strm.next_in = (z_const Bytef *)buf;

  00100	4c 89 b3 80 00
	00 00		 mov	 QWORD PTR [rbx+128], r14
  00107	be ff ff ff ff	 mov	 esi, -1			; ffffffffH
  0010c	0f 1f 40 00	 npad	 4
$LL7@gz_write:

; 220  :         do {
; 221  :             unsigned n = (unsigned)-1;
; 222  :             if (n > len)

  00110	8b ce		 mov	 ecx, esi
  00112	48 3b ee	 cmp	 rbp, rsi
  00115	0f 42 cd	 cmovb	 ecx, ebp

; 223  :                 n = (unsigned)len;
; 224  :             state->strm.avail_in = n;
; 225  :             state->x.pos += n;
; 226  :             if (gz_comp(state, Z_NO_FLUSH) == -1)

  00118	33 d2		 xor	 edx, edx
  0011a	8b f9		 mov	 edi, ecx
  0011c	48 01 7b 10	 add	 QWORD PTR [rbx+16], rdi
  00120	89 8b 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ecx
  00126	48 8b cb	 mov	 rcx, rbx
  00129	e8 00 00 00 00	 call	 gz_comp
  0012e	83 f8 ff	 cmp	 eax, -1
  00131	74 9a		 je	 SHORT $LN25@gz_write

; 228  :             len -= n;

  00133	48 2b ef	 sub	 rbp, rdi

; 229  :         } while (len);

  00136	75 d8		 jne	 SHORT $LL7@gz_write
$LN6@gz_write:

; 230  :     }
; 231  : 
; 232  :     /* input was all buffered or compressed */
; 233  :     return put;

  00138	49 8b c7	 mov	 rax, r15
  0013b	eb 92		 jmp	 SHORT $LN1@gz_write
gz_write ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gzwrite
_TEXT	SEGMENT
file$ = 48
buf$ = 56
len$ = 64
gzwrite	PROC						; COMDAT

; 237  : int ZEXPORT gzwrite(gzFile file, voidpc buf, unsigned len) {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 238  :     gz_statep state;
; 239  : 
; 240  :     /* get internal structure */
; 241  :     if (file == NULL)

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 25		 je	 SHORT $LN4@gzwrite

; 242  :         return 0;
; 243  :     state = (gz_statep)file;
; 244  : 
; 245  :     /* check that we're writing and that there's no error */
; 246  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00009	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00010	75 1c		 jne	 SHORT $LN4@gzwrite
  00012	83 79 74 00	 cmp	 DWORD PTR [rcx+116], 0
  00016	75 16		 jne	 SHORT $LN4@gzwrite

; 247  :         return 0;
; 248  : 
; 249  :     /* since an int is returned, make sure len fits in one, otherwise return
; 250  :        with an error (this avoids a flaw in the interface) */
; 251  :     if ((int)len < 0) {

  00018	45 85 c0	 test	 r8d, r8d
  0001b	79 18		 jns	 SHORT $LN5@gzwrite

; 252  :         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");

  0001d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5i@
  00024	ba fd ff ff ff	 mov	 edx, -3
  00029	e8 00 00 00 00	 call	 gz_error
$LN4@gzwrite:

; 258  : }

  0002e	33 c0		 xor	 eax, eax
  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
$LN5@gzwrite:

; 253  :         return 0;
; 254  :     }
; 255  : 
; 256  :     /* write len bytes from buf (the return value will fit in an int) */
; 257  :     return (int)gz_write(state, buf, len);

  00035	45 8b c0	 mov	 r8d, r8d

; 258  : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 253  :         return 0;
; 254  :     }
; 255  : 
; 256  :     /* write len bytes from buf (the return value will fit in an int) */
; 257  :     return (int)gz_write(state, buf, len);

  0003c	e9 00 00 00 00	 jmp	 gz_write
gzwrite	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gzfwrite
_TEXT	SEGMENT
buf$ = 48
size$ = 56
nitems$ = 64
file$ = 72
gzfwrite PROC						; COMDAT

; 262  :                           gzFile file) {

$LN17:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4d 8b d0	 mov	 r10, r8
  00009	48 8b da	 mov	 rbx, rdx

; 263  :     z_size_t len;
; 264  :     gz_statep state;
; 265  : 
; 266  :     /* get internal structure */
; 267  :     if (file == NULL)

  0000c	4d 85 c9	 test	 r9, r9
  0000f	74 3e		 je	 SHORT $LN4@gzfwrite

; 268  :         return 0;
; 269  :     state = (gz_statep)file;
; 270  : 
; 271  :     /* check that we're writing and that there's no error */
; 272  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00011	41 81 79 18 b1
	79 00 00	 cmp	 DWORD PTR [r9+24], 31153 ; 000079b1H
  00019	75 34		 jne	 SHORT $LN4@gzfwrite
  0001b	41 83 79 74 00	 cmp	 DWORD PTR [r9+116], 0
  00020	75 2d		 jne	 SHORT $LN4@gzfwrite

; 273  :         return 0;
; 274  : 
; 275  :     /* compute bytes to read -- error on overflow */
; 276  :     len = nitems * size;

  00022	4c 8b c2	 mov	 r8, rdx
  00025	4d 0f af c2	 imul	 r8, r10

; 277  :     if (size && len / size != nitems) {

  00029	48 85 d2	 test	 rdx, rdx
  0002c	74 29		 je	 SHORT $LN5@gzfwrite
  0002e	33 d2		 xor	 edx, edx
  00030	49 8b c0	 mov	 rax, r8
  00033	48 f7 f3	 div	 rbx
  00036	49 3b c2	 cmp	 rax, r10
  00039	74 1c		 je	 SHORT $LN5@gzfwrite

; 278  :         gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");

  0003b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CB@EGGJDMIK@request?5does?5not?5fit?5in?5a?5size_@
  00042	ba fe ff ff ff	 mov	 edx, -2
  00047	49 8b c9	 mov	 rcx, r9
  0004a	e8 00 00 00 00	 call	 gz_error
$LN4@gzfwrite:

; 284  : }

  0004f	33 c0		 xor	 eax, eax
  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
$LN5@gzfwrite:

; 279  :         return 0;
; 280  :     }
; 281  : 
; 282  :     /* write len bytes to buf, return the number of full items written */
; 283  :     return len ? gz_write(state, buf, len) / size : 0;

  00057	4d 85 c0	 test	 r8, r8
  0005a	74 f3		 je	 SHORT $LN4@gzfwrite
  0005c	48 8b d1	 mov	 rdx, rcx
  0005f	49 8b c9	 mov	 rcx, r9
  00062	e8 00 00 00 00	 call	 gz_write
  00067	33 d2		 xor	 edx, edx
  00069	48 f7 f3	 div	 rbx

; 284  : }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5b		 pop	 rbx
  00071	c3		 ret	 0
gzfwrite ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gzputc
_TEXT	SEGMENT
file$ = 48
buf$ = 48
c$ = 56
gzputc	PROC						; COMDAT

; 287  : int ZEXPORT gzputc(gzFile file, int c) {

$LN27:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 288  :     unsigned have;
; 289  :     unsigned char buf[1];
; 290  :     gz_statep state;
; 291  :     z_streamp strm;
; 292  : 
; 293  :     /* get internal structure */
; 294  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	0f 84 a4 00 00
	00		 je	 $LN4@gzputc

; 295  :         return -1;
; 296  :     state = (gz_statep)file;
; 297  :     strm = &(state->strm);
; 298  : 
; 299  :     /* check that we're writing and that there's no error */
; 300  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00018	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  0001f	0f 85 97 00 00
	00		 jne	 $LN4@gzputc
  00025	83 79 74 00	 cmp	 DWORD PTR [rcx+116], 0
  00029	0f 85 8d 00 00
	00		 jne	 $LN4@gzputc

; 302  : 
; 303  :     /* check for seek request */
; 304  :     if (state->seek) {

  0002f	83 79 70 00	 cmp	 DWORD PTR [rcx+112], 0
  00033	74 15		 je	 SHORT $LN6@gzputc

; 305  :         state->seek = 0;
; 306  :         if (gz_zero(state, state->skip) == -1)

  00035	48 8b 51 68	 mov	 rdx, QWORD PTR [rcx+104]
  00039	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [rcx+112], 0
  00040	e8 00 00 00 00	 call	 gz_zero
  00045	83 f8 ff	 cmp	 eax, -1
  00048	74 72		 je	 SHORT $LN4@gzputc
$LN6@gzputc:

; 307  :             return -1;
; 308  :     }
; 309  : 
; 310  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 311  :        initialized) */
; 312  :     if (state->size) {

  0004a	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0004d	85 c9		 test	 ecx, ecx
  0004f	74 49		 je	 SHORT $LN9@gzputc

; 313  :         if (strm->avail_in == 0)

  00051	8b 93 88 00 00
	00		 mov	 edx, DWORD PTR [rbx+136]
  00057	85 d2		 test	 edx, edx
  00059	75 0b		 jne	 SHORT $LN14@gzputc

; 314  :             strm->next_in = state->in;

  0005b	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0005f	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax
$LN14@gzputc:

; 315  :         have = (unsigned)((strm->next_in + strm->avail_in) - state->in);

  00066	44 8b 83 80 00
	00 00		 mov	 r8d, DWORD PTR [rbx+128]
  0006d	44 2b 43 30	 sub	 r8d, DWORD PTR [rbx+48]
  00071	44 03 c2	 add	 r8d, edx

; 316  :         if (have < state->size) {

  00074	44 3b c1	 cmp	 r8d, ecx
  00077	73 21		 jae	 SHORT $LN9@gzputc

; 317  :             state->in[have] = (unsigned char)c;

  00079	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0007d	41 88 3c 00	 mov	 BYTE PTR [r8+rax], dil

; 318  :             strm->avail_in++;

  00081	ff 83 88 00 00
	00		 inc	 DWORD PTR [rbx+136]

; 319  :             state->x.pos++;

  00087	48 ff 43 10	 inc	 QWORD PTR [rbx+16]

; 320  :             return c & 0xff;

  0008b	40 0f b6 c7	 movzx	 eax, dil

; 329  : }

  0008f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00094	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00098	5f		 pop	 rdi
  00099	c3		 ret	 0
$LN9@gzputc:

; 321  :         }
; 322  :     }
; 323  : 
; 324  :     /* no room in buffer or not initialized, use gz_write() */
; 325  :     buf[0] = (unsigned char)c;
; 326  :     if (gz_write(state, buf, 1) != 1)

  0009a	41 b8 01 00 00
	00		 mov	 r8d, 1
  000a0	40 88 7c 24 30	 mov	 BYTE PTR buf$[rsp], dil
  000a5	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  000aa	48 8b cb	 mov	 rcx, rbx
  000ad	e8 00 00 00 00	 call	 gz_write
  000b2	48 83 f8 01	 cmp	 rax, 1

; 327  :         return -1;
; 328  :     return c & 0xff;

  000b6	40 0f b6 c7	 movzx	 eax, dil
  000ba	74 05		 je	 SHORT $LN1@gzputc
$LN4@gzputc:

; 301  :         return -1;

  000bc	b8 ff ff ff ff	 mov	 eax, -1
$LN1@gzputc:

; 329  : }

  000c1	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000c6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ca	5f		 pop	 rdi
  000cb	c3		 ret	 0
gzputc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gzputs
_TEXT	SEGMENT
file$ = 48
s$ = 56
gzputs	PROC						; COMDAT

; 332  : int ZEXPORT gzputs(gzFile file, const char *s) {

$LN18:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 333  :     z_size_t len, put;
; 334  :     gz_statep state;
; 335  : 
; 336  :     /* get internal structure */
; 337  :     if (file == NULL)

  00006	48 85 c9	 test	 rcx, rcx
  00009	74 72		 je	 SHORT $LN4@gzputs

; 338  :         return -1;
; 339  :     state = (gz_statep)file;
; 340  : 
; 341  :     /* check that we're writing and that there's no error */
; 342  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0000b	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00012	75 69		 jne	 SHORT $LN4@gzputs
  00014	83 79 74 00	 cmp	 DWORD PTR [rcx+116], 0
  00018	75 63		 jne	 SHORT $LN4@gzputs

; 344  : 
; 345  :     /* write string */
; 346  :     len = strlen(s);

  0001a	48 c7 c7 ff ff
	ff ff		 mov	 rdi, -1
  00021	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00026	48 8b df	 mov	 rbx, rdi
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@gzputs:
  00030	48 ff c3	 inc	 rbx
  00033	80 3c 1a 00	 cmp	 BYTE PTR [rdx+rbx], 0
  00037	75 f7		 jne	 SHORT $LL9@gzputs

; 347  :     if ((int)len < 0 || (unsigned)len != len) {

  00039	85 db		 test	 ebx, ebx
  0003b	78 22		 js	 SHORT $LN6@gzputs
  0003d	8b c3		 mov	 eax, ebx
  0003f	48 3b c3	 cmp	 rax, rbx
  00042	75 1b		 jne	 SHORT $LN6@gzputs

; 350  :     }
; 351  :     put = gz_write(state, s, len);

  00044	4c 8b c3	 mov	 r8, rbx
  00047	e8 00 00 00 00	 call	 gz_write

; 352  :     return put < len ? -1 : (int)len;

  0004c	48 3b c3	 cmp	 rax, rbx
  0004f	0f 42 df	 cmovb	 ebx, edi
  00052	8b c3		 mov	 eax, ebx
  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 353  : }

  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
$LN6@gzputs:

; 348  :         gz_error(state, Z_STREAM_ERROR, "string length does not fit in int");

  0005f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CC@ENDIFONJ@string?5length?5does?5not?5fit?5in?5i@
  00066	ba fe ff ff ff	 mov	 edx, -2
  0006b	e8 00 00 00 00	 call	 gz_error
  00070	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 349  :         return -1;

  00075	8b c7		 mov	 eax, edi

; 353  : }

  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
$LN4@gzputs:

; 343  :         return -1;

  0007d	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1

; 353  : }

  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
gzputs	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gzvprintf
_TEXT	SEGMENT
file$ = 64
format$ = 72
va$ = 80
gzvprintf PROC						; COMDAT

; 359  : int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va) {

$LN40:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 56		 push	 r14
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00010	49 8b f0	 mov	 rsi, r8
  00013	4c 8b f2	 mov	 r14, rdx
  00016	48 8b f9	 mov	 rdi, rcx

; 360  :     int len;
; 361  :     unsigned left;
; 362  :     char *next;
; 363  :     gz_statep state;
; 364  :     z_streamp strm;
; 365  : 
; 366  :     /* get internal structure */
; 367  :     if (file == NULL)

  00019	48 85 c9	 test	 rcx, rcx
  0001c	0f 84 54 01 00
	00		 je	 $LN4@gzvprintf

; 368  :         return Z_STREAM_ERROR;
; 369  :     state = (gz_statep)file;
; 370  :     strm = &(state->strm);
; 371  : 
; 372  :     /* check that we're writing and that there's no error */
; 373  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00022	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00029	0f 85 47 01 00
	00		 jne	 $LN4@gzvprintf
  0002f	83 79 74 00	 cmp	 DWORD PTR [rcx+116], 0
  00033	0f 85 3d 01 00
	00		 jne	 $LN4@gzvprintf

; 374  :         return Z_STREAM_ERROR;
; 375  : 
; 376  :     /* make sure we have some buffer space */
; 377  :     if (state->size == 0 && gz_init(state) == -1)

  00039	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  0003d	75 1e		 jne	 SHORT $LN20@gzvprintf
  0003f	e8 00 00 00 00	 call	 gz_init
  00044	83 f8 ff	 cmp	 eax, -1
  00047	75 14		 jne	 SHORT $LN20@gzvprintf
$LN38@gzvprintf:

; 428  : }

  00049	8b 47 74	 mov	 eax, DWORD PTR [rdi+116]
  0004c	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00051	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	41 5e		 pop	 r14
  0005c	c3		 ret	 0
$LN20@gzvprintf:

; 378  :         return state->err;
; 379  : 
; 380  :     /* check for seek request */
; 381  :     if (state->seek) {

  0005d	83 7f 70 00	 cmp	 DWORD PTR [rdi+112], 0
  00061	74 18		 je	 SHORT $LN7@gzvprintf

; 382  :         state->seek = 0;
; 383  :         if (gz_zero(state, state->skip) == -1)

  00063	48 8b 57 68	 mov	 rdx, QWORD PTR [rdi+104]
  00067	48 8b cf	 mov	 rcx, rdi
  0006a	c7 47 70 00 00
	00 00		 mov	 DWORD PTR [rdi+112], 0
  00071	e8 00 00 00 00	 call	 gz_zero
  00076	83 f8 ff	 cmp	 eax, -1
  00079	74 ce		 je	 SHORT $LN38@gzvprintf
$LN7@gzvprintf:

; 384  :             return state->err;
; 385  :     }
; 386  : 
; 387  :     /* do the printf() into the input buffer, put length in len -- the input
; 388  :        buffer is double-sized just for this function, so there is guaranteed to
; 389  :        be state->size bytes available after the current contents */
; 390  :     if (strm->avail_in == 0)

  0007b	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [rdi+136]
  00081	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00086	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0008b	85 c9		 test	 ecx, ecx
  0008d	75 0b		 jne	 SHORT $LN21@gzvprintf

; 391  :         strm->next_in = state->in;

  0008f	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00093	48 89 87 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rax
$LN21@gzvprintf:

; 392  :     next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);
; 393  :     next[state->size - 1] = 0;

  0009a	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  0009d	48 8b e9	 mov	 rbp, rcx
  000a0	48 03 af 80 00
	00 00		 add	 rbp, QWORD PTR [rdi+128]
  000a7	ff c8		 dec	 eax
  000a9	c6 04 28 00	 mov	 BYTE PTR [rax+rbp], 0

; 394  : #ifdef NO_vsnprintf
; 395  : #  ifdef HAS_vsprintf_void
; 396  :     (void)vsprintf(next, format, va);
; 397  :     for (len = 0; len < state->size; len++)
; 398  :         if (next[len] == 0) break;
; 399  : #  else
; 400  :     len = vsprintf(next, format, va);
; 401  : #  endif
; 402  : #else
; 403  : #  ifdef HAS_vsnprintf_void
; 404  :     (void)vsnprintf(next, state->size, format, va);
; 405  :     len = strlen(next);
; 406  : #  else
; 407  :     len = vsnprintf(next, state->size, format, va);

  000ad	8b 5f 28	 mov	 ebx, DWORD PTR [rdi+40]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h

; 1439 :         int const _Result = __stdio_common_vsprintf(

  000b0	e8 00 00 00 00	 call	 __local_stdio_printf_options
  000b5	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  000ba	4d 8b ce	 mov	 r9, r14
  000bd	44 8b c3	 mov	 r8d, ebx
  000c0	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000c9	48 8b d5	 mov	 rdx, rbp
  000cc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000cf	48 83 c9 02	 or	 rcx, 2
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  000d9	8b f0		 mov	 esi, eax

; 1440 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1441 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1442 : 
; 1443 :         return _Result < 0 ? -1 : _Result;

  000db	b8 ff ff ff ff	 mov	 eax, -1
  000e0	85 f6		 test	 esi, esi
  000e2	0f 48 f0	 cmovs	 esi, eax
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c

; 412  :     if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)

  000e5	85 f6		 test	 esi, esi
  000e7	0f 84 85 00 00
	00		 je	 $LN10@gzvprintf
  000ed	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  000f0	3b f0		 cmp	 esi, eax
  000f2	73 7e		 jae	 SHORT $LN10@gzvprintf
  000f4	ff c8		 dec	 eax
  000f6	80 3c 28 00	 cmp	 BYTE PTR [rax+rbp], 0
  000fa	75 76		 jne	 SHORT $LN10@gzvprintf

; 414  : 
; 415  :     /* update buffer and position, compress first half if past that */
; 416  :     strm->avail_in += (unsigned)len;

  000fc	01 b7 88 00 00
	00		 add	 DWORD PTR [rdi+136], esi

; 417  :     state->x.pos += len;

  00102	48 63 c6	 movsxd	 rax, esi
  00105	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 418  :     if (strm->avail_in >= state->size) {

  00109	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  0010c	8b 9f 88 00 00
	00		 mov	 ebx, DWORD PTR [rdi+136]
  00112	3b d8		 cmp	 ebx, eax
  00114	72 58		 jb	 SHORT $LN11@gzvprintf

; 419  :         left = strm->avail_in - state->size;
; 420  :         strm->avail_in = state->size;
; 421  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  00116	33 d2		 xor	 edx, edx
  00118	89 87 88 00 00
	00		 mov	 DWORD PTR [rdi+136], eax
  0011e	48 8b cf	 mov	 rcx, rdi
  00121	2b d8		 sub	 ebx, eax
  00123	e8 00 00 00 00	 call	 gz_comp
  00128	83 f8 ff	 cmp	 eax, -1
  0012b	75 1e		 jne	 SHORT $LN12@gzvprintf

; 422  :             return state->err;

  0012d	8b 47 74	 mov	 eax, DWORD PTR [rdi+116]
$LN37@gzvprintf:
  00130	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00135	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 428  : }

  0013a	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0013f	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00144	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00148	41 5e		 pop	 r14
  0014a	c3		 ret	 0
$LN12@gzvprintf:

; 423  :         memmove(state->in, state->in + state->size, left);

  0014b	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  0014f	8b 57 28	 mov	 edx, DWORD PTR [rdi+40]
  00152	48 03 d1	 add	 rdx, rcx
  00155	44 8b c3	 mov	 r8d, ebx
  00158	e8 00 00 00 00	 call	 memmove

; 424  :         strm->next_in = state->in;

  0015d	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  00161	48 89 8f 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rcx

; 425  :         strm->avail_in = left;

  00168	89 9f 88 00 00
	00		 mov	 DWORD PTR [rdi+136], ebx
$LN11@gzvprintf:

; 426  :     }
; 427  :     return len;

  0016e	8b c6		 mov	 eax, esi
  00170	eb be		 jmp	 SHORT $LN37@gzvprintf
$LN10@gzvprintf:

; 413  :         return 0;

  00172	33 c0		 xor	 eax, eax
  00174	eb ba		 jmp	 SHORT $LN37@gzvprintf
$LN4@gzvprintf:

; 428  : }

  00176	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0017b	b8 fe ff ff ff	 mov	 eax, -2
  00180	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00185	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00189	41 5e		 pop	 r14
  0018b	c3		 ret	 0
gzvprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gzprintf
_TEXT	SEGMENT
file$ = 48
format$ = 56
gzprintf PROC						; COMDAT

; 430  : int ZEXPORTVA gzprintf(gzFile file, const char *format, ...) {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 431  :     va_list va;
; 432  :     int ret;
; 433  : 
; 434  :     va_start(va, format);

  00013	4c 8d 44 24 40	 lea	 r8, QWORD PTR format$[rsp+8]

; 435  :     ret = gzvprintf(file, format, va);

  00018	e8 00 00 00 00	 call	 gzvprintf

; 436  :     va_end(va);
; 437  :     return ret;
; 438  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
gzprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gzflush
_TEXT	SEGMENT
file$ = 48
flush$ = 56
gzflush	PROC						; COMDAT

; 528  : int ZEXPORT gzflush(gzFile file, int flush) {

$LN22:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 529  :     gz_statep state;
; 530  : 
; 531  :     /* get internal structure */
; 532  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	74 47		 je	 SHORT $LN4@gzflush

; 533  :         return Z_STREAM_ERROR;
; 534  :     state = (gz_statep)file;
; 535  : 
; 536  :     /* check that we're writing and that there's no error */
; 537  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00014	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  0001b	75 3e		 jne	 SHORT $LN4@gzflush
  0001d	83 79 74 00	 cmp	 DWORD PTR [rcx+116], 0
  00021	75 38		 jne	 SHORT $LN4@gzflush

; 538  :         return Z_STREAM_ERROR;
; 539  : 
; 540  :     /* check flush parameter */
; 541  :     if (flush < 0 || flush > Z_FINISH)

  00023	83 fa 04	 cmp	 edx, 4
  00026	77 33		 ja	 SHORT $LN4@gzflush

; 542  :         return Z_STREAM_ERROR;
; 543  : 
; 544  :     /* check for seek request */
; 545  :     if (state->seek) {

  00028	83 79 70 00	 cmp	 DWORD PTR [rcx+112], 0
  0002c	74 15		 je	 SHORT $LN12@gzflush

; 546  :         state->seek = 0;
; 547  :         if (gz_zero(state, state->skip) == -1)

  0002e	48 8b 51 68	 mov	 rdx, QWORD PTR [rcx+104]
  00032	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [rcx+112], 0
  00039	e8 00 00 00 00	 call	 gz_zero
  0003e	83 f8 ff	 cmp	 eax, -1
  00041	74 0a		 je	 SHORT $LN20@gzflush
$LN12@gzflush:

; 548  :             return state->err;
; 549  :     }
; 550  : 
; 551  :     /* compress remaining data with requested flush */
; 552  :     (void)gz_comp(state, flush);

  00043	8b d7		 mov	 edx, edi
  00045	48 8b cb	 mov	 rcx, rbx
  00048	e8 00 00 00 00	 call	 gz_comp
$LN20@gzflush:

; 553  :     return state->err;
; 554  : }

  0004d	8b 43 74	 mov	 eax, DWORD PTR [rbx+116]
  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
$LN4@gzflush:
  0005b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00060	b8 fe ff ff ff	 mov	 eax, -2
  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5f		 pop	 rdi
  0006a	c3		 ret	 0
gzflush	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Programming\AGE\Engine\libs\vendor\zlib\gzwrite.c
;	COMDAT gzsetparams
_TEXT	SEGMENT
file$ = 64
level$ = 72
strategy$ = 80
gzsetparams PROC					; COMDAT

; 557  : int ZEXPORT gzsetparams(gzFile file, int level, int strategy) {

$LN32:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	45 8b f0	 mov	 r14d, r8d
  00011	8b ea		 mov	 ebp, edx
  00013	48 8b d9	 mov	 rbx, rcx

; 558  :     gz_statep state;
; 559  :     z_streamp strm;
; 560  : 
; 561  :     /* get internal structure */
; 562  :     if (file == NULL)

  00016	48 85 c9	 test	 rcx, rcx
  00019	0f 84 d0 00 00
	00		 je	 $LN4@gzsetparam

; 563  :         return Z_STREAM_ERROR;
; 564  :     state = (gz_statep)file;
; 565  :     strm = &(state->strm);
; 566  : 
; 567  :     /* check that we're writing and that there's no error */
; 568  :     if (state->mode != GZ_WRITE || state->err != Z_OK || state->direct)

  0001f	81 79 18 b1 79
	00 00		 cmp	 DWORD PTR [rcx+24], 31153 ; 000079b1H
  00026	0f 85 c3 00 00
	00		 jne	 $LN4@gzsetparam
  0002c	83 79 74 00	 cmp	 DWORD PTR [rcx+116], 0
  00030	0f 85 b9 00 00
	00		 jne	 $LN4@gzsetparam
  00036	83 79 40 00	 cmp	 DWORD PTR [rcx+64], 0
  0003a	0f 85 af 00 00
	00		 jne	 $LN4@gzsetparam
  00040	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 569  :         return Z_STREAM_ERROR;
; 570  : 
; 571  :     /* if no change is requested, then do nothing */
; 572  :     if (level == state->level && strategy == state->strategy)

  00045	48 8d 71 58	 lea	 rsi, QWORD PTR [rcx+88]
  00049	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0004e	48 8d 79 5c	 lea	 rdi, QWORD PTR [rcx+92]
  00052	3b 16		 cmp	 edx, DWORD PTR [rsi]
  00054	75 09		 jne	 SHORT $LN5@gzsetparam
  00056	44 3b 07	 cmp	 r8d, DWORD PTR [rdi]
  00059	75 04		 jne	 SHORT $LN5@gzsetparam

; 573  :         return Z_OK;

  0005b	33 c0		 xor	 eax, eax
  0005d	eb 5a		 jmp	 SHORT $LN28@gzsetparam
$LN5@gzsetparam:

; 574  : 
; 575  :     /* check for seek request */
; 576  :     if (state->seek) {

  0005f	83 79 70 00	 cmp	 DWORD PTR [rcx+112], 0
  00063	48 8b c7	 mov	 rax, rdi
  00066	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  0006b	4c 8b e6	 mov	 r12, rsi
  0006e	74 1d		 je	 SHORT $LN12@gzsetparam

; 577  :         state->seek = 0;
; 578  :         if (gz_zero(state, state->skip) == -1)

  00070	48 8b 51 68	 mov	 rdx, QWORD PTR [rcx+104]
  00074	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [rcx+112], 0
  0007b	e8 00 00 00 00	 call	 gz_zero
  00080	83 f8 ff	 cmp	 eax, -1
  00083	74 2c		 je	 SHORT $LN30@gzsetparam
  00085	4c 8d 63 58	 lea	 r12, QWORD PTR [rbx+88]
  00089	48 8d 43 5c	 lea	 rax, QWORD PTR [rbx+92]
$LN12@gzsetparam:

; 579  :             return state->err;
; 580  :     }
; 581  : 
; 582  :     /* change compression parameters for subsequent input */
; 583  :     if (state->size) {

  0008d	83 7b 28 00	 cmp	 DWORD PTR [rbx+40], 0
  00091	74 53		 je	 SHORT $LN8@gzsetparam

; 584  :         /* flush previous input with previous parameters before changing */
; 585  :         if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)

  00093	83 bb 88 00 00
	00 00		 cmp	 DWORD PTR [rbx+136], 0
  0009a	74 36		 je	 SHORT $LN9@gzsetparam
  0009c	ba 05 00 00 00	 mov	 edx, 5
  000a1	48 8b cb	 mov	 rcx, rbx
  000a4	48 8b f8	 mov	 rdi, rax
  000a7	e8 00 00 00 00	 call	 gz_comp
  000ac	83 f8 ff	 cmp	 eax, -1
  000af	75 21		 jne	 SHORT $LN9@gzsetparam
$LN30@gzsetparam:

; 586  :             return state->err;

  000b1	8b 43 74	 mov	 eax, DWORD PTR [rbx+116]
$LN29@gzsetparam:
  000b4	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
$LN28@gzsetparam:
  000b9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000be	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 592  : }

  000c3	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cc	41 5f		 pop	 r15
  000ce	41 5e		 pop	 r14
  000d0	5d		 pop	 rbp
  000d1	c3		 ret	 0
$LN9@gzsetparam:

; 587  :         deflateParams(strm, level, strategy);

  000d2	45 8b c6	 mov	 r8d, r14d
  000d5	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  000dc	8b d5		 mov	 edx, ebp
  000de	e8 00 00 00 00	 call	 deflateParams
  000e3	49 8b f4	 mov	 rsi, r12
$LN8@gzsetparam:

; 588  :     }
; 589  :     state->level = level;

  000e6	89 2e		 mov	 DWORD PTR [rsi], ebp

; 590  :     state->strategy = strategy;
; 591  :     return Z_OK;

  000e8	33 c0		 xor	 eax, eax
  000ea	44 89 37	 mov	 DWORD PTR [rdi], r14d
  000ed	eb c5		 jmp	 SHORT $LN29@gzsetparam
$LN4@gzsetparam:

; 592  : }

  000ef	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000f4	b8 fe ff ff ff	 mov	 eax, -2
  000f9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fd	41 5f		 pop	 r15
  000ff	41 5e		 pop	 r14
  00101	5d		 pop	 rbp
  00102	c3		 ret	 0
gzsetparams ENDP
_TEXT	ENDS
END
